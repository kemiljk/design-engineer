"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-from-markdown";
exports.ids = ["vendor-chunks/mdast-util-from-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(ssr)/./node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(ssr)/./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(ssr)/./node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(ssr)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(ssr)/./node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(ssr)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ \n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */ function fromMarkdown(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark__WEBPACK_IMPORTED_MODULE_0__.postprocess)((0,micromark__WEBPACK_IMPORTED_MODULE_1__.parse)(options).document().write((0,micromark__WEBPACK_IMPORTED_MODULE_2__.preprocess)()(value, encoding, true))));\n}\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            data\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered || events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            switch(event[1].type){\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuote:\n                    {\n                        if (event[0] === \"enter\") {\n                            containerBalance++;\n                        } else {\n                            containerBalance--;\n                        }\n                        atMarker = undefined;\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank:\n                    {\n                        if (event[0] === \"enter\") {\n                            if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                                firstBlankLineIndex = index;\n                            }\n                            atMarker = undefined;\n                        }\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemValue:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemMarker:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefixWhitespace:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        atMarker = undefined;\n                    }\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered || event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix) {\n                    /** @type {Token} */ const item = {\n                        type: \"listItem\",\n                        _spread: false,\n                        start: Object.assign({}, event[1].start),\n                        // @ts-expect-error: weâ€™ll add `end` in a second.\n                        end: undefined\n                    };\n                    listItem = item;\n                    events.splice(index, 0, [\n                        \"enter\",\n                        item,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(parent, \"expected `parent`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in parent, \"expected `parent`\");\n        /** @type {Array<Nodes>} */ const siblings = parent.children;\n        siblings.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        node.position = {\n            start: point(token.start),\n            // @ts-expect-error: `end` will be patched later.\n            end: undefined\n        };\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): itâ€™s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        this.data.expectingFirstListItemValue = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (this.data.expectingFirstListItemValue) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected nodes on stack\");\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            this.data.expectingFirstListItemValue = undefined;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (this.data.flowCodeInside) return;\n        this.buffer();\n        this.data.flowCodeInside = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        this.data.flowCodeInside = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        this.data.setextHeadingSlurpLineEnding = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).codePointAt(0) === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        this.data.setextHeadingSlurpLineEnding = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in node, \"expected parent on stack\");\n        /** @type {Array<Nodes>} */ const siblings = node.children;\n        let tail = siblings[siblings.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            tail.position = {\n                start: point(token.start),\n                // @ts-expect-error: weâ€™ll add `end` later.\n                end: undefined\n            };\n            siblings.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(context, \"expected `node`\");\n        // If weâ€™re at a hard break, include the line ending in there.\n        if (this.data.atHardBreak) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            this.data.atHardBreak = undefined;\n            return;\n        }\n        if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        this.data.atHardBreak = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        this.data.inReference = true;\n        if (node.type === \"link\") {\n            /** @type {Array<PhrasingContent>} */ const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        this.data.inReference = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        this.data.referenceType = \"collapsed\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        this.data.referenceType = \"full\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        this.data.characterReferenceType = token.type;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = this.data.characterReferenceType;\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.characterReferenceMarkerNumeric ? micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            this.data.characterReferenceType = undefined;\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected `node`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node.position`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        return {\n            type: \"heading\",\n            // @ts-expect-error `depth` will be set later.\n            depth: 0,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {Html} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            switch(key){\n                case \"canContainEols\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"transforms\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"enter\":\n                case \"exit\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            Object.assign(combined[key], right);\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNDLEdBRUQ7O0NBRUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBRWtDO0FBQ1U7QUFDVztBQUN5QztBQUN4QztBQUNjO0FBQ1Y7QUFDaUI7QUFDZjtBQUUvRCxNQUFNYyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNDLGFBQWFDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxPQUFPO0lBQ25ELElBQUksT0FBT0QsYUFBYSxVQUFVO1FBQ2hDQyxVQUFVRDtRQUNWQSxXQUFXRTtJQUNiO0lBRUEsT0FBT0MsU0FBU0YsU0FDZGYsc0RBQVdBLENBQ1RELGdEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNsQixxREFBVUEsR0FBR1ksT0FBT0MsVUFBVTtBQUdwRTtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTRyxTQUFTRixPQUFPO0lBQ3ZCLG1CQUFtQixHQUNuQixNQUFNSyxTQUFTO1FBQ2JDLFlBQVksRUFBRTtRQUNkQyxnQkFBZ0I7WUFBQztZQUFZO1lBQVk7WUFBVztZQUFhO1NBQVM7UUFDMUVDLE9BQU87WUFDTEMsVUFBVUMsT0FBT0M7WUFDakJDLGtCQUFrQkM7WUFDbEJDLGVBQWVEO1lBQ2ZFLFlBQVlMLE9BQU9NO1lBQ25CQyxZQUFZUCxPQUFPTztZQUNuQkMsaUJBQWlCTDtZQUNqQk0sb0JBQW9CTjtZQUNwQk8sWUFBWVYsT0FBT1c7WUFDbkJDLHFCQUFxQkM7WUFDckJDLHFCQUFx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UixzQ0FDRXVDLE1BQU0vRixJQUFJLEdBQ1YsUUFDQW5ILGdGQUFpQkEsQ0FBQztZQUFDdUksT0FBTzJFLE1BQU0zRSxLQUFLO1lBQUVLLEtBQUtzRSxNQUFNdEUsR0FBRztRQUFBLEtBQ3JEO0lBRU47QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb20tbWFya2Rvd24vZGV2L2xpYi9pbmRleC5qcz9iZWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CcmVha30gQnJlYWtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQmxvY2txdW90ZX0gQmxvY2txdW90ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkRlZmluaXRpb259IERlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRW1waGFzaXN9IEVtcGhhc2lzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhlYWRpbmd9IEhlYWRpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSHRtbH0gSHRtbFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZX0gSW1hZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW5saW5lQ29kZX0gSW5saW5lQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaW5rfSBMaW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3R9IExpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlzdEl0ZW19IExpc3RJdGVtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLk5vZGVzfSBOb2Rlc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJhZ3JhcGh9IFBhcmFncmFwaFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJlbnR9IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5SZWZlcmVuY2VUeXBlfSBSZWZlcmVuY2VUeXBlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuU3Ryb25nfSBTdHJvbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGV4dH0gVGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UaGVtYXRpY0JyZWFrfSBUaGVtYXRpY0JyZWFrXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FbmNvZGluZ30gRW5jb2RpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlT3B0aW9uc30gUGFyc2VPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5WYWx1ZX0gVmFsdWVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuQ29tcGlsZURhdGF9IENvbXBpbGVEYXRhXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T21pdDxQYXJlbnQsICdjaGlsZHJlbicgfCAndHlwZSc+ICYge3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBBcnJheTxQaHJhc2luZ0NvbnRlbnQ+fX0gRnJhZ21lbnRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1cbiAqICAgRXh0cmEgdHJhbnNmb3JtLCB0byBjaGFuZ2UgdGhlIEFTVCBhZnRlcndhcmRzLlxuICogQHBhcmFtIHtSb290fSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge1Jvb3QgfCBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZH1cbiAqICAgTmV3IHRyZWUgb3Igbm90aGluZyAoaW4gd2hpY2ggY2FzZSB0aGUgY3VycmVudCB0cmVlIGlzIHVzZWQpLlxuICpcbiAqIEBjYWxsYmFjayBIYW5kbGVcbiAqICAgSGFuZGxlIGEgdG9rZW4uXG4gKiBAcGFyYW0ge0NvbXBpbGVDb250ZXh0fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICogICBDdXJyZW50IHRva2VuLlxuICogQHJldHVybnMge3VuZGVmaW5lZCB8IHZvaWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIEhhbmRsZT59IEhhbmRsZXNcbiAqICAgVG9rZW4gdHlwZXMgbWFwcGluZyB0byBoYW5kbGVzXG4gKlxuICogQGNhbGxiYWNrIE9uRW50ZXJFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiwgYnV0IGl0IGlzIGNsb3NlZCAoYnkgdGhlXG4gKiAgIGBsZWZ0YCB0b2tlbikgb3IgYmVjYXVzZSB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gbGVmdFxuICogICBMZWZ0IHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gcmlnaHRcbiAqICAgUmlnaHQgdG9rZW4uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEBjYWxsYmFjayBPbkV4aXRFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiBidXQgaXQgaXMgY2xvc2VkIGJ5XG4gKiAgIGV4aXRpbmcgdGhlIGBsZWZ0YCB0b2tlbi5cbiAqIEBwYXJhbSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW59IGxlZnRcbiAqICAgTGVmdCB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHJpZ2h0XG4gKiAgIFJpZ2h0IHRva2VuLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAdHlwZWRlZiB7W1Rva2VuLCBPbkVudGVyRXJyb3IgfCB1bmRlZmluZWRdfSBUb2tlblR1cGxlXG4gKiAgIE9wZW4gdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRoIGFuIG9wdGlvbmFsIGVycm9yIGhhbmRsZXIgZm9yIHdoZW5cbiAqICAgdGhhdCB0b2tlbiBpc27igJl0IGNsb3NlZCBwcm9wZXJseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIENvbmZpZ1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqICAgV2UgaGF2ZSBvdXIgZGVmYXVsdHMsIGJ1dCBleHRlbnNpb25zIHdpbGwgYWRkIG1vcmUuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGNhbkNvbnRhaW5Fb2xzXG4gKiAgIFRva2VuIHR5cGVzIHdoZXJlIGxpbmUgZW5kaW5ncyBhcmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlc30gZW50ZXJcbiAqICAgT3BlbmluZyBoYW5kbGVzLlxuICogQHByb3BlcnR5IHtIYW5kbGVzfSBleGl0XG4gKiAgIENsb3NpbmcgaGFuZGxlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8VHJhbnNmb3JtPn0gdHJhbnNmb3Jtc1xuICogICBUcmVlIHRyYW5zZm9ybXMuXG4gKlxuICogQHR5cGVkZWYge1BhcnRpYWw8Q29uZmlnPn0gRXh0ZW5zaW9uXG4gKiAgIENoYW5nZSBob3cgbWFya2Rvd24gdG9rZW5zIGZyb20gbWljcm9tYXJrIGFyZSB0dXJuZWQgaW50byBtZGFzdC5cbiAqXG4gKiBAdHlwZWRlZiBDb21waWxlQ29udGV4dFxuICogICBtZGFzdCBjb21waWxlciBjb250ZXh0LlxuICogQHByb3BlcnR5IHtBcnJheTxGcmFnbWVudCB8IE5vZGVzPn0gc3RhY2tcbiAqICAgU3RhY2sgb2Ygbm9kZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHVwbGU+fSB0b2tlblN0YWNrXG4gKiAgIFN0YWNrIG9mIHRva2Vucy5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiB1bmRlZmluZWR9IGJ1ZmZlclxuICogICBDYXB0dXJlIHNvbWUgb2YgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHN0cmluZ30gcmVzdW1lXG4gKiAgIFN0b3AgY2FwdHVyaW5nIGFuZCBhY2Nlc3MgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIG5vZGU6IE5vZGVzLCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkVudGVyRXJyb3IpID0+IHVuZGVmaW5lZH0gZW50ZXJcbiAqICAgRW50ZXIgYSBub2RlLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIHRva2VuOiBUb2tlbiwgb25FcnJvcj86IE9uRXhpdEVycm9yKSA9PiB1bmRlZmluZWR9IGV4aXRcbiAqICAgRXhpdCBhIG5vZGUuXG4gKiBAcHJvcGVydHkge1Rva2VuaXplQ29udGV4dFsnc2xpY2VTZXJpYWxpemUnXX0gc2xpY2VTZXJpYWxpemVcbiAqICAgR2V0IHRoZSBzdHJpbmcgdmFsdWUgb2YgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Q29uZmlnfSBjb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Q29tcGlsZURhdGF9IGRhdGFcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kOyBrZXkvdmFsdWUgc3RvcmUuXG4gKlxuICogQHR5cGVkZWYgRnJvbU1hcmtkb3duT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciBob3cgdG8gYnVpbGQgbWRhc3QuXG4gKiBAcHJvcGVydHkge0FycmF5PEV4dGVuc2lvbiB8IEFycmF5PEV4dGVuc2lvbj4+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW21kYXN0RXh0ZW5zaW9uc11cbiAqICAgRXh0ZW5zaW9ucyBmb3IgdGhpcyB1dGlsaXR5IHRvIGNoYW5nZSBob3cgdG9rZW5zIGFyZSB0dXJuZWQgaW50byBhIHRyZWUuXG4gKlxuICogQHR5cGVkZWYge1BhcnNlT3B0aW9ucyAmIEZyb21NYXJrZG93bk9wdGlvbnN9IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbWRhc3QtdXRpbC10by1zdHJpbmcnXG5pbXBvcnQge3BhcnNlLCBwb3N0cHJvY2VzcywgcHJlcHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrJ1xuaW1wb3J0IHtkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtkZWNvZGVTdHJpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtjb2RlcywgY29uc3RhbnRzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuaW1wb3J0IHtkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge3N0cmluZ2lmeVBvc2l0aW9ufSBmcm9tICd1bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbidcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBUdXJuIG1hcmtkb3duIGludG8gYSBzeW50YXggdHJlZS5cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge0VuY29kaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nXVxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Um9vdH1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtSb290fVxuICpcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiAgIE1hcmtkb3duIHRvIHBhcnNlLlxuICogQHBhcmFtIHtFbmNvZGluZyB8IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5jb2RpbmddXG4gKiAgIENoYXJhY3RlciBlbmNvZGluZyBmb3Igd2hlbiBgdmFsdWVgIGlzIGBCdWZmZXJgLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyB7Um9vdH1cbiAqICAgbWRhc3QgdHJlZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXJrZG93bih2YWx1ZSwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVyKG9wdGlvbnMpKFxuICAgIHBvc3Rwcm9jZXNzKFxuICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSlcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBOb3RlIHRoaXMgY29tcGlsZXIgb25seSB1bmRlcnN0YW5kIGNvbXBsZXRlIGJ1ZmZlcmluZywgbm90IHN0cmVhbWluZy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gY29tcGlsZXIob3B0aW9ucykge1xuICAvKiogQHR5cGUge0NvbmZpZ30gKi9cbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgIGNhbkNvbnRhaW5Fb2xzOiBbJ2VtcGhhc2lzJywgJ2ZyYWdtZW50JywgJ2hlYWRpbmcnLCAncGFyYWdyYXBoJywgJ3N0cm9uZyddLFxuICAgIGVudGVyOiB7XG4gICAgICBhdXRvbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogb25lbnRlcmRhdGEsXG4gICAgICBhdXRvbGlua0VtYWlsOiBvbmVudGVyZGF0YSxcbiAgICAgIGF0eEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgIGJsb2NrUXVvdGU6IG9wZW5lcihibG9ja1F1b3RlKSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZTogb25lbnRlcmRhdGEsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2U6IG9uZW50ZXJkYXRhLFxuICAgICAgY29kZUZlbmNlZDogb3BlbmVyKGNvZGVGbG93KSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IGJ1ZmZlcixcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IGJ1ZmZlcixcbiAgICAgIGNvZGVJbmRlbnRlZDogb3BlbmVyKGNvZGVGbG93LCBidWZmZXIpLFxuICAgICAgY29kZVRleHQ6IG9wZW5lcihjb2RlVGV4dCwgYnVmZmVyKSxcbiAgICAgIGNvZGVUZXh0RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBkYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGNvZGVGbG93VmFsdWU6IG9uZW50ZXJkYXRhLFxuICAgICAgZGVmaW5pdGlvbjogb3BlbmVyKGRlZmluaXRpb24pLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgZW1waGFzaXM6IG9wZW5lcihlbXBoYXNpcyksXG4gICAgICBoYXJkQnJlYWtFc2NhcGU6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgaHRtbEZsb3c6IG9wZW5lcihodG1sLCBidWZmZXIpLFxuICAgICAgaHRtbEZsb3dEYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGh0bWxUZXh0OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgIGh0bWxUZXh0RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBpbWFnZTogb3BlbmVyKGltYWdlKSxcbiAgICAgIGxhYmVsOiBidWZmZXIsXG4gICAgICBsaW5rOiBvcGVuZXIobGluayksXG4gICAgICBsaXN0SXRlbTogb3BlbmVyKGxpc3RJdGVtKSxcbiAgICAgIGxpc3RJdGVtVmFsdWU6IG9uZW50ZXJsaXN0aXRlbXZhbHVlLFxuICAgICAgbGlzdE9yZGVyZWQ6IG9wZW5lcihsaXN0LCBvbmVudGVybGlzdG9yZGVyZWQpLFxuICAgICAgbGlzdFVub3JkZXJlZDogb3BlbmVyKGxpc3QpLFxuICAgICAgcGFyYWdyYXBoOiBvcGVuZXIocGFyYWdyYXBoKSxcbiAgICAgIHJlZmVyZW5jZTogb25lbnRlcnJlZmVyZW5jZSxcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogYnVmZmVyLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgcmVzb3VyY2VUaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgc2V0ZXh0SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgc3Ryb25nOiBvcGVuZXIoc3Ryb25nKSxcbiAgICAgIHRoZW1hdGljQnJlYWs6IG9wZW5lcih0aGVtYXRpY0JyZWFrKVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgYXR4SGVhZGluZzogY2xvc2VyKCksXG4gICAgICBhdHhIZWFkaW5nU2VxdWVuY2U6IG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSxcbiAgICAgIGF1dG9saW5rOiBjbG9zZXIoKSxcbiAgICAgIGF1dG9saW5rRW1haWw6IG9uZXhpdGF1dG9saW5rZW1haWwsXG4gICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmV4aXRhdXRvbGlua3Byb3RvY29sLFxuICAgICAgYmxvY2tRdW90ZTogY2xvc2VyKCksXG4gICAgICBjaGFyYWN0ZXJFc2NhcGVWYWx1ZTogb25leGl0ZGF0YSxcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZTogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUsXG4gICAgICBjb2RlRmVuY2VkOiBjbG9zZXIob25leGl0Y29kZWZlbmNlZCksXG4gICAgICBjb2RlRmVuY2VkRmVuY2U6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IG9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8sXG4gICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhLFxuICAgICAgY29kZUZsb3dWYWx1ZTogb25leGl0ZGF0YSxcbiAgICAgIGNvZGVJbmRlbnRlZDogY2xvc2VyKG9uZXhpdGNvZGVpbmRlbnRlZCksXG4gICAgICBjb2RlVGV4dDogY2xvc2VyKG9uZXhpdGNvZGV0ZXh0KSxcbiAgICAgIGNvZGVUZXh0RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGRhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBkZWZpbml0aW9uOiBjbG9zZXIoKSxcbiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyxcbiAgICAgIGVtcGhhc2lzOiBjbG9zZXIoKSxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogY2xvc2VyKG9uZXhpdGhhcmRicmVhayksXG4gICAgICBoYXJkQnJlYWtUcmFpbGluZzogY2xvc2VyKG9uZXhpdGhhcmRicmVhayksXG4gICAgICBodG1sRmxvdzogY2xvc2VyKG9uZXhpdGh0bWxmbG93KSxcbiAgICAgIGh0bWxGbG93RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGh0bWxUZXh0OiBjbG9zZXIob25leGl0aHRtbHRleHQpLFxuICAgICAgaHRtbFRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgaW1hZ2U6IGNsb3NlcihvbmV4aXRpbWFnZSksXG4gICAgICBsYWJlbDogb25leGl0bGFiZWwsXG4gICAgICBsYWJlbFRleHQ6IG9uZXhpdGxhYmVsdGV4dCxcbiAgICAgIGxpbmVFbmRpbmc6IG9uZXhpdGxpbmVlbmRpbmcsXG4gICAgICBsaW5rOiBjbG9zZXIob25leGl0bGluayksXG4gICAgICBsaXN0SXRlbTogY2xvc2VyKCksXG4gICAgICBsaXN0T3JkZXJlZDogY2xvc2VyKCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgIHBhcmFncmFwaDogY2xvc2VyKCksXG4gICAgICByZWZlcmVuY2VTdHJpbmc6IG9uZXhpdHJlZmVyZW5jZXN0cmluZyxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IG9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nLFxuICAgICAgcmVzb3VyY2U6IG9uZXhpdHJlc291cmNlLFxuICAgICAgc2V0ZXh0SGVhZGluZzogY2xvc2VyKG9uZXhpdHNldGV4dGhlYWRpbmcpLFxuICAgICAgc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZTogb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSxcbiAgICAgIHNldGV4dEhlYWRpbmdUZXh0OiBvbmV4aXRzZXRleHRoZWFkaW5ndGV4dCxcbiAgICAgIHN0cm9uZzogY2xvc2VyKCksXG4gICAgICB0aGVtYXRpY0JyZWFrOiBjbG9zZXIoKVxuICAgIH1cbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcsIChvcHRpb25zIHx8IHt9KS5tZGFzdEV4dGVuc2lvbnMgfHwgW10pXG5cbiAgLyoqIEB0eXBlIHtDb21waWxlRGF0YX0gKi9cbiAgY29uc3QgZGF0YSA9IHt9XG5cbiAgcmV0dXJuIGNvbXBpbGVcblxuICAvKipcbiAgICogVHVybiBtaWNyb21hcmsgZXZlbnRzIGludG8gYW4gbWRhc3QgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiAgIEV2ZW50cy5cbiAgICogQHJldHVybnMge1Jvb3R9XG4gICAqICAgbWRhc3QgdHJlZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGUoZXZlbnRzKSB7XG4gICAgLyoqIEB0eXBlIHtSb290fSAqL1xuICAgIGxldCB0cmVlID0ge3R5cGU6ICdyb290JywgY2hpbGRyZW46IFtdfVxuICAgIC8qKiBAdHlwZSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHN0YWNrOiBbdHJlZV0sXG4gICAgICB0b2tlblN0YWNrOiBbXSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGVudGVyLFxuICAgICAgZXhpdCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHJlc3VtZSxcbiAgICAgIGRhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGxpc3RTdGFjayA9IFtdXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgLy8gV2UgcHJlcHJvY2VzcyBsaXN0cyB0byBhZGQgYGxpc3RJdGVtYCB0b2tlbnMsIGFuZCB0byBpbmZlciB3aGV0aGVyXG4gICAgICAvLyBpdGVtcyB0aGUgbGlzdCBpdHNlbGYgYXJlIHNwcmVhZCBvdXQuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBsaXN0U3RhY2sucHVzaChpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWlsID0gbGlzdFN0YWNrLnBvcCgpXG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWlsID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGxpc3Qgb3QgYmUgb3BlbicpXG4gICAgICAgICAgaW5kZXggPSBwcmVwYXJlTGlzdChldmVudHMsIHRhaWwsIGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gY29uZmlnW2V2ZW50c1tpbmRleF1bMF1dXG5cbiAgICAgIGlmIChvd24uY2FsbChoYW5kbGVyLCBldmVudHNbaW5kZXhdWzFdLnR5cGUpKSB7XG4gICAgICAgIGhhbmRsZXJbZXZlbnRzW2luZGV4XVsxXS50eXBlXS5jYWxsKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7c2xpY2VTZXJpYWxpemU6IGV2ZW50c1tpbmRleF1bMl0uc2xpY2VTZXJpYWxpemV9LFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICksXG4gICAgICAgICAgZXZlbnRzW2luZGV4XVsxXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRva2VucyBzdGlsbCBiZWluZyBvcGVuLlxuICAgIGlmIChjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQudG9rZW5TdGFja1tjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdW5kZWZpbmVkLCB0YWlsWzBdKVxuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgYHJvb3RgIHBvc2l0aW9uLlxuICAgIHRyZWUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwID8gZXZlbnRzWzBdWzFdLnN0YXJ0IDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKSxcbiAgICAgIGVuZDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZFxuICAgICAgICAgIDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENhbGwgdHJhbnNmb3Jtcy5cbiAgICBpbmRleCA9IC0xXG4gICAgd2hpbGUgKCsraW5kZXggPCBjb25maWcudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgIHRyZWUgPSBjb25maWcudHJhbnNmb3Jtc1tpbmRleF0odHJlZSkgfHwgdHJlZVxuICAgIH1cblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3QoZXZlbnRzLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQgLSAxXG4gICAgbGV0IGNvbnRhaW5lckJhbGFuY2UgPSAtMVxuICAgIGxldCBsaXN0U3ByZWFkID0gZmFsc2VcbiAgICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaXN0SXRlbVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZmlyc3RCbGFua0xpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYXRNYXJrZXJcblxuICAgIHdoaWxlICgrK2luZGV4IDw9IGxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAgIHN3aXRjaCAoZXZlbnRbMV0udHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLmxpc3RVbm9yZGVyZWQ6XG4gICAgICAgIGNhc2UgdHlwZXMubGlzdE9yZGVyZWQ6XG4gICAgICAgIGNhc2UgdHlwZXMuYmxvY2tRdW90ZToge1xuICAgICAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgY29udGFpbmVyQmFsYW5jZSsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UtLVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSB0eXBlcy5saW5lRW5kaW5nQmxhbms6IHtcbiAgICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGlzdEl0ZW0gJiZcbiAgICAgICAgICAgICAgIWF0TWFya2VyICYmXG4gICAgICAgICAgICAgICFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgICAgICFmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgdHlwZXMubGluZVByZWZpeDpcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbVZhbHVlOlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtTWFya2VyOlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtUHJlZml4OlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZToge1xuICAgICAgICAgIC8vIEVtcHR5LlxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeCkgfHxcbiAgICAgICAgKGNvbnRhaW5lckJhbGFuY2UgPT09IC0xICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkIHx8XG4gICAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtKSB7XG4gICAgICAgICAgbGV0IHRhaWxJbmRleCA9IGluZGV4XG4gICAgICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICB3aGlsZSAodGFpbEluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhaWxFdmVudCA9IGV2ZW50c1t0YWlsSW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsRXZlbnRbMF0gPT09ICdleGl0JykgY29udGludWVcblxuICAgICAgICAgICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2xpbmVJbmRleF1bMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgICAgIGxpc3RTcHJlYWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdcbiAgICAgICAgICAgICAgbGluZUluZGV4ID0gdGFpbEluZGV4XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVNYXJrZXIgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtSW5kZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCAmJlxuICAgICAgICAgICAgKCFsaW5lSW5kZXggfHwgZmlyc3RCbGFua0xpbmVJbmRleCA8IGxpbmVJbmRleClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLl9zcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRml4IHBvc2l0aW9uLlxuICAgICAgICAgIGxpc3RJdGVtLmVuZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGxpbmVJbmRleCA/IGV2ZW50c1tsaW5lSW5kZXhdWzFdLnN0YXJ0IDogZXZlbnRbMV0uZW5kXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShsaW5lSW5kZXggfHwgaW5kZXgsIDAsIFsnZXhpdCcsIGxpc3RJdGVtLCBldmVudFsyXV0pXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgIGxlbmd0aCsrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBpdGVtLlxuICAgICAgICBpZiAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgX3NwcmVhZDogZmFsc2UsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRbMV0uc3RhcnQpLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2XigJlsbCBhZGQgYGVuZGAgaW4gYSBzZWNvbmQuXG4gICAgICAgICAgICBlbmQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0SXRlbSA9IGl0ZW1cbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAwLCBbJ2VudGVyJywgaXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSB1bmRlZmluZWRcbiAgICAgICAgICBhdE1hcmtlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50c1tzdGFydF1bMV0uX3NwcmVhZCA9IGxpc3RTcHJlYWRcbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9wZW5lciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7KHRva2VuOiBUb2tlbikgPT4gTm9kZXN9IGNyZWF0ZVxuICAgKiAgIENyZWF0ZSBhIG5vZGUuXG4gICAqIEBwYXJhbSB7SGFuZGxlIHwgdW5kZWZpbmVkfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9wZW5lcihjcmVhdGUsIGFuZCkge1xuICAgIHJldHVybiBvcGVuXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW4odG9rZW4pIHtcbiAgICAgIGVudGVyLmNhbGwodGhpcywgY3JlYXRlKHRva2VuKSwgdG9rZW4pXG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7dHlwZTogJ2ZyYWdtZW50JywgY2hpbGRyZW46IFtdfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqICAgQ29udGV4dC5cbiAgICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICAgKiAgIE5vZGUgdG8gZW50ZXIuXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqICAgQ29ycmVzcG9uZGluZyB0b2tlbi5cbiAgICogQHBhcmFtIHtPbkVudGVyRXJyb3IgfCB1bmRlZmluZWR9IFtlcnJvckhhbmRsZXJdXG4gICAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoaXMgdG9rZW4gaXMgb3BlbiwgYnV0IGl0IGlzIGNsb3NlZCBieSBzb21ldGhpbmcgZWxzZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXIobm9kZSwgdG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChwYXJlbnQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gcGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+fSAqL1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gICAgc2libGluZ3MucHVzaChub2RlKVxuICAgIHRoaXMuc3RhY2sucHVzaChub2RlKVxuICAgIHRoaXMudG9rZW5TdGFjay5wdXNoKFt0b2tlbiwgZXJyb3JIYW5kbGVyXSlcbiAgICBub2RlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cbiAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb3NlciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGFuZGxlIHwgdW5kZWZpbmVkfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNsb3NlcihhbmQpIHtcbiAgICByZXR1cm4gY2xvc2VcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvc2UodG9rZW4pIHtcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgICAgZXhpdC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqICAgQ29udGV4dC5cbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogICBDb3JyZXNwb25kaW5nIHRva2VuLlxuICAgKiBAcGFyYW0ge09uRXhpdEVycm9yIHwgdW5kZWZpbmVkfSBbb25FeGl0RXJyb3JdXG4gICAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFub3RoZXIgdG9rZW4gaXMgb3Blbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdCh0b2tlbiwgb25FeGl0RXJyb3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgYG5vZGVgJylcbiAgICBjb25zdCBvcGVuID0gdGhpcy50b2tlblN0YWNrLnBvcCgpXG5cbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgICAgdG9rZW4udHlwZSArXG4gICAgICAgICAgJ2AgKCcgK1xuICAgICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kfSkgK1xuICAgICAgICAgICcpOiBpdOKAmXMgbm90IG9wZW4nXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChvcGVuWzBdLnR5cGUgIT09IHRva2VuLnR5cGUpIHtcbiAgICAgIGlmIChvbkV4aXRFcnJvcikge1xuICAgICAgICBvbkV4aXRFcnJvci5jYWxsKHRoaXMsIHRva2VuLCBvcGVuWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG9wZW5bMV0gfHwgZGVmYXVsdE9uRXJyb3JcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHRva2VuLCBvcGVuWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydChub2RlLnR5cGUgIT09ICdmcmFnbWVudCcsICd1bmV4cGVjdGVkIGZyYWdtZW50IGBleGl0YGVkJylcbiAgICBhc3NlcnQobm9kZS5wb3NpdGlvbiwgJ2V4cGVjdGVkIGBwb3NpdGlvbmAgdG8gYmUgZGVmaW5lZCcpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzLnN0YWNrLnBvcCgpKVxuICB9XG5cbiAgLy9cbiAgLy8gSGFuZGxlcnMuXG4gIC8vXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0b3JkZXJlZCgpIHtcbiAgICB0aGlzLmRhdGEuZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0aXRlbXZhbHVlKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5leHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG4gICAgICBhc3NlcnQoYW5jZXN0b3IsICdleHBlY3RlZCBub2RlcyBvbiBzdGFjaycpXG4gICAgICBhc3NlcnQoYW5jZXN0b3IudHlwZSA9PT0gJ2xpc3QnLCAnZXhwZWN0ZWQgbGlzdCBvbiBzdGFjaycpXG4gICAgICBhbmNlc3Rvci5zdGFydCA9IE51bWJlci5wYXJzZUludChcbiAgICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbiksXG4gICAgICAgIGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgIClcbiAgICAgIHRoaXMuZGF0YS5leHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuICAgIG5vZGUubGFuZyA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG4gICAgbm9kZS5tZXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZSgpIHtcbiAgICAvLyBFeGl0IGlmIHRoaXMgaXMgdGhlIGNsb3NpbmcgZmVuY2UuXG4gICAgaWYgKHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSkgcmV0dXJuXG4gICAgdGhpcy5idWZmZXIoKVxuICAgIHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICB0aGlzLmRhdGEuZmxvd0NvZGVJbnNpZGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlaW5kZW50ZWQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29kZScsICdleHBlY3RlZCBjb2RlIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhLnJlcGxhY2UoLyhcXHI/XFxufFxccikkL2csICcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2RlZmluaXRpb24nLCAnZXhwZWN0ZWQgZGVmaW5pdGlvbiBvbiBzdGFjaycpXG5cbiAgICBub2RlLnRpdGxlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXR4aGVhZGluZ3NlcXVlbmNlKHRva2VuKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnLCAnZXhwZWN0ZWQgaGVhZGluZyBvbiBzdGFjaycpXG5cbiAgICBpZiAoIW5vZGUuZGVwdGgpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikubGVuZ3RoXG5cbiAgICAgIGFzc2VydChcbiAgICAgICAgZGVwdGggPT09IDEgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gMiB8fFxuICAgICAgICAgIGRlcHRoID09PSAzIHx8XG4gICAgICAgICAgZGVwdGggPT09IDQgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNSB8fFxuICAgICAgICAgIGRlcHRoID09PSA2LFxuICAgICAgICAnZXhwZWN0ZWQgYGRlcHRoYCBiZXR3ZWVuIGAxYCBhbmQgYDZgJ1xuICAgICAgKVxuXG4gICAgICBub2RlLmRlcHRoID0gZGVwdGhcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ3RleHQoKSB7XG4gICAgdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdoZWFkaW5nJywgJ2V4cGVjdGVkIGhlYWRpbmcgb24gc3RhY2snKVxuXG4gICAgbm9kZS5kZXB0aCA9XG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5jb2RlUG9pbnRBdCgwKSA9PT0gY29kZXMuZXF1YWxzVG8gPyAxIDogMlxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJkYXRhKHRva2VuKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gbm9kZSwgJ2V4cGVjdGVkIHBhcmVudCBvbiBzdGFjaycpXG4gICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz59ICovXG4gICAgY29uc3Qgc2libGluZ3MgPSBub2RlLmNoaWxkcmVuXG5cbiAgICBsZXQgdGFpbCA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIXRhaWwgfHwgdGFpbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIC8vIEFkZCBhIG5ldyB0ZXh0IG5vZGUuXG4gICAgICB0YWlsID0gdGV4dCgpXG4gICAgICB0YWlsLnBvc2l0aW9uID0ge1xuICAgICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZeKAmWxsIGFkZCBgZW5kYCBsYXRlci5cbiAgICAgICAgZW5kOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIHNpYmxpbmdzLnB1c2godGFpbClcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2godGFpbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGRhdGEodG9rZW4pIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGFzc2VydCh0YWlsLCAnZXhwZWN0ZWQgYSBgbm9kZWAgdG8gYmUgb24gdGhlIHN0YWNrJylcbiAgICBhc3NlcnQoJ3ZhbHVlJyBpbiB0YWlsLCAnZXhwZWN0ZWQgYSBgbGl0ZXJhbGAgdG8gYmUgb24gdGhlIHN0YWNrJylcbiAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIGBub2RlYCB0byBoYXZlIGFuIG9wZW4gcG9zaXRpb24nKVxuICAgIHRhaWwudmFsdWUgKz0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmVlbmRpbmcodG9rZW4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KGNvbnRleHQsICdleHBlY3RlZCBgbm9kZWAnKVxuXG4gICAgLy8gSWYgd2XigJlyZSBhdCBhIGhhcmQgYnJlYWssIGluY2x1ZGUgdGhlIGxpbmUgZW5kaW5nIGluIHRoZXJlLlxuICAgIGlmICh0aGlzLmRhdGEuYXRIYXJkQnJlYWspIHtcbiAgICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIGNvbnRleHQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgICBjb25zdCB0YWlsID0gY29udGV4dC5jaGlsZHJlbltjb250ZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIHRhaWwgdG8gaGF2ZSBhIHN0YXJ0aW5nIHBvc2l0aW9uJylcbiAgICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgICAgdGhpcy5kYXRhLmF0SGFyZEJyZWFrID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgJiZcbiAgICAgIGNvbmZpZy5jYW5Db250YWluRW9scy5pbmNsdWRlcyhjb250ZXh0LnR5cGUpXG4gICAgKSB7XG4gICAgICBvbmVudGVyZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGhhcmRicmVhaygpIHtcbiAgICB0aGlzLmRhdGEuYXRIYXJkQnJlYWsgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdodG1sJywgJ2V4cGVjdGVkIGh0bWwgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGh0bWx0ZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2h0bWwnLCAnZXhwZWN0ZWQgaHRtbCBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZXRleHQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaW5saW5lQ29kZScsICdleHBlY3RlZCBpbmxpbmUgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGluaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIC8vIE5vdGU6IHRoZXJlIGFyZSBhbHNvIGBpZGVudGlmaWVyYCBhbmQgYGxhYmVsYCBmaWVsZHMgb24gdGhpcyBsaW5rIG5vZGUhXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgLyBjbGVhbmVkIGhlcmUuXG5cbiAgICAvLyBUbyBkbzogY2xlYW4uXG4gICAgaWYgKHRoaXMuZGF0YS5pblJlZmVyZW5jZSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2VUeXBlfSAqL1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlIHx8ICdzaG9ydGN1dCdcblxuICAgICAgbm9kZS50eXBlICs9ICdSZWZlcmVuY2UnXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBub2RlLnJlZmVyZW5jZVR5cGUgPSByZWZlcmVuY2VUeXBlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS51cmxcbiAgICAgIGRlbGV0ZSBub2RlLnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmlkZW50aWZpZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmxhYmVsXG4gICAgfVxuXG4gICAgdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGltYWdlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdpbWFnZScsICdleHBlY3RlZCBpbWFnZSBvbiBzdGFjaycpXG5cbiAgICAvLyBOb3RlOiB0aGVyZSBhcmUgYWxzbyBgaWRlbnRpZmllcmAgYW5kIGBsYWJlbGAgZmllbGRzIG9uIHRoaXMgbGluayBub2RlIVxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIC8gY2xlYW5lZCBoZXJlLlxuXG4gICAgLy8gVG8gZG86IGNsZWFuLlxuICAgIGlmICh0aGlzLmRhdGEuaW5SZWZlcmVuY2UpIHtcbiAgICAgIC8qKiBAdHlwZSB7UmVmZXJlbmNlVHlwZX0gKi9cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbHRleHQodG9rZW4pIHtcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGNvbnN0IGFuY2VzdG9yID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG4gICAgYXNzZXJ0KGFuY2VzdG9yLCAnZXhwZWN0ZWQgYW5jZXN0b3Igb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIGFuY2VzdG9yLnR5cGUgPT09ICdpbWFnZScgfHwgYW5jZXN0b3IudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3Rhc2ggdGhpcyBvbiB0aGUgbm9kZSwgYXMgaXQgbWlnaHQgYmVjb21lIGEgcmVmZXJlbmNlXG4gICAgLy8gbGF0ZXIuXG4gICAgYW5jZXN0b3IubGFiZWwgPSBkZWNvZGVTdHJpbmcoc3RyaW5nKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNhbWUgYXMgYWJvdmUuXG4gICAgYW5jZXN0b3IuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoc3RyaW5nKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbCgpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChmcmFnbWVudCwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChmcmFnbWVudC50eXBlID09PSAnZnJhZ21lbnQnLCAnZXhwZWN0ZWQgZnJhZ21lbnQgb24gc3RhY2snKVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEFzc3VtZSBhIHJlZmVyZW5jZS5cbiAgICB0aGlzLmRhdGEuaW5SZWZlcmVuY2UgPSB0cnVlXG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnbGluaycpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UGhyYXNpbmdDb250ZW50Pn0gKi9cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZnJhZ21lbnQuY2hpbGRyZW5cblxuICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYWx0ID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2V0aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcbiAgICBub2RlLnRpdGxlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2UoKSB7XG4gICAgdGhpcy5kYXRhLmluUmVmZXJlbmNlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVycmVmZXJlbmNlKCkge1xuICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gJ2NvbGxhcHNlZCdcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlZmVyZW5jZXN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSByZWZlcmVuY2Ugb3IgbGluayByZWZlcmVuY2Ugb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3Rhc2ggdGhpcyBvbiB0aGUgbm9kZSwgYXMgaXQgbWlnaHQgYmVjb21lIGEgcmVmZXJlbmNlXG4gICAgLy8gbGF0ZXIuXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZSBhcyBhYm92ZS5cbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgICB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSA9ICdmdWxsJ1xuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyKHRva2VuKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCdcbiAgICApXG4gICAgdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGUgPSB0b2tlbi50eXBlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUodG9rZW4pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCB0eXBlID0gdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGVcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdmFsdWVcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YWx1ZSA9IGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWNcbiAgICAgICAgICA/IGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgICAgICA6IGNvbnN0YW50cy5udW1lcmljQmFzZUhleGFkZWNpbWFsXG4gICAgICApXG4gICAgICB0aGlzLmRhdGEuY2hhcmFjdGVyUmVmZXJlbmNlVHlwZSA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZShkYXRhKVxuICAgICAgYXNzZXJ0KHJlc3VsdCAhPT0gZmFsc2UsICdleHBlY3RlZCByZWZlcmVuY2UgdG8gZGVjb2RlJylcbiAgICAgIHZhbHVlID0gcmVzdWx0XG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQodGFpbCwgJ2V4cGVjdGVkIGBub2RlYCcpXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCBgbm9kZS5wb3NpdGlvbmAnKVxuICAgIGFzc2VydCgndmFsdWUnIGluIHRhaWwsICdleHBlY3RlZCBgbm9kZS52YWx1ZWAnKVxuICAgIHRhaWwudmFsdWUgKz0gdmFsdWVcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua3Byb3RvY29sKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF1dG9saW5rZW1haWwodG9rZW4pIHtcbiAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICBub2RlLnVybCA9ICdtYWlsdG86JyArIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvL1xuICAvLyBDcmVhdGVycy5cbiAgLy9cblxuICAvKiogQHJldHVybnMge0Jsb2NrcXVvdGV9ICovXG4gIGZ1bmN0aW9uIGJsb2NrUXVvdGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnYmxvY2txdW90ZScsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7Q29kZX0gKi9cbiAgZnVuY3Rpb24gY29kZUZsb3coKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnY29kZScsIGxhbmc6IG51bGwsIG1ldGE6IG51bGwsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW5saW5lQ29kZX0gKi9cbiAgZnVuY3Rpb24gY29kZVRleHQoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaW5saW5lQ29kZScsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7RGVmaW5pdGlvbn0gKi9cbiAgZnVuY3Rpb24gZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RlZmluaXRpb24nLFxuICAgICAgaWRlbnRpZmllcjogJycsXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgdXJsOiAnJ1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7RW1waGFzaXN9ICovXG4gIGZ1bmN0aW9uIGVtcGhhc2lzKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2VtcGhhc2lzJywgY2hpbGRyZW46IFtdfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtIZWFkaW5nfSAqL1xuICBmdW5jdGlvbiBoZWFkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuXG4gICAgICBkZXB0aDogMCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7QnJlYWt9ICovXG4gIGZ1bmN0aW9uIGhhcmRCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdicmVhayd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0h0bWx9ICovXG4gIGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaHRtbCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW1hZ2V9ICovXG4gIGZ1bmN0aW9uIGltYWdlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2ltYWdlJywgdGl0bGU6IG51bGwsIHVybDogJycsIGFsdDogbnVsbH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7TGlua30gKi9cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdsaW5rJywgdGl0bGU6IG51bGwsIHVybDogJycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdH1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3QodG9rZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgb3JkZXJlZDogdG9rZW4udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtMaXN0SXRlbX1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RJdGVtKHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICBzcHJlYWQ6IHRva2VuLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtQYXJhZ3JhcGh9ICovXG4gIGZ1bmN0aW9uIHBhcmFncmFwaCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdwYXJhZ3JhcGgnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1N0cm9uZ30gKi9cbiAgZnVuY3Rpb24gc3Ryb25nKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3N0cm9uZycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGV4dH0gKi9cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtUaGVtYXRpY0JyZWFrfSAqL1xuICBmdW5jdGlvbiB0aGVtYXRpY0JyZWFrKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3RoZW1hdGljQnJlYWsnfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhIHBvaW50LWxpa2UgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gZFxuICogICBQb2ludC1saWtlIHZhbHVlLlxuICogQHJldHVybnMge1BvaW50fVxuICogICB1bmlzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcG9pbnQoZCkge1xuICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29tYmluZWRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RXh0ZW5zaW9uPiB8IEV4dGVuc2lvbj59IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZShjb21iaW5lZCwgZXh0ZW5zaW9ucykge1xuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbnNbaW5kZXhdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbmZpZ3VyZShjb21iaW5lZCwgdmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuc2lvbihjb21iaW5lZCwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25maWd9IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0V4dGVuc2lvbn0gZXh0ZW5zaW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBleHRlbnNpb24oY29tYmluZWQsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge2tleW9mIEV4dGVuc2lvbn0gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIGV4dGVuc2lvbikge1xuICAgIGlmIChvd24uY2FsbChleHRlbnNpb24sIGtleSkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2NhbkNvbnRhaW5Fb2xzJzoge1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2tleV1cbiAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3Jtcyc6IHtcbiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgY2FzZSAnZXhpdCc6IHtcbiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbWJpbmVkW2tleV0sIHJpZ2h0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHR5cGUge09uRW50ZXJFcnJvcn0gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgIGxlZnQudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiBsZWZ0LnN0YXJ0LCBlbmQ6IGxlZnQuZW5kfSkgK1xuICAgICAgICAnKTogYSBkaWZmZXJlbnQgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIG9wZW4nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIHN0aWxsIG9wZW4nXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsib2siLCJhc3NlcnQiLCJ0b1N0cmluZyIsInBhcnNlIiwicG9zdHByb2Nlc3MiLCJwcmVwcm9jZXNzIiwiZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSIsImRlY29kZVN0cmluZyIsIm5vcm1hbGl6ZUlkZW50aWZpZXIiLCJjb2RlcyIsImNvbnN0YW50cyIsInR5cGVzIiwiZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UiLCJzdHJpbmdpZnlQb3NpdGlvbiIsIm93biIsImhhc093blByb3BlcnR5IiwiZnJvbU1hcmtkb3duIiwidmFsdWUiLCJlbmNvZGluZyIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJjb21waWxlciIsImRvY3VtZW50Iiwid3JpdGUiLCJjb25maWciLCJ0cmFuc2Zvcm1zIiwiY2FuQ29udGFpbkVvbHMiLCJlbnRlciIsImF1dG9saW5rIiwib3BlbmVyIiwibGluayIsImF1dG9saW5rUHJvdG9jb2wiLCJvbmVudGVyZGF0YSIsImF1dG9saW5rRW1haWwiLCJhdHhIZWFkaW5nIiwiaGVhZGluZyIsImJsb2NrUXVvdGUiLCJjaGFyYWN0ZXJFc2NhcGUiLCJjaGFyYWN0ZXJSZWZlcmVuY2UiLCJjb2RlRmVuY2VkIiwiY29kZUZsb3ciLCJjb2RlRmVuY2VkRmVuY2VJbmZvIiwiYnVmZmVyIiwiY29kZUZlbmNlZEZlbmNlTWV0YSIsImNvZGVJbmRlbnRlZCIsImNvZGVUZXh0IiwiY29kZVRleHREYXRhIiwiZGF0YSIsImNvZGVGbG93VmFsdWUiLCJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nIiwiZGVmaW5pdGlvbkxhYmVsU3RyaW5nIiwiZGVmaW5pdGlvblRpdGxlU3RyaW5nIiwiZW1waGFzaXMiLCJoYXJkQnJlYWtFc2NhcGUiLCJoYXJkQnJlYWsiLCJoYXJkQnJlYWtUcmFpbGluZyIsImh0bWxGbG93IiwiaHRtbCIsImh0bWxGbG93RGF0YSIsImh0bWxUZXh0IiwiaHRtbFRleHREYXRhIiwiaW1hZ2UiLCJsYWJlbCIsImxpc3RJdGVtIiwibGlzdEl0ZW1WYWx1ZSIsIm9uZW50ZXJsaXN0aXRlbXZhbHVlIiwibGlzdE9yZGVyZWQiLCJsaXN0Iiwib25lbnRlcmxpc3RvcmRlcmVkIiwibGlzdFVub3JkZXJlZCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIm9uZW50ZXJyZWZlcmVuY2UiLCJyZWZlcmVuY2VTdHJpbmciLCJyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nIiwicmVzb3VyY2VUaXRsZVN0cmluZyIsInNldGV4dEhlYWRpbmciLCJzdHJvbmciLCJ0aGVtYXRpY0JyZWFrIiwiZXhpdCIsImNsb3NlciIsImF0eEhlYWRpbmdTZXF1ZW5jZSIsIm9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSIsIm9uZXhpdGF1dG9saW5rZW1haWwiLCJvbmV4aXRhdXRvbGlua3Byb3RvY29sIiwiY2hhcmFjdGVyRXNjYXBlVmFsdWUiLCJvbmV4aXRkYXRhIiwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljIiwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSIsIm9uZXhpdGNvZGVmZW5jZWQiLCJjb2RlRmVuY2VkRmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvIiwib25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSIsIm9uZXhpdGNvZGVpbmRlbnRlZCIsIm9uZXhpdGNvZGV0ZXh0Iiwib25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nIiwib25leGl0aGFyZGJyZWFrIiwib25leGl0aHRtbGZsb3ciLCJvbmV4aXRodG1sdGV4dCIsIm9uZXhpdGltYWdlIiwib25leGl0bGFiZWwiLCJsYWJlbFRleHQiLCJvbmV4aXRsYWJlbHRleHQiLCJsaW5lRW5kaW5nIiwib25leGl0bGluZWVuZGluZyIsIm9uZXhpdGxpbmsiLCJvbmV4aXRyZWZlcmVuY2VzdHJpbmciLCJvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0cmVzb3VyY2V0aXRsZXN0cmluZyIsInJlc291cmNlIiwib25leGl0cmVzb3VyY2UiLCJvbmV4aXRzZXRleHRoZWFkaW5nIiwic2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZSIsIm9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UiLCJzZXRleHRIZWFkaW5nVGV4dCIsIm9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0IiwiY29uZmlndXJlIiwibWRhc3RFeHRlbnNpb25zIiwiY29tcGlsZSIsImV2ZW50cyIsInRyZWUiLCJ0eXBlIiwiY2hpbGRyZW4iLCJjb250ZXh0Iiwic3RhY2siLCJ0b2tlblN0YWNrIiwicmVzdW1lIiwibGlzdFN0YWNrIiwiaW5kZXgiLCJsZW5ndGgiLCJwdXNoIiwidGFpbCIsInBvcCIsInByZXBhcmVMaXN0IiwiaGFuZGxlciIsImNhbGwiLCJPYmplY3QiLCJhc3NpZ24iLCJzbGljZVNlcmlhbGl6ZSIsImRlZmF1bHRPbkVycm9yIiwicG9zaXRpb24iLCJzdGFydCIsInBvaW50IiwibGluZSIsImNvbHVtbiIsIm9mZnNldCIsImVuZCIsImNvbnRhaW5lckJhbGFuY2UiLCJsaXN0U3ByZWFkIiwibGluZUluZGV4IiwiZmlyc3RCbGFua0xpbmVJbmRleCIsImF0TWFya2VyIiwiZXZlbnQiLCJsaW5lRW5kaW5nQmxhbmsiLCJsaW5lUHJlZml4IiwibGlzdEl0ZW1NYXJrZXIiLCJsaXN0SXRlbVByZWZpeCIsImxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZSIsInRhaWxJbmRleCIsInRhaWxFdmVudCIsImJsb2NrUXVvdGVQcmVmaXgiLCJibG9ja1F1b3RlUHJlZml4V2hpdGVzcGFjZSIsImJsb2NrUXVvdGVNYXJrZXIiLCJsaXN0SXRlbUluZGVudCIsIl9zcHJlYWQiLCJzcGxpY2UiLCJpdGVtIiwiY3JlYXRlIiwiYW5kIiwib3BlbiIsInRva2VuIiwibm9kZSIsImVycm9ySGFuZGxlciIsInBhcmVudCIsInNpYmxpbmdzIiwiY2xvc2UiLCJvbkV4aXRFcnJvciIsIkVycm9yIiwiZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlIiwiYW5jZXN0b3IiLCJOdW1iZXIiLCJwYXJzZUludCIsIm51bWVyaWNCYXNlRGVjaW1hbCIsImxhbmciLCJtZXRhIiwiZmxvd0NvZGVJbnNpZGUiLCJyZXBsYWNlIiwiaWRlbnRpZmllciIsInRvTG93ZXJDYXNlIiwidGl0bGUiLCJ1cmwiLCJkZXB0aCIsInNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmciLCJjb2RlUG9pbnRBdCIsImVxdWFsc1RvIiwidGV4dCIsImF0SGFyZEJyZWFrIiwiaW5jbHVkZXMiLCJpblJlZmVyZW5jZSIsInJlZmVyZW5jZVR5cGUiLCJzdHJpbmciLCJmcmFnbWVudCIsImFsdCIsImNoYXJhY3RlclJlZmVyZW5jZVR5cGUiLCJudW1lcmljQmFzZUhleGFkZWNpbWFsIiwicmVzdWx0Iiwib3JkZXJlZCIsInNwcmVhZCIsImNoZWNrZWQiLCJkIiwiY29tYmluZWQiLCJleHRlbnNpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiZXh0ZW5zaW9uIiwia2V5IiwicmlnaHQiLCJsZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(rsc)/./node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark */ \"(rsc)/./node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark */ \"(rsc)/./node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark */ \"(rsc)/./node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(rsc)/./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(rsc)/./node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(rsc)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(rsc)/./node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(rsc)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ \n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */ function fromMarkdown(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark__WEBPACK_IMPORTED_MODULE_0__.postprocess)((0,micromark__WEBPACK_IMPORTED_MODULE_1__.parse)(options).document().write((0,micromark__WEBPACK_IMPORTED_MODULE_2__.preprocess)()(value, encoding, true))));\n}\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            data\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered || events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            switch(event[1].type){\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuote:\n                    {\n                        if (event[0] === \"enter\") {\n                            containerBalance++;\n                        } else {\n                            containerBalance--;\n                        }\n                        atMarker = undefined;\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank:\n                    {\n                        if (event[0] === \"enter\") {\n                            if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                                firstBlankLineIndex = index;\n                            }\n                            atMarker = undefined;\n                        }\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemValue:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemMarker:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefixWhitespace:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        atMarker = undefined;\n                    }\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered || event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix) {\n                    /** @type {Token} */ const item = {\n                        type: \"listItem\",\n                        _spread: false,\n                        start: Object.assign({}, event[1].start),\n                        // @ts-expect-error: weâ€™ll add `end` in a second.\n                        end: undefined\n                    };\n                    listItem = item;\n                    events.splice(index, 0, [\n                        \"enter\",\n                        item,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(parent, \"expected `parent`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in parent, \"expected `parent`\");\n        /** @type {Array<Nodes>} */ const siblings = parent.children;\n        siblings.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        node.position = {\n            start: point(token.start),\n            // @ts-expect-error: `end` will be patched later.\n            end: undefined\n        };\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): itâ€™s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        this.data.expectingFirstListItemValue = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (this.data.expectingFirstListItemValue) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected nodes on stack\");\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            this.data.expectingFirstListItemValue = undefined;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (this.data.flowCodeInside) return;\n        this.buffer();\n        this.data.flowCodeInside = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        this.data.flowCodeInside = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        this.data.setextHeadingSlurpLineEnding = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).codePointAt(0) === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        this.data.setextHeadingSlurpLineEnding = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in node, \"expected parent on stack\");\n        /** @type {Array<Nodes>} */ const siblings = node.children;\n        let tail = siblings[siblings.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            tail.position = {\n                start: point(token.start),\n                // @ts-expect-error: weâ€™ll add `end` later.\n                end: undefined\n            };\n            siblings.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(context, \"expected `node`\");\n        // If weâ€™re at a hard break, include the line ending in there.\n        if (this.data.atHardBreak) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            this.data.atHardBreak = undefined;\n            return;\n        }\n        if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        this.data.atHardBreak = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        this.data.inReference = true;\n        if (node.type === \"link\") {\n            /** @type {Array<PhrasingContent>} */ const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        this.data.inReference = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        this.data.referenceType = \"collapsed\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        this.data.referenceType = \"full\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        this.data.characterReferenceType = token.type;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = this.data.characterReferenceType;\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.characterReferenceMarkerNumeric ? micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            this.data.characterReferenceType = undefined;\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected `node`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node.position`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        return {\n            type: \"heading\",\n            // @ts-expect-error `depth` will be set later.\n            depth: 0,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {Html} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            switch(key){\n                case \"canContainEols\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"transforms\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"enter\":\n                case \"exit\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            Object.assign(combined[key], right);\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNDLEdBRUQ7O0NBRUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBRWtDO0FBQ1U7QUFDVztBQUN5QztBQUN4QztBQUNjO0FBQ1Y7QUFDaUI7QUFDZjtBQUUvRCxNQUFNYyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNDLGFBQWFDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxPQUFPO0lBQ25ELElBQUksT0FBT0QsYUFBYSxVQUFVO1FBQ2hDQyxVQUFVRDtRQUNWQSxXQUFXRTtJQUNiO0lBRUEsT0FBT0MsU0FBU0YsU0FDZGYsc0RBQVdBLENBQ1RELGdEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNsQixxREFBVUEsR0FBR1ksT0FBT0MsVUFBVTtBQUdwRTtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTRyxTQUFTRixPQUFPO0lBQ3ZCLG1CQUFtQixHQUNuQixNQUFNSyxTQUFTO1FBQ2JDLFlBQVksRUFBRTtRQUNkQyxnQkFBZ0I7WUFBQztZQUFZO1lBQVk7WUFBVztZQUFhO1NBQVM7UUFDMUVDLE9BQU87WUFDTEMsVUFBVUMsT0FBT0M7WUFDakJDLGtCQUFrQkM7WUFDbEJDLGVBQWVEO1lBQ2ZFLFlBQVlMLE9BQU9NO1lBQ25CQyxZQUFZUCxPQUFPTztZQUNuQkMsaUJBQWlCTDtZQUNqQk0sb0JBQW9CTjtZQUNwQk8sWUFBWVYsT0FBT1c7WUFDbkJDLHFCQUFxQkM7WUFDckJDLHFCQUFx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UixzQ0FDRXVDLE1BQU0vRixJQUFJLEdBQ1YsUUFDQW5ILGdGQUFpQkEsQ0FBQztZQUFDdUksT0FBTzJFLE1BQU0zRSxLQUFLO1lBQUVLLEtBQUtzRSxNQUFNdEUsR0FBRztRQUFBLEtBQ3JEO0lBRU47QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb20tbWFya2Rvd24vZGV2L2xpYi9pbmRleC5qcz9iZWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5CcmVha30gQnJlYWtcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQmxvY2txdW90ZX0gQmxvY2txdW90ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Db2RlfSBDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkRlZmluaXRpb259IERlZmluaXRpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuRW1waGFzaXN9IEVtcGhhc2lzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkhlYWRpbmd9IEhlYWRpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSHRtbH0gSHRtbFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZX0gSW1hZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW5saW5lQ29kZX0gSW5saW5lQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaW5rfSBMaW5rXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3R9IExpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlzdEl0ZW19IExpc3RJdGVtXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLk5vZGVzfSBOb2Rlc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJhZ3JhcGh9IFBhcmFncmFwaFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJlbnR9IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5SZWZlcmVuY2VUeXBlfSBSZWZlcmVuY2VUeXBlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuU3Ryb25nfSBTdHJvbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGV4dH0gVGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UaGVtYXRpY0JyZWFrfSBUaGVtYXRpY0JyZWFrXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FbmNvZGluZ30gRW5jb2RpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlBhcnNlT3B0aW9uc30gUGFyc2VPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlRva2VufSBUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbml6ZUNvbnRleHR9IFRva2VuaXplQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5WYWx1ZX0gVmFsdWVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvaW50fSBQb2ludFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuQ29tcGlsZURhdGF9IENvbXBpbGVEYXRhXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T21pdDxQYXJlbnQsICdjaGlsZHJlbicgfCAndHlwZSc+ICYge3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBBcnJheTxQaHJhc2luZ0NvbnRlbnQ+fX0gRnJhZ21lbnRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1cbiAqICAgRXh0cmEgdHJhbnNmb3JtLCB0byBjaGFuZ2UgdGhlIEFTVCBhZnRlcndhcmRzLlxuICogQHBhcmFtIHtSb290fSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge1Jvb3QgfCBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZH1cbiAqICAgTmV3IHRyZWUgb3Igbm90aGluZyAoaW4gd2hpY2ggY2FzZSB0aGUgY3VycmVudCB0cmVlIGlzIHVzZWQpLlxuICpcbiAqIEBjYWxsYmFjayBIYW5kbGVcbiAqICAgSGFuZGxlIGEgdG9rZW4uXG4gKiBAcGFyYW0ge0NvbXBpbGVDb250ZXh0fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICogICBDdXJyZW50IHRva2VuLlxuICogQHJldHVybnMge3VuZGVmaW5lZCB8IHZvaWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIEhhbmRsZT59IEhhbmRsZXNcbiAqICAgVG9rZW4gdHlwZXMgbWFwcGluZyB0byBoYW5kbGVzXG4gKlxuICogQGNhbGxiYWNrIE9uRW50ZXJFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiwgYnV0IGl0IGlzIGNsb3NlZCAoYnkgdGhlXG4gKiAgIGBsZWZ0YCB0b2tlbikgb3IgYmVjYXVzZSB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtPbWl0PENvbXBpbGVDb250ZXh0LCAnc2xpY2VTZXJpYWxpemUnPn0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gbGVmdFxuICogICBMZWZ0IHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gcmlnaHRcbiAqICAgUmlnaHQgdG9rZW4uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEBjYWxsYmFjayBPbkV4aXRFcnJvclxuICogICBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGByaWdodGAgdG9rZW4gaXMgb3BlbiBidXQgaXQgaXMgY2xvc2VkIGJ5XG4gKiAgIGV4aXRpbmcgdGhlIGBsZWZ0YCB0b2tlbi5cbiAqIEBwYXJhbSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW59IGxlZnRcbiAqICAgTGVmdCB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHJpZ2h0XG4gKiAgIFJpZ2h0IHRva2VuLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAdHlwZWRlZiB7W1Rva2VuLCBPbkVudGVyRXJyb3IgfCB1bmRlZmluZWRdfSBUb2tlblR1cGxlXG4gKiAgIE9wZW4gdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRoIGFuIG9wdGlvbmFsIGVycm9yIGhhbmRsZXIgZm9yIHdoZW5cbiAqICAgdGhhdCB0b2tlbiBpc27igJl0IGNsb3NlZCBwcm9wZXJseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIENvbmZpZ1xuICogICBDb25maWd1cmF0aW9uLlxuICpcbiAqICAgV2UgaGF2ZSBvdXIgZGVmYXVsdHMsIGJ1dCBleHRlbnNpb25zIHdpbGwgYWRkIG1vcmUuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGNhbkNvbnRhaW5Fb2xzXG4gKiAgIFRva2VuIHR5cGVzIHdoZXJlIGxpbmUgZW5kaW5ncyBhcmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlc30gZW50ZXJcbiAqICAgT3BlbmluZyBoYW5kbGVzLlxuICogQHByb3BlcnR5IHtIYW5kbGVzfSBleGl0XG4gKiAgIENsb3NpbmcgaGFuZGxlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8VHJhbnNmb3JtPn0gdHJhbnNmb3Jtc1xuICogICBUcmVlIHRyYW5zZm9ybXMuXG4gKlxuICogQHR5cGVkZWYge1BhcnRpYWw8Q29uZmlnPn0gRXh0ZW5zaW9uXG4gKiAgIENoYW5nZSBob3cgbWFya2Rvd24gdG9rZW5zIGZyb20gbWljcm9tYXJrIGFyZSB0dXJuZWQgaW50byBtZGFzdC5cbiAqXG4gKiBAdHlwZWRlZiBDb21waWxlQ29udGV4dFxuICogICBtZGFzdCBjb21waWxlciBjb250ZXh0LlxuICogQHByb3BlcnR5IHtBcnJheTxGcmFnbWVudCB8IE5vZGVzPn0gc3RhY2tcbiAqICAgU3RhY2sgb2Ygbm9kZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PFRva2VuVHVwbGU+fSB0b2tlblN0YWNrXG4gKiAgIFN0YWNrIG9mIHRva2Vucy5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiB1bmRlZmluZWR9IGJ1ZmZlclxuICogICBDYXB0dXJlIHNvbWUgb2YgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQpID0+IHN0cmluZ30gcmVzdW1lXG4gKiAgIFN0b3AgY2FwdHVyaW5nIGFuZCBhY2Nlc3MgdGhlIG91dHB1dCBkYXRhLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIG5vZGU6IE5vZGVzLCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkVudGVyRXJyb3IpID0+IHVuZGVmaW5lZH0gZW50ZXJcbiAqICAgRW50ZXIgYSBub2RlLlxuICogQHByb3BlcnR5IHsodGhpczogQ29tcGlsZUNvbnRleHQsIHRva2VuOiBUb2tlbiwgb25FcnJvcj86IE9uRXhpdEVycm9yKSA9PiB1bmRlZmluZWR9IGV4aXRcbiAqICAgRXhpdCBhIG5vZGUuXG4gKiBAcHJvcGVydHkge1Rva2VuaXplQ29udGV4dFsnc2xpY2VTZXJpYWxpemUnXX0gc2xpY2VTZXJpYWxpemVcbiAqICAgR2V0IHRoZSBzdHJpbmcgdmFsdWUgb2YgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Q29uZmlnfSBjb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Q29tcGlsZURhdGF9IGRhdGFcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kOyBrZXkvdmFsdWUgc3RvcmUuXG4gKlxuICogQHR5cGVkZWYgRnJvbU1hcmtkb3duT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciBob3cgdG8gYnVpbGQgbWRhc3QuXG4gKiBAcHJvcGVydHkge0FycmF5PEV4dGVuc2lvbiB8IEFycmF5PEV4dGVuc2lvbj4+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW21kYXN0RXh0ZW5zaW9uc11cbiAqICAgRXh0ZW5zaW9ucyBmb3IgdGhpcyB1dGlsaXR5IHRvIGNoYW5nZSBob3cgdG9rZW5zIGFyZSB0dXJuZWQgaW50byBhIHRyZWUuXG4gKlxuICogQHR5cGVkZWYge1BhcnNlT3B0aW9ucyAmIEZyb21NYXJrZG93bk9wdGlvbnN9IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbWRhc3QtdXRpbC10by1zdHJpbmcnXG5pbXBvcnQge3BhcnNlLCBwb3N0cHJvY2VzcywgcHJlcHJvY2Vzc30gZnJvbSAnbWljcm9tYXJrJ1xuaW1wb3J0IHtkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtbnVtZXJpYy1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtkZWNvZGVTdHJpbmd9IGZyb20gJ21pY3JvbWFyay11dGlsLWRlY29kZS1zdHJpbmcnXG5pbXBvcnQge25vcm1hbGl6ZUlkZW50aWZpZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLW5vcm1hbGl6ZS1pZGVudGlmaWVyJ1xuaW1wb3J0IHtjb2RlcywgY29uc3RhbnRzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuaW1wb3J0IHtkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnZGVjb2RlLW5hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2UnXG5pbXBvcnQge3N0cmluZ2lmeVBvc2l0aW9ufSBmcm9tICd1bmlzdC11dGlsLXN0cmluZ2lmeS1wb3NpdGlvbidcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBUdXJuIG1hcmtkb3duIGludG8gYSBzeW50YXggdHJlZS5cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge0VuY29kaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nXVxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Um9vdH1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtSb290fVxuICpcbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gKiAgIE1hcmtkb3duIHRvIHBhcnNlLlxuICogQHBhcmFtIHtFbmNvZGluZyB8IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5jb2RpbmddXG4gKiAgIENoYXJhY3RlciBlbmNvZGluZyBmb3Igd2hlbiBgdmFsdWVgIGlzIGBCdWZmZXJgLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyB7Um9vdH1cbiAqICAgbWRhc3QgdHJlZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXJrZG93bih2YWx1ZSwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVyKG9wdGlvbnMpKFxuICAgIHBvc3Rwcm9jZXNzKFxuICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSlcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBOb3RlIHRoaXMgY29tcGlsZXIgb25seSB1bmRlcnN0YW5kIGNvbXBsZXRlIGJ1ZmZlcmluZywgbm90IHN0cmVhbWluZy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gY29tcGlsZXIob3B0aW9ucykge1xuICAvKiogQHR5cGUge0NvbmZpZ30gKi9cbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgIGNhbkNvbnRhaW5Fb2xzOiBbJ2VtcGhhc2lzJywgJ2ZyYWdtZW50JywgJ2hlYWRpbmcnLCAncGFyYWdyYXBoJywgJ3N0cm9uZyddLFxuICAgIGVudGVyOiB7XG4gICAgICBhdXRvbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogb25lbnRlcmRhdGEsXG4gICAgICBhdXRvbGlua0VtYWlsOiBvbmVudGVyZGF0YSxcbiAgICAgIGF0eEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgIGJsb2NrUXVvdGU6IG9wZW5lcihibG9ja1F1b3RlKSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZTogb25lbnRlcmRhdGEsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2U6IG9uZW50ZXJkYXRhLFxuICAgICAgY29kZUZlbmNlZDogb3BlbmVyKGNvZGVGbG93KSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IGJ1ZmZlcixcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IGJ1ZmZlcixcbiAgICAgIGNvZGVJbmRlbnRlZDogb3BlbmVyKGNvZGVGbG93LCBidWZmZXIpLFxuICAgICAgY29kZVRleHQ6IG9wZW5lcihjb2RlVGV4dCwgYnVmZmVyKSxcbiAgICAgIGNvZGVUZXh0RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBkYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGNvZGVGbG93VmFsdWU6IG9uZW50ZXJkYXRhLFxuICAgICAgZGVmaW5pdGlvbjogb3BlbmVyKGRlZmluaXRpb24pLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgZW1waGFzaXM6IG9wZW5lcihlbXBoYXNpcyksXG4gICAgICBoYXJkQnJlYWtFc2NhcGU6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IG9wZW5lcihoYXJkQnJlYWspLFxuICAgICAgaHRtbEZsb3c6IG9wZW5lcihodG1sLCBidWZmZXIpLFxuICAgICAgaHRtbEZsb3dEYXRhOiBvbmVudGVyZGF0YSxcbiAgICAgIGh0bWxUZXh0OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgIGh0bWxUZXh0RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBpbWFnZTogb3BlbmVyKGltYWdlKSxcbiAgICAgIGxhYmVsOiBidWZmZXIsXG4gICAgICBsaW5rOiBvcGVuZXIobGluayksXG4gICAgICBsaXN0SXRlbTogb3BlbmVyKGxpc3RJdGVtKSxcbiAgICAgIGxpc3RJdGVtVmFsdWU6IG9uZW50ZXJsaXN0aXRlbXZhbHVlLFxuICAgICAgbGlzdE9yZGVyZWQ6IG9wZW5lcihsaXN0LCBvbmVudGVybGlzdG9yZGVyZWQpLFxuICAgICAgbGlzdFVub3JkZXJlZDogb3BlbmVyKGxpc3QpLFxuICAgICAgcGFyYWdyYXBoOiBvcGVuZXIocGFyYWdyYXBoKSxcbiAgICAgIHJlZmVyZW5jZTogb25lbnRlcnJlZmVyZW5jZSxcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogYnVmZmVyLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgcmVzb3VyY2VUaXRsZVN0cmluZzogYnVmZmVyLFxuICAgICAgc2V0ZXh0SGVhZGluZzogb3BlbmVyKGhlYWRpbmcpLFxuICAgICAgc3Ryb25nOiBvcGVuZXIoc3Ryb25nKSxcbiAgICAgIHRoZW1hdGljQnJlYWs6IG9wZW5lcih0aGVtYXRpY0JyZWFrKVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgYXR4SGVhZGluZzogY2xvc2VyKCksXG4gICAgICBhdHhIZWFkaW5nU2VxdWVuY2U6IG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSxcbiAgICAgIGF1dG9saW5rOiBjbG9zZXIoKSxcbiAgICAgIGF1dG9saW5rRW1haWw6IG9uZXhpdGF1dG9saW5rZW1haWwsXG4gICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmV4aXRhdXRvbGlua3Byb3RvY29sLFxuICAgICAgYmxvY2tRdW90ZTogY2xvc2VyKCksXG4gICAgICBjaGFyYWN0ZXJFc2NhcGVWYWx1ZTogb25leGl0ZGF0YSxcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZTogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUsXG4gICAgICBjb2RlRmVuY2VkOiBjbG9zZXIob25leGl0Y29kZWZlbmNlZCksXG4gICAgICBjb2RlRmVuY2VkRmVuY2U6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IG9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8sXG4gICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhLFxuICAgICAgY29kZUZsb3dWYWx1ZTogb25leGl0ZGF0YSxcbiAgICAgIGNvZGVJbmRlbnRlZDogY2xvc2VyKG9uZXhpdGNvZGVpbmRlbnRlZCksXG4gICAgICBjb2RlVGV4dDogY2xvc2VyKG9uZXhpdGNvZGV0ZXh0KSxcbiAgICAgIGNvZGVUZXh0RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGRhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBkZWZpbml0aW9uOiBjbG9zZXIoKSxcbiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyxcbiAgICAgIGVtcGhhc2lzOiBjbG9zZXIoKSxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogY2xvc2VyKG9uZXhpdGhhcmRicmVhayksXG4gICAgICBoYXJkQnJlYWtUcmFpbGluZzogY2xvc2VyKG9uZXhpdGhhcmRicmVhayksXG4gICAgICBodG1sRmxvdzogY2xvc2VyKG9uZXhpdGh0bWxmbG93KSxcbiAgICAgIGh0bWxGbG93RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGh0bWxUZXh0OiBjbG9zZXIob25leGl0aHRtbHRleHQpLFxuICAgICAgaHRtbFRleHREYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgaW1hZ2U6IGNsb3NlcihvbmV4aXRpbWFnZSksXG4gICAgICBsYWJlbDogb25leGl0bGFiZWwsXG4gICAgICBsYWJlbFRleHQ6IG9uZXhpdGxhYmVsdGV4dCxcbiAgICAgIGxpbmVFbmRpbmc6IG9uZXhpdGxpbmVlbmRpbmcsXG4gICAgICBsaW5rOiBjbG9zZXIob25leGl0bGluayksXG4gICAgICBsaXN0SXRlbTogY2xvc2VyKCksXG4gICAgICBsaXN0T3JkZXJlZDogY2xvc2VyKCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiBjbG9zZXIoKSxcbiAgICAgIHBhcmFncmFwaDogY2xvc2VyKCksXG4gICAgICByZWZlcmVuY2VTdHJpbmc6IG9uZXhpdHJlZmVyZW5jZXN0cmluZyxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IG9uZXhpdHJlc291cmNlZGVzdGluYXRpb25zdHJpbmcsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nLFxuICAgICAgcmVzb3VyY2U6IG9uZXhpdHJlc291cmNlLFxuICAgICAgc2V0ZXh0SGVhZGluZzogY2xvc2VyKG9uZXhpdHNldGV4dGhlYWRpbmcpLFxuICAgICAgc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZTogb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSxcbiAgICAgIHNldGV4dEhlYWRpbmdUZXh0OiBvbmV4aXRzZXRleHRoZWFkaW5ndGV4dCxcbiAgICAgIHN0cm9uZzogY2xvc2VyKCksXG4gICAgICB0aGVtYXRpY0JyZWFrOiBjbG9zZXIoKVxuICAgIH1cbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcsIChvcHRpb25zIHx8IHt9KS5tZGFzdEV4dGVuc2lvbnMgfHwgW10pXG5cbiAgLyoqIEB0eXBlIHtDb21waWxlRGF0YX0gKi9cbiAgY29uc3QgZGF0YSA9IHt9XG5cbiAgcmV0dXJuIGNvbXBpbGVcblxuICAvKipcbiAgICogVHVybiBtaWNyb21hcmsgZXZlbnRzIGludG8gYW4gbWRhc3QgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiAgIEV2ZW50cy5cbiAgICogQHJldHVybnMge1Jvb3R9XG4gICAqICAgbWRhc3QgdHJlZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGUoZXZlbnRzKSB7XG4gICAgLyoqIEB0eXBlIHtSb290fSAqL1xuICAgIGxldCB0cmVlID0ge3R5cGU6ICdyb290JywgY2hpbGRyZW46IFtdfVxuICAgIC8qKiBAdHlwZSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59ICovXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHN0YWNrOiBbdHJlZV0sXG4gICAgICB0b2tlblN0YWNrOiBbXSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGVudGVyLFxuICAgICAgZXhpdCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHJlc3VtZSxcbiAgICAgIGRhdGFcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGxpc3RTdGFjayA9IFtdXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgLy8gV2UgcHJlcHJvY2VzcyBsaXN0cyB0byBhZGQgYGxpc3RJdGVtYCB0b2tlbnMsIGFuZCB0byBpbmZlciB3aGV0aGVyXG4gICAgICAvLyBpdGVtcyB0aGUgbGlzdCBpdHNlbGYgYXJlIHNwcmVhZCBvdXQuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQgfHxcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICBsaXN0U3RhY2sucHVzaChpbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YWlsID0gbGlzdFN0YWNrLnBvcCgpXG4gICAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWlsID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGxpc3Qgb3QgYmUgb3BlbicpXG4gICAgICAgICAgaW5kZXggPSBwcmVwYXJlTGlzdChldmVudHMsIHRhaWwsIGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gY29uZmlnW2V2ZW50c1tpbmRleF1bMF1dXG5cbiAgICAgIGlmIChvd24uY2FsbChoYW5kbGVyLCBldmVudHNbaW5kZXhdWzFdLnR5cGUpKSB7XG4gICAgICAgIGhhbmRsZXJbZXZlbnRzW2luZGV4XVsxXS50eXBlXS5jYWxsKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7c2xpY2VTZXJpYWxpemU6IGV2ZW50c1tpbmRleF1bMl0uc2xpY2VTZXJpYWxpemV9LFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICksXG4gICAgICAgICAgZXZlbnRzW2luZGV4XVsxXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRva2VucyBzdGlsbCBiZWluZyBvcGVuLlxuICAgIGlmIChjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQudG9rZW5TdGFja1tjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdW5kZWZpbmVkLCB0YWlsWzBdKVxuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgYHJvb3RgIHBvc2l0aW9uLlxuICAgIHRyZWUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwID8gZXZlbnRzWzBdWzFdLnN0YXJ0IDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKSxcbiAgICAgIGVuZDogcG9pbnQoXG4gICAgICAgIGV2ZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZFxuICAgICAgICAgIDoge2xpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENhbGwgdHJhbnNmb3Jtcy5cbiAgICBpbmRleCA9IC0xXG4gICAgd2hpbGUgKCsraW5kZXggPCBjb25maWcudHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgIHRyZWUgPSBjb25maWcudHJhbnNmb3Jtc1tpbmRleF0odHJlZSkgfHwgdHJlZVxuICAgIH1cblxuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3QoZXZlbnRzLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQgLSAxXG4gICAgbGV0IGNvbnRhaW5lckJhbGFuY2UgPSAtMVxuICAgIGxldCBsaXN0U3ByZWFkID0gZmFsc2VcbiAgICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaXN0SXRlbVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZmlyc3RCbGFua0xpbmVJbmRleFxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgYXRNYXJrZXJcblxuICAgIHdoaWxlICgrK2luZGV4IDw9IGxlbmd0aCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICAgIHN3aXRjaCAoZXZlbnRbMV0udHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLmxpc3RVbm9yZGVyZWQ6XG4gICAgICAgIGNhc2UgdHlwZXMubGlzdE9yZGVyZWQ6XG4gICAgICAgIGNhc2UgdHlwZXMuYmxvY2tRdW90ZToge1xuICAgICAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgY29udGFpbmVyQmFsYW5jZSsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UtLVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSB0eXBlcy5saW5lRW5kaW5nQmxhbms6IHtcbiAgICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGlzdEl0ZW0gJiZcbiAgICAgICAgICAgICAgIWF0TWFya2VyICYmXG4gICAgICAgICAgICAgICFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgICAgICFmaXJzdEJsYW5rTGluZUluZGV4XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0TWFya2VyID0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgdHlwZXMubGluZVByZWZpeDpcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbVZhbHVlOlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtTWFya2VyOlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtUHJlZml4OlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZToge1xuICAgICAgICAgIC8vIEVtcHR5LlxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKCFjb250YWluZXJCYWxhbmNlICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeCkgfHxcbiAgICAgICAgKGNvbnRhaW5lckJhbGFuY2UgPT09IC0xICYmXG4gICAgICAgICAgZXZlbnRbMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkIHx8XG4gICAgICAgICAgICBldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtKSB7XG4gICAgICAgICAgbGV0IHRhaWxJbmRleCA9IGluZGV4XG4gICAgICAgICAgbGluZUluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICB3aGlsZSAodGFpbEluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhaWxFdmVudCA9IGV2ZW50c1t0YWlsSW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsRXZlbnRbMF0gPT09ICdleGl0JykgY29udGludWVcblxuICAgICAgICAgICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2xpbmVJbmRleF1bMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdCbGFua1xuICAgICAgICAgICAgICAgIGxpc3RTcHJlYWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9IHR5cGVzLmxpbmVFbmRpbmdcbiAgICAgICAgICAgICAgbGluZUluZGV4ID0gdGFpbEluZGV4XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeCB8fFxuICAgICAgICAgICAgICB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVNYXJrZXIgfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtSW5kZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCAmJlxuICAgICAgICAgICAgKCFsaW5lSW5kZXggfHwgZmlyc3RCbGFua0xpbmVJbmRleCA8IGxpbmVJbmRleClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLl9zcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRml4IHBvc2l0aW9uLlxuICAgICAgICAgIGxpc3RJdGVtLmVuZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGxpbmVJbmRleCA/IGV2ZW50c1tsaW5lSW5kZXhdWzFdLnN0YXJ0IDogZXZlbnRbMV0uZW5kXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShsaW5lSW5kZXggfHwgaW5kZXgsIDAsIFsnZXhpdCcsIGxpc3RJdGVtLCBldmVudFsyXV0pXG4gICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgIGxlbmd0aCsrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBpdGVtLlxuICAgICAgICBpZiAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgX3NwcmVhZDogZmFsc2UsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRbMV0uc3RhcnQpLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2XigJlsbCBhZGQgYGVuZGAgaW4gYSBzZWNvbmQuXG4gICAgICAgICAgICBlbmQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0SXRlbSA9IGl0ZW1cbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAwLCBbJ2VudGVyJywgaXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSB1bmRlZmluZWRcbiAgICAgICAgICBhdE1hcmtlciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50c1tzdGFydF1bMV0uX3NwcmVhZCA9IGxpc3RTcHJlYWRcbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9wZW5lciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7KHRva2VuOiBUb2tlbikgPT4gTm9kZXN9IGNyZWF0ZVxuICAgKiAgIENyZWF0ZSBhIG5vZGUuXG4gICAqIEBwYXJhbSB7SGFuZGxlIHwgdW5kZWZpbmVkfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9wZW5lcihjcmVhdGUsIGFuZCkge1xuICAgIHJldHVybiBvcGVuXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW4odG9rZW4pIHtcbiAgICAgIGVudGVyLmNhbGwodGhpcywgY3JlYXRlKHRva2VuKSwgdG9rZW4pXG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gYnVmZmVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh7dHlwZTogJ2ZyYWdtZW50JywgY2hpbGRyZW46IFtdfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqICAgQ29udGV4dC5cbiAgICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICAgKiAgIE5vZGUgdG8gZW50ZXIuXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqICAgQ29ycmVzcG9uZGluZyB0b2tlbi5cbiAgICogQHBhcmFtIHtPbkVudGVyRXJyb3IgfCB1bmRlZmluZWR9IFtlcnJvckhhbmRsZXJdXG4gICAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoaXMgdG9rZW4gaXMgb3BlbiwgYnV0IGl0IGlzIGNsb3NlZCBieSBzb21ldGhpbmcgZWxzZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXIobm9kZSwgdG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChwYXJlbnQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gcGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+fSAqL1xuICAgIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG4gICAgc2libGluZ3MucHVzaChub2RlKVxuICAgIHRoaXMuc3RhY2sucHVzaChub2RlKVxuICAgIHRoaXMudG9rZW5TdGFjay5wdXNoKFt0b2tlbiwgZXJyb3JIYW5kbGVyXSlcbiAgICBub2RlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBlbmRgIHdpbGwgYmUgcGF0Y2hlZCBsYXRlci5cbiAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb3NlciBoYW5kbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGFuZGxlIHwgdW5kZWZpbmVkfSBbYW5kXVxuICAgKiAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFsc28gcnVuLlxuICAgKiBAcmV0dXJucyB7SGFuZGxlfVxuICAgKiAgIEhhbmRsZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNsb3NlcihhbmQpIHtcbiAgICByZXR1cm4gY2xvc2VcblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvc2UodG9rZW4pIHtcbiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKVxuICAgICAgZXhpdC5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqICAgQ29udGV4dC5cbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogICBDb3JyZXNwb25kaW5nIHRva2VuLlxuICAgKiBAcGFyYW0ge09uRXhpdEVycm9yIHwgdW5kZWZpbmVkfSBbb25FeGl0RXJyb3JdXG4gICAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFub3RoZXIgdG9rZW4gaXMgb3Blbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdCh0b2tlbiwgb25FeGl0RXJyb3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgYG5vZGVgJylcbiAgICBjb25zdCBvcGVuID0gdGhpcy50b2tlblN0YWNrLnBvcCgpXG5cbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgICAgdG9rZW4udHlwZSArXG4gICAgICAgICAgJ2AgKCcgK1xuICAgICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kfSkgK1xuICAgICAgICAgICcpOiBpdOKAmXMgbm90IG9wZW4nXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChvcGVuWzBdLnR5cGUgIT09IHRva2VuLnR5cGUpIHtcbiAgICAgIGlmIChvbkV4aXRFcnJvcikge1xuICAgICAgICBvbkV4aXRFcnJvci5jYWxsKHRoaXMsIHRva2VuLCBvcGVuWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG9wZW5bMV0gfHwgZGVmYXVsdE9uRXJyb3JcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHRva2VuLCBvcGVuWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydChub2RlLnR5cGUgIT09ICdmcmFnbWVudCcsICd1bmV4cGVjdGVkIGZyYWdtZW50IGBleGl0YGVkJylcbiAgICBhc3NlcnQobm9kZS5wb3NpdGlvbiwgJ2V4cGVjdGVkIGBwb3NpdGlvbmAgdG8gYmUgZGVmaW5lZCcpXG4gICAgbm9kZS5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzLnN0YWNrLnBvcCgpKVxuICB9XG5cbiAgLy9cbiAgLy8gSGFuZGxlcnMuXG4gIC8vXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0b3JkZXJlZCgpIHtcbiAgICB0aGlzLmRhdGEuZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZW50ZXJsaXN0aXRlbXZhbHVlKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5leHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG4gICAgICBhc3NlcnQoYW5jZXN0b3IsICdleHBlY3RlZCBub2RlcyBvbiBzdGFjaycpXG4gICAgICBhc3NlcnQoYW5jZXN0b3IudHlwZSA9PT0gJ2xpc3QnLCAnZXhwZWN0ZWQgbGlzdCBvbiBzdGFjaycpXG4gICAgICBhbmNlc3Rvci5zdGFydCA9IE51bWJlci5wYXJzZUludChcbiAgICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbiksXG4gICAgICAgIGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgIClcbiAgICAgIHRoaXMuZGF0YS5leHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWUgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuICAgIG5vZGUubGFuZyA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VtZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG4gICAgbm9kZS5tZXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZSgpIHtcbiAgICAvLyBFeGl0IGlmIHRoaXMgaXMgdGhlIGNsb3NpbmcgZmVuY2UuXG4gICAgaWYgKHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSkgcmV0dXJuXG4gICAgdGhpcy5idWZmZXIoKVxuICAgIHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgICB0aGlzLmRhdGEuZmxvd0NvZGVJbnNpZGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlaW5kZW50ZWQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29kZScsICdleHBlY3RlZCBjb2RlIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhLnJlcGxhY2UoLyhcXHI/XFxufFxccikkL2csICcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2RlZmluaXRpb24nLCAnZXhwZWN0ZWQgZGVmaW5pdGlvbiBvbiBzdGFjaycpXG5cbiAgICBub2RlLnRpdGxlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXR4aGVhZGluZ3NlcXVlbmNlKHRva2VuKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnLCAnZXhwZWN0ZWQgaGVhZGluZyBvbiBzdGFjaycpXG5cbiAgICBpZiAoIW5vZGUuZGVwdGgpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikubGVuZ3RoXG5cbiAgICAgIGFzc2VydChcbiAgICAgICAgZGVwdGggPT09IDEgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gMiB8fFxuICAgICAgICAgIGRlcHRoID09PSAzIHx8XG4gICAgICAgICAgZGVwdGggPT09IDQgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNSB8fFxuICAgICAgICAgIGRlcHRoID09PSA2LFxuICAgICAgICAnZXhwZWN0ZWQgYGRlcHRoYCBiZXR3ZWVuIGAxYCBhbmQgYDZgJ1xuICAgICAgKVxuXG4gICAgICBub2RlLmRlcHRoID0gZGVwdGhcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ3RleHQoKSB7XG4gICAgdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdoZWFkaW5nJywgJ2V4cGVjdGVkIGhlYWRpbmcgb24gc3RhY2snKVxuXG4gICAgbm9kZS5kZXB0aCA9XG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5jb2RlUG9pbnRBdCgwKSA9PT0gY29kZXMuZXF1YWxzVG8gPyAxIDogMlxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZW50ZXJkYXRhKHRva2VuKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KCdjaGlsZHJlbicgaW4gbm9kZSwgJ2V4cGVjdGVkIHBhcmVudCBvbiBzdGFjaycpXG4gICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz59ICovXG4gICAgY29uc3Qgc2libGluZ3MgPSBub2RlLmNoaWxkcmVuXG5cbiAgICBsZXQgdGFpbCA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAoIXRhaWwgfHwgdGFpbC50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIC8vIEFkZCBhIG5ldyB0ZXh0IG5vZGUuXG4gICAgICB0YWlsID0gdGV4dCgpXG4gICAgICB0YWlsLnBvc2l0aW9uID0ge1xuICAgICAgICBzdGFydDogcG9pbnQodG9rZW4uc3RhcnQpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZeKAmWxsIGFkZCBgZW5kYCBsYXRlci5cbiAgICAgICAgZW5kOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIHNpYmxpbmdzLnB1c2godGFpbClcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2godGFpbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGRhdGEodG9rZW4pIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy5zdGFjay5wb3AoKVxuICAgIGFzc2VydCh0YWlsLCAnZXhwZWN0ZWQgYSBgbm9kZWAgdG8gYmUgb24gdGhlIHN0YWNrJylcbiAgICBhc3NlcnQoJ3ZhbHVlJyBpbiB0YWlsLCAnZXhwZWN0ZWQgYSBgbGl0ZXJhbGAgdG8gYmUgb24gdGhlIHN0YWNrJylcbiAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIGBub2RlYCB0byBoYXZlIGFuIG9wZW4gcG9zaXRpb24nKVxuICAgIHRhaWwudmFsdWUgKz0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmVlbmRpbmcodG9rZW4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KGNvbnRleHQsICdleHBlY3RlZCBgbm9kZWAnKVxuXG4gICAgLy8gSWYgd2XigJlyZSBhdCBhIGhhcmQgYnJlYWssIGluY2x1ZGUgdGhlIGxpbmUgZW5kaW5nIGluIHRoZXJlLlxuICAgIGlmICh0aGlzLmRhdGEuYXRIYXJkQnJlYWspIHtcbiAgICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIGNvbnRleHQsICdleHBlY3RlZCBgcGFyZW50YCcpXG4gICAgICBjb25zdCB0YWlsID0gY29udGV4dC5jaGlsZHJlbltjb250ZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICBhc3NlcnQodGFpbC5wb3NpdGlvbiwgJ2V4cGVjdGVkIHRhaWwgdG8gaGF2ZSBhIHN0YXJ0aW5nIHBvc2l0aW9uJylcbiAgICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICAgICAgdGhpcy5kYXRhLmF0SGFyZEJyZWFrID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgJiZcbiAgICAgIGNvbmZpZy5jYW5Db250YWluRW9scy5pbmNsdWRlcyhjb250ZXh0LnR5cGUpXG4gICAgKSB7XG4gICAgICBvbmVudGVyZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGhhcmRicmVhaygpIHtcbiAgICB0aGlzLmRhdGEuYXRIYXJkQnJlYWsgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdodG1sJywgJ2V4cGVjdGVkIGh0bWwgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGh0bWx0ZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2h0bWwnLCAnZXhwZWN0ZWQgaHRtbCBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y29kZXRleHQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaW5saW5lQ29kZScsICdleHBlY3RlZCBpbmxpbmUgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGluaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIC8vIE5vdGU6IHRoZXJlIGFyZSBhbHNvIGBpZGVudGlmaWVyYCBhbmQgYGxhYmVsYCBmaWVsZHMgb24gdGhpcyBsaW5rIG5vZGUhXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgLyBjbGVhbmVkIGhlcmUuXG5cbiAgICAvLyBUbyBkbzogY2xlYW4uXG4gICAgaWYgKHRoaXMuZGF0YS5pblJlZmVyZW5jZSkge1xuICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2VUeXBlfSAqL1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlIHx8ICdzaG9ydGN1dCdcblxuICAgICAgbm9kZS50eXBlICs9ICdSZWZlcmVuY2UnXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBub2RlLnJlZmVyZW5jZVR5cGUgPSByZWZlcmVuY2VUeXBlXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS51cmxcbiAgICAgIGRlbGV0ZSBub2RlLnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmlkZW50aWZpZXJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLmxhYmVsXG4gICAgfVxuXG4gICAgdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGltYWdlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdpbWFnZScsICdleHBlY3RlZCBpbWFnZSBvbiBzdGFjaycpXG5cbiAgICAvLyBOb3RlOiB0aGVyZSBhcmUgYWxzbyBgaWRlbnRpZmllcmAgYW5kIGBsYWJlbGAgZmllbGRzIG9uIHRoaXMgbGluayBub2RlIVxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIC8gY2xlYW5lZCBoZXJlLlxuXG4gICAgLy8gVG8gZG86IGNsZWFuLlxuICAgIGlmICh0aGlzLmRhdGEuaW5SZWZlcmVuY2UpIHtcbiAgICAgIC8qKiBAdHlwZSB7UmVmZXJlbmNlVHlwZX0gKi9cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbHRleHQodG9rZW4pIHtcbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgIGNvbnN0IGFuY2VzdG9yID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG4gICAgYXNzZXJ0KGFuY2VzdG9yLCAnZXhwZWN0ZWQgYW5jZXN0b3Igb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIGFuY2VzdG9yLnR5cGUgPT09ICdpbWFnZScgfHwgYW5jZXN0b3IudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3Rhc2ggdGhpcyBvbiB0aGUgbm9kZSwgYXMgaXQgbWlnaHQgYmVjb21lIGEgcmVmZXJlbmNlXG4gICAgLy8gbGF0ZXIuXG4gICAgYW5jZXN0b3IubGFiZWwgPSBkZWNvZGVTdHJpbmcoc3RyaW5nKVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNhbWUgYXMgYWJvdmUuXG4gICAgYW5jZXN0b3IuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoc3RyaW5nKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsYWJlbCgpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChmcmFnbWVudCwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChmcmFnbWVudC50eXBlID09PSAnZnJhZ21lbnQnLCAnZXhwZWN0ZWQgZnJhZ21lbnQgb24gc3RhY2snKVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEFzc3VtZSBhIHJlZmVyZW5jZS5cbiAgICB0aGlzLmRhdGEuaW5SZWZlcmVuY2UgPSB0cnVlXG5cbiAgICBpZiAobm9kZS50eXBlID09PSAnbGluaycpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UGhyYXNpbmdDb250ZW50Pn0gKi9cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZnJhZ21lbnQuY2hpbGRyZW5cblxuICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYWx0ID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZS50eXBlID09PSAnaW1hZ2UnIHx8IG5vZGUudHlwZSA9PT0gJ2xpbmsnLFxuICAgICAgJ2V4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2snXG4gICAgKVxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2V0aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcbiAgICBub2RlLnRpdGxlID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2UoKSB7XG4gICAgdGhpcy5kYXRhLmluUmVmZXJlbmNlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVycmVmZXJlbmNlKCkge1xuICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gJ2NvbGxhcHNlZCdcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlZmVyZW5jZXN0cmluZyh0b2tlbikge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSByZWZlcmVuY2Ugb3IgbGluayByZWZlcmVuY2Ugb24gc3RhY2snXG4gICAgKVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3Rhc2ggdGhpcyBvbiB0aGUgbm9kZSwgYXMgaXQgbWlnaHQgYmVjb21lIGEgcmVmZXJlbmNlXG4gICAgLy8gbGF0ZXIuXG4gICAgbm9kZS5sYWJlbCA9IGxhYmVsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZSBhcyBhYm92ZS5cbiAgICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICApLnRvTG93ZXJDYXNlKClcbiAgICB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSA9ICdmdWxsJ1xuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyKHRva2VuKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdG9rZW4udHlwZSA9PT0gJ2NoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWMnIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbCdcbiAgICApXG4gICAgdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGUgPSB0b2tlbi50eXBlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUodG9rZW4pIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCB0eXBlID0gdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGVcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdmFsdWVcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YWx1ZSA9IGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWNcbiAgICAgICAgICA/IGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWxcbiAgICAgICAgICA6IGNvbnN0YW50cy5udW1lcmljQmFzZUhleGFkZWNpbWFsXG4gICAgICApXG4gICAgICB0aGlzLmRhdGEuY2hhcmFjdGVyUmVmZXJlbmNlVHlwZSA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVOYW1lZENoYXJhY3RlclJlZmVyZW5jZShkYXRhKVxuICAgICAgYXNzZXJ0KHJlc3VsdCAhPT0gZmFsc2UsICdleHBlY3RlZCByZWZlcmVuY2UgdG8gZGVjb2RlJylcbiAgICAgIHZhbHVlID0gcmVzdWx0XG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQodGFpbCwgJ2V4cGVjdGVkIGBub2RlYCcpXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCBgbm9kZS5wb3NpdGlvbmAnKVxuICAgIGFzc2VydCgndmFsdWUnIGluIHRhaWwsICdleHBlY3RlZCBgbm9kZS52YWx1ZWAnKVxuICAgIHRhaWwudmFsdWUgKz0gdmFsdWVcbiAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua3Byb3RvY29sKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF1dG9saW5rZW1haWwodG9rZW4pIHtcbiAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICBub2RlLnVybCA9ICdtYWlsdG86JyArIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gIH1cblxuICAvL1xuICAvLyBDcmVhdGVycy5cbiAgLy9cblxuICAvKiogQHJldHVybnMge0Jsb2NrcXVvdGV9ICovXG4gIGZ1bmN0aW9uIGJsb2NrUXVvdGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnYmxvY2txdW90ZScsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7Q29kZX0gKi9cbiAgZnVuY3Rpb24gY29kZUZsb3coKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnY29kZScsIGxhbmc6IG51bGwsIG1ldGE6IG51bGwsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW5saW5lQ29kZX0gKi9cbiAgZnVuY3Rpb24gY29kZVRleHQoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaW5saW5lQ29kZScsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7RGVmaW5pdGlvbn0gKi9cbiAgZnVuY3Rpb24gZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RlZmluaXRpb24nLFxuICAgICAgaWRlbnRpZmllcjogJycsXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgdXJsOiAnJ1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7RW1waGFzaXN9ICovXG4gIGZ1bmN0aW9uIGVtcGhhc2lzKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2VtcGhhc2lzJywgY2hpbGRyZW46IFtdfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtIZWFkaW5nfSAqL1xuICBmdW5jdGlvbiBoZWFkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuXG4gICAgICBkZXB0aDogMCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7QnJlYWt9ICovXG4gIGZ1bmN0aW9uIGhhcmRCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdicmVhayd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0h0bWx9ICovXG4gIGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnaHRtbCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SW1hZ2V9ICovXG4gIGZ1bmN0aW9uIGltYWdlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2ltYWdlJywgdGl0bGU6IG51bGwsIHVybDogJycsIGFsdDogbnVsbH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7TGlua30gKi9cbiAgZnVuY3Rpb24gbGluaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdsaW5rJywgdGl0bGU6IG51bGwsIHVybDogJycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdH1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3QodG9rZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgb3JkZXJlZDogdG9rZW4udHlwZSA9PT0gJ2xpc3RPcmRlcmVkJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtMaXN0SXRlbX1cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RJdGVtKHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0SXRlbScsXG4gICAgICBzcHJlYWQ6IHRva2VuLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtQYXJhZ3JhcGh9ICovXG4gIGZ1bmN0aW9uIHBhcmFncmFwaCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdwYXJhZ3JhcGgnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1N0cm9uZ30gKi9cbiAgZnVuY3Rpb24gc3Ryb25nKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3N0cm9uZycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGV4dH0gKi9cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtUaGVtYXRpY0JyZWFrfSAqL1xuICBmdW5jdGlvbiB0aGVtYXRpY0JyZWFrKCkge1xuICAgIHJldHVybiB7dHlwZTogJ3RoZW1hdGljQnJlYWsnfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhIHBvaW50LWxpa2UgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gZFxuICogICBQb2ludC1saWtlIHZhbHVlLlxuICogQHJldHVybnMge1BvaW50fVxuICogICB1bmlzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcG9pbnQoZCkge1xuICByZXR1cm4ge2xpbmU6IGQubGluZSwgY29sdW1uOiBkLmNvbHVtbiwgb2Zmc2V0OiBkLm9mZnNldH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29tYmluZWRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RXh0ZW5zaW9uPiB8IEV4dGVuc2lvbj59IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZShjb21iaW5lZCwgZXh0ZW5zaW9ucykge1xuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbnNbaW5kZXhdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbmZpZ3VyZShjb21iaW5lZCwgdmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuc2lvbihjb21iaW5lZCwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25maWd9IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0V4dGVuc2lvbn0gZXh0ZW5zaW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBleHRlbnNpb24oY29tYmluZWQsIGV4dGVuc2lvbikge1xuICAvKiogQHR5cGUge2tleW9mIEV4dGVuc2lvbn0gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIGV4dGVuc2lvbikge1xuICAgIGlmIChvd24uY2FsbChleHRlbnNpb24sIGtleSkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2NhbkNvbnRhaW5Fb2xzJzoge1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZXh0ZW5zaW9uW2tleV1cbiAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkW2tleV0ucHVzaCguLi5yaWdodClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3Jtcyc6IHtcbiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgY2FzZSAnZXhpdCc6IHtcbiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbWJpbmVkW2tleV0sIHJpZ2h0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHR5cGUge09uRW50ZXJFcnJvcn0gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjbG9zZSBgJyArXG4gICAgICAgIGxlZnQudHlwZSArXG4gICAgICAgICdgICgnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiBsZWZ0LnN0YXJ0LCBlbmQ6IGxlZnQuZW5kfSkgK1xuICAgICAgICAnKTogYSBkaWZmZXJlbnQgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIG9wZW4nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGAnICtcbiAgICAgICAgcmlnaHQudHlwZSArXG4gICAgICAgICdgLCAnICtcbiAgICAgICAgc3RyaW5naWZ5UG9zaXRpb24oe3N0YXJ0OiByaWdodC5zdGFydCwgZW5kOiByaWdodC5lbmR9KSArXG4gICAgICAgICcpIGlzIHN0aWxsIG9wZW4nXG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsib2siLCJhc3NlcnQiLCJ0b1N0cmluZyIsInBhcnNlIiwicG9zdHByb2Nlc3MiLCJwcmVwcm9jZXNzIiwiZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSIsImRlY29kZVN0cmluZyIsIm5vcm1hbGl6ZUlkZW50aWZpZXIiLCJjb2RlcyIsImNvbnN0YW50cyIsInR5cGVzIiwiZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UiLCJzdHJpbmdpZnlQb3NpdGlvbiIsIm93biIsImhhc093blByb3BlcnR5IiwiZnJvbU1hcmtkb3duIiwidmFsdWUiLCJlbmNvZGluZyIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJjb21waWxlciIsImRvY3VtZW50Iiwid3JpdGUiLCJjb25maWciLCJ0cmFuc2Zvcm1zIiwiY2FuQ29udGFpbkVvbHMiLCJlbnRlciIsImF1dG9saW5rIiwib3BlbmVyIiwibGluayIsImF1dG9saW5rUHJvdG9jb2wiLCJvbmVudGVyZGF0YSIsImF1dG9saW5rRW1haWwiLCJhdHhIZWFkaW5nIiwiaGVhZGluZyIsImJsb2NrUXVvdGUiLCJjaGFyYWN0ZXJFc2NhcGUiLCJjaGFyYWN0ZXJSZWZlcmVuY2UiLCJjb2RlRmVuY2VkIiwiY29kZUZsb3ciLCJjb2RlRmVuY2VkRmVuY2VJbmZvIiwiYnVmZmVyIiwiY29kZUZlbmNlZEZlbmNlTWV0YSIsImNvZGVJbmRlbnRlZCIsImNvZGVUZXh0IiwiY29kZVRleHREYXRhIiwiZGF0YSIsImNvZGVGbG93VmFsdWUiLCJkZWZpbml0aW9uIiwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nIiwiZGVmaW5pdGlvbkxhYmVsU3RyaW5nIiwiZGVmaW5pdGlvblRpdGxlU3RyaW5nIiwiZW1waGFzaXMiLCJoYXJkQnJlYWtFc2NhcGUiLCJoYXJkQnJlYWsiLCJoYXJkQnJlYWtUcmFpbGluZyIsImh0bWxGbG93IiwiaHRtbCIsImh0bWxGbG93RGF0YSIsImh0bWxUZXh0IiwiaHRtbFRleHREYXRhIiwiaW1hZ2UiLCJsYWJlbCIsImxpc3RJdGVtIiwibGlzdEl0ZW1WYWx1ZSIsIm9uZW50ZXJsaXN0aXRlbXZhbHVlIiwibGlzdE9yZGVyZWQiLCJsaXN0Iiwib25lbnRlcmxpc3RvcmRlcmVkIiwibGlzdFVub3JkZXJlZCIsInBhcmFncmFwaCIsInJlZmVyZW5jZSIsIm9uZW50ZXJyZWZlcmVuY2UiLCJyZWZlcmVuY2VTdHJpbmciLCJyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nIiwicmVzb3VyY2VUaXRsZVN0cmluZyIsInNldGV4dEhlYWRpbmciLCJzdHJvbmciLCJ0aGVtYXRpY0JyZWFrIiwiZXhpdCIsImNsb3NlciIsImF0eEhlYWRpbmdTZXF1ZW5jZSIsIm9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSIsIm9uZXhpdGF1dG9saW5rZW1haWwiLCJvbmV4aXRhdXRvbGlua3Byb3RvY29sIiwiY2hhcmFjdGVyRXNjYXBlVmFsdWUiLCJvbmV4aXRkYXRhIiwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIiLCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljIiwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWUiLCJvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2V2YWx1ZSIsIm9uZXhpdGNvZGVmZW5jZWQiLCJjb2RlRmVuY2VkRmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2UiLCJvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvIiwib25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSIsIm9uZXhpdGNvZGVpbmRlbnRlZCIsIm9uZXhpdGNvZGV0ZXh0Iiwib25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nIiwib25leGl0ZGVmaW5pdGlvbnRpdGxlc3RyaW5nIiwib25leGl0aGFyZGJyZWFrIiwib25leGl0aHRtbGZsb3ciLCJvbmV4aXRodG1sdGV4dCIsIm9uZXhpdGltYWdlIiwib25leGl0bGFiZWwiLCJsYWJlbFRleHQiLCJvbmV4aXRsYWJlbHRleHQiLCJsaW5lRW5kaW5nIiwib25leGl0bGluZWVuZGluZyIsIm9uZXhpdGxpbmsiLCJvbmV4aXRyZWZlcmVuY2VzdHJpbmciLCJvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nIiwib25leGl0cmVzb3VyY2V0aXRsZXN0cmluZyIsInJlc291cmNlIiwib25leGl0cmVzb3VyY2UiLCJvbmV4aXRzZXRleHRoZWFkaW5nIiwic2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZSIsIm9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UiLCJzZXRleHRIZWFkaW5nVGV4dCIsIm9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0IiwiY29uZmlndXJlIiwibWRhc3RFeHRlbnNpb25zIiwiY29tcGlsZSIsImV2ZW50cyIsInRyZWUiLCJ0eXBlIiwiY2hpbGRyZW4iLCJjb250ZXh0Iiwic3RhY2siLCJ0b2tlblN0YWNrIiwicmVzdW1lIiwibGlzdFN0YWNrIiwiaW5kZXgiLCJsZW5ndGgiLCJwdXNoIiwidGFpbCIsInBvcCIsInByZXBhcmVMaXN0IiwiaGFuZGxlciIsImNhbGwiLCJPYmplY3QiLCJhc3NpZ24iLCJzbGljZVNlcmlhbGl6ZSIsImRlZmF1bHRPbkVycm9yIiwicG9zaXRpb24iLCJzdGFydCIsInBvaW50IiwibGluZSIsImNvbHVtbiIsIm9mZnNldCIsImVuZCIsImNvbnRhaW5lckJhbGFuY2UiLCJsaXN0U3ByZWFkIiwibGluZUluZGV4IiwiZmlyc3RCbGFua0xpbmVJbmRleCIsImF0TWFya2VyIiwiZXZlbnQiLCJsaW5lRW5kaW5nQmxhbmsiLCJsaW5lUHJlZml4IiwibGlzdEl0ZW1NYXJrZXIiLCJsaXN0SXRlbVByZWZpeCIsImxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZSIsInRhaWxJbmRleCIsInRhaWxFdmVudCIsImJsb2NrUXVvdGVQcmVmaXgiLCJibG9ja1F1b3RlUHJlZml4V2hpdGVzcGFjZSIsImJsb2NrUXVvdGVNYXJrZXIiLCJsaXN0SXRlbUluZGVudCIsIl9zcHJlYWQiLCJzcGxpY2UiLCJpdGVtIiwiY3JlYXRlIiwiYW5kIiwib3BlbiIsInRva2VuIiwibm9kZSIsImVycm9ySGFuZGxlciIsInBhcmVudCIsInNpYmxpbmdzIiwiY2xvc2UiLCJvbkV4aXRFcnJvciIsIkVycm9yIiwiZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlIiwiYW5jZXN0b3IiLCJOdW1iZXIiLCJwYXJzZUludCIsIm51bWVyaWNCYXNlRGVjaW1hbCIsImxhbmciLCJtZXRhIiwiZmxvd0NvZGVJbnNpZGUiLCJyZXBsYWNlIiwiaWRlbnRpZmllciIsInRvTG93ZXJDYXNlIiwidGl0bGUiLCJ1cmwiLCJkZXB0aCIsInNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmciLCJjb2RlUG9pbnRBdCIsImVxdWFsc1RvIiwidGV4dCIsImF0SGFyZEJyZWFrIiwiaW5jbHVkZXMiLCJpblJlZmVyZW5jZSIsInJlZmVyZW5jZVR5cGUiLCJzdHJpbmciLCJmcmFnbWVudCIsImFsdCIsImNoYXJhY3RlclJlZmVyZW5jZVR5cGUiLCJudW1lcmljQmFzZUhleGFkZWNpbWFsIiwicmVzdWx0Iiwib3JkZXJlZCIsInNwcmVhZCIsImNoZWNrZWQiLCJkIiwiY29tYmluZWQiLCJleHRlbnNpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiZXh0ZW5zaW9uIiwia2V5IiwicmlnaHQiLCJsZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ })

};
;