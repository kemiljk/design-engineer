"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createAsyncCache: () => (/* binding */ createAsyncCache),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentsApi: () => (/* binding */ createCommentsApi),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n    if (false) {} else {\n        throw new Error(msg);\n    }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n    const pkgId = Symbol.for(pkgName);\n    const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n    if (!g[pkgId]) {\n        g[pkgId] = pkgBuildInfo;\n    } else if (g[pkgId] === pkgBuildInfo) {} else {\n        const msg = [\n            `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n            \"\",\n            \"Conflicts:\",\n            `- ${pkgName} ${g[pkgId]} (already loaded)`,\n            `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n        ].join(\"\\n\");\n        error(msg);\n    }\n    if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n        error([\n            `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n            \"\",\n            \"Conflicts:\",\n            `- ${PKG_NAME} is at ${PKG_VERSION}`,\n            `- ${pkgName} is at ${pkgVersion}`,\n            \"\",\n            \"Always upgrade all Liveblocks packages to the same version number.\"\n        ].join(\"\\n\"));\n    }\n}\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n    throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n    if (true) {\n        if (!condition) {\n            const err = new Error(errmsg);\n            err.name = \"Assertion failure\";\n            throw err;\n        }\n    }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n    assert(value !== null && value !== void 0, errmsg);\n    return value;\n}\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n    let flagger;\n    const promise = new Promise((res)=>{\n        flagger = res;\n    });\n    if (!flagger) {\n        throw new Error(\"Should never happen\");\n    }\n    return [\n        promise,\n        flagger\n    ];\n}\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n    const _onetimeObservers = /* @__PURE__ */ new Set();\n    const _observers = /* @__PURE__ */ new Set();\n    let _buffer = null;\n    function pause() {\n        _buffer = [];\n    }\n    function unpause() {\n        if (_buffer === null) {\n            return;\n        }\n        for (const event of _buffer){\n            notify(event);\n        }\n        _buffer = null;\n    }\n    function subscribe(callback) {\n        _observers.add(callback);\n        return ()=>_observers.delete(callback);\n    }\n    function subscribeOnce(callback) {\n        _onetimeObservers.add(callback);\n        return ()=>_onetimeObservers.delete(callback);\n    }\n    async function waitUntil(predicate) {\n        let unsub;\n        return new Promise((res)=>{\n            unsub = subscribe((event)=>{\n                if (predicate === void 0 || predicate(event)) {\n                    res(event);\n                }\n            });\n        }).finally(()=>unsub?.());\n    }\n    function notifyOrBuffer(event) {\n        if (_buffer !== null) {\n            _buffer.push(event);\n        } else {\n            notify(event);\n        }\n    }\n    function notify(event) {\n        _onetimeObservers.forEach((callback)=>callback(event));\n        _onetimeObservers.clear();\n        _observers.forEach((callback)=>callback(event));\n    }\n    function clear() {\n        _onetimeObservers.clear();\n        _observers.clear();\n    }\n    function count() {\n        return _onetimeObservers.size + _observers.size;\n    }\n    return {\n        // Private/internal control over event emission\n        notify: notifyOrBuffer,\n        subscribe,\n        subscribeOnce,\n        clear,\n        count,\n        waitUntil,\n        pause,\n        unpause,\n        // Publicly exposable subscription API\n        observable: {\n            subscribe,\n            subscribeOnce,\n            waitUntil\n        }\n    };\n}\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n    error: ()=>error2,\n    errorWithTitle: ()=>errorWithTitle,\n    warn: ()=>warn,\n    warnWithTitle: ()=>warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n    return  true ? console[method] : /* istanbul ignore next */ 0;\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n    return  true ? console[method] : /* istanbul ignore next */ 0;\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n    if (state1 === state2) {\n        return [\n            0,\n            0\n        ];\n    }\n    const chunks1 = state1.split(\".\");\n    const chunks2 = state2.split(\".\");\n    const minLen = Math.min(chunks1.length, chunks2.length);\n    let shared = 0;\n    for(; shared < minLen; shared++){\n        if (chunks1[shared] !== chunks2[shared]) {\n            break;\n        }\n    }\n    const up = chunks1.length - shared;\n    const down = chunks2.length - shared;\n    return [\n        up,\n        down\n    ];\n}\nfunction patterns(targetState, levels) {\n    const parts = targetState.split(\".\");\n    if (levels < 1 || levels > parts.length + 1) {\n        throw new Error(\"Invalid number of levels\");\n    }\n    const result = [];\n    if (levels > parts.length) {\n        result.push(\"*\");\n    }\n    for(let i = parts.length - levels + 1; i < parts.length; i++){\n        const slice = parts.slice(0, i);\n        if (slice.length > 0) {\n            result.push(slice.join(\".\") + \".*\");\n        }\n    }\n    result.push(targetState);\n    return result;\n}\nvar SafeContext = class {\n    constructor(initialContext){\n        this.curr = initialContext;\n    }\n    get current() {\n        return this.curr;\n    }\n    /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */ allowPatching(callback) {\n        const self = this;\n        let allowed = true;\n        const patchableContext = {\n            ...this.curr,\n            patch (patch) {\n                if (allowed) {\n                    self.curr = Object.assign({}, self.curr, patch);\n                    for (const pair of Object.entries(patch)){\n                        const [key, value] = pair;\n                        if (key !== \"patch\") {\n                            this[key] = value;\n                        }\n                    }\n                } else {\n                    throw new Error(\"Can no longer patch stale context\");\n                }\n            }\n        };\n        callback(patchableContext);\n        allowed = false;\n        return;\n    }\n};\nvar nextId = 1;\nvar FSM = class {\n    /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */ get initialState() {\n        const result = this.states.values()[Symbol.iterator]().next();\n        if (result.done) {\n            throw new Error(\"No states defined yet\");\n        } else {\n            return result.value;\n        }\n    }\n    get currentState() {\n        if (this.currentStateOrNull === null) {\n            if (this.runningState === 0 /* NOT_STARTED_YET */ ) {\n                throw new Error(\"Not started yet\");\n            } else {\n                throw new Error(\"Already stopped\");\n            }\n        }\n        return this.currentStateOrNull;\n    }\n    /**\n   * Starts the machine by entering the initial state.\n   */ start() {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"State machine has already started\");\n        }\n        this.runningState = 1 /* STARTED */ ;\n        this.currentStateOrNull = this.initialState;\n        this.enter(null);\n        return this;\n    }\n    /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */ stop() {\n        if (this.runningState !== 1 /* STARTED */ ) {\n            throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n        }\n        this.exit(null);\n        this.runningState = 2 /* STOPPED */ ;\n        this.currentStateOrNull = null;\n    }\n    constructor(initialContext){\n        this.id = nextId++;\n        this.runningState = 0 /* NOT_STARTED_YET */ ;\n        this.currentStateOrNull = null;\n        this.states = /* @__PURE__ */ new Set();\n        this.enterFns = /* @__PURE__ */ new Map();\n        this.cleanupStack = [];\n        this.knownEventTypes = /* @__PURE__ */ new Set();\n        this.allowedTransitions = /* @__PURE__ */ new Map();\n        this.currentContext = new SafeContext(initialContext);\n        this.eventHub = {\n            didReceiveEvent: makeEventSource(),\n            willTransition: makeEventSource(),\n            didIgnoreEvent: makeEventSource(),\n            willExitState: makeEventSource(),\n            didEnterState: makeEventSource()\n        };\n        this.events = {\n            didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n            willTransition: this.eventHub.willTransition.observable,\n            didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n            willExitState: this.eventHub.willExitState.observable,\n            didEnterState: this.eventHub.didEnterState.observable\n        };\n    }\n    get context() {\n        return this.currentContext.current;\n    }\n    /**\n   * Define an explicit finite state in the state machine.\n   */ addState(state) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        this.states.add(state);\n        return this;\n    }\n    onEnter(nameOrPattern, enterFn) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        } else if (this.enterFns.has(nameOrPattern)) {\n            throw new Error(// TODO We _currently_ don't support multiple .onEnters() for the same\n            // state, but this is not a fundamental limitation. Just not\n            // implemented yet. If we wanted to, we could make this an array.\n            `enter/exit function for ${nameOrPattern} already exists`);\n        }\n        this.enterFns.set(nameOrPattern, enterFn);\n        return this;\n    }\n    onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n        return this.onEnter(nameOrPattern, ()=>{\n            let cancelled = false;\n            void promiseFn(this.currentContext.current).then(// On OK\n            (data)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_OK\",\n                        data\n                    }, onOK);\n                }\n            }, // On Error\n            (reason)=>{\n                if (!cancelled) {\n                    this.transition({\n                        type: \"ASYNC_ERROR\",\n                        reason\n                    }, onError);\n                }\n            });\n            return ()=>{\n                cancelled = true;\n            };\n        });\n    }\n    getStatesMatching(nameOrPattern) {\n        const matches = [];\n        if (nameOrPattern === \"*\") {\n            for (const state of this.states){\n                matches.push(state);\n            }\n        } else if (nameOrPattern.endsWith(\".*\")) {\n            const prefix = nameOrPattern.slice(0, -1);\n            for (const state of this.states){\n                if (state.startsWith(prefix)) {\n                    matches.push(state);\n                }\n            }\n        } else {\n            const name = nameOrPattern;\n            if (this.states.has(name)) {\n                matches.push(name);\n            }\n        }\n        if (matches.length === 0) {\n            throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n        }\n        return matches;\n    }\n    /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */ addTransitions(nameOrPattern, mapping) {\n        if (this.runningState !== 0 /* NOT_STARTED_YET */ ) {\n            throw new Error(\"Already started\");\n        }\n        for (const srcState of this.getStatesMatching(nameOrPattern)){\n            let map = this.allowedTransitions.get(srcState);\n            if (map === void 0) {\n                map = /* @__PURE__ */ new Map();\n                this.allowedTransitions.set(srcState, map);\n            }\n            for (const [type, target_] of Object.entries(mapping)){\n                if (map.has(type)) {\n                    throw new Error(`Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`);\n                }\n                const target = target_;\n                this.knownEventTypes.add(type);\n                if (target !== void 0) {\n                    const targetFn = typeof target === \"function\" ? target : ()=>target;\n                    map.set(type, targetFn);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */ addTimedTransition(stateOrPattern, after2, target) {\n        return this.onEnter(stateOrPattern, ()=>{\n            const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n            const timeoutID = setTimeout(()=>{\n                this.transition({\n                    type: \"TIMER\"\n                }, target);\n            }, ms);\n            return ()=>{\n                clearTimeout(timeoutID);\n            };\n        });\n    }\n    getTargetFn(eventName) {\n        return this.allowedTransitions.get(this.currentState)?.get(eventName);\n    }\n    /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */ exit(levels) {\n        this.eventHub.willExitState.notify(this.currentState);\n        this.currentContext.allowPatching((patchableContext)=>{\n            levels = levels ?? this.cleanupStack.length;\n            for(let i = 0; i < levels; i++){\n                this.cleanupStack.pop()?.(patchableContext);\n            }\n        });\n    }\n    /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */ enter(levels) {\n        const enterPatterns = patterns(this.currentState, levels ?? this.currentState.split(\".\").length + 1);\n        this.currentContext.allowPatching((patchableContext)=>{\n            for (const pattern of enterPatterns){\n                const enterFn = this.enterFns.get(pattern);\n                const cleanupFn = enterFn?.(patchableContext);\n                if (typeof cleanupFn === \"function\") {\n                    this.cleanupStack.push(cleanupFn);\n                } else {\n                    this.cleanupStack.push(null);\n                }\n            }\n        });\n        this.eventHub.didEnterState.notify(this.currentState);\n    }\n    /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */ send(event) {\n        if (!this.knownEventTypes.has(event.type)) {\n            throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n        }\n        if (this.runningState === 2 /* STOPPED */ ) {\n            return;\n        }\n        const targetFn = this.getTargetFn(event.type);\n        if (targetFn !== void 0) {\n            return this.transition(event, targetFn);\n        } else {\n            this.eventHub.didIgnoreEvent.notify(event);\n        }\n    }\n    transition(event, target) {\n        this.eventHub.didReceiveEvent.notify(event);\n        const oldState = this.currentState;\n        const targetFn = typeof target === \"function\" ? target : ()=>target;\n        const nextTarget = targetFn(event, this.currentContext.current);\n        let nextState;\n        let effects = void 0;\n        if (nextTarget === null) {\n            this.eventHub.didIgnoreEvent.notify(event);\n            return;\n        }\n        if (typeof nextTarget === \"string\") {\n            nextState = nextTarget;\n        } else {\n            nextState = nextTarget.target;\n            effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [\n                nextTarget.effect\n            ];\n        }\n        if (!this.states.has(nextState)) {\n            throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n        }\n        this.eventHub.willTransition.notify({\n            from: oldState,\n            to: nextState\n        });\n        const [up, down] = distance(this.currentState, nextState);\n        if (up > 0) {\n            this.exit(up);\n        }\n        this.currentStateOrNull = nextState;\n        if (effects !== void 0) {\n            const effectsToRun = effects;\n            this.currentContext.allowPatching((patchableContext)=>{\n                for (const effect of effectsToRun){\n                    if (typeof effect === \"function\") {\n                        effect(patchableContext, event);\n                    } else {\n                        patchableContext.patch(effect);\n                    }\n                }\n            });\n        }\n        if (down > 0) {\n            this.enter(down);\n        }\n    }\n};\n// src/lib/utils.ts\nfunction raise(msg) {\n    throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n    return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n    return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n    try {\n        return JSON.parse(rawMessage);\n    } catch (e) {\n        return void 0;\n    }\n}\nfunction deepClone(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n    try {\n        const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        const decodedValue = decodeURIComponent(atob(formattedValue).split(\"\").map(function(c) {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join(\"\"));\n        return decodedValue;\n    } catch (err) {\n        return atob(b64value);\n    }\n}\nfunction compact(items) {\n    return items.filter((item)=>item !== null && item !== void 0);\n}\nfunction compactObject(obj) {\n    const newObj = {\n        ...obj\n    };\n    Object.keys(obj).forEach((k)=>{\n        const key = k;\n        if (newObj[key] === void 0) {\n            delete newObj[key];\n        }\n    });\n    return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n    let timerID;\n    const timer$ = new Promise((_, reject)=>{\n        timerID = setTimeout(()=>{\n            reject(new Error(errmsg));\n        }, millis);\n    });\n    return Promise.race([\n        promise,\n        timer$\n    ]).finally(()=>clearTimeout(timerID));\n}\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2)=>{\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n    ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n    ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n    ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n    ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n    ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n    return ServerMsgCode2;\n})(ServerMsgCode || {});\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2)=>{\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n    return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n    return code === 4999 /* CLOSE_WITHOUT_RETRY */  || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n    return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n    return code === 1013 /* TRY_AGAIN_LATER */  || code >= 4200 && code < 4300;\n}\n// src/connection.ts\nfunction isIdle(status) {\n    return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n    switch(status){\n        case \"connecting\":\n            return \"connecting\";\n        case \"connected\":\n            return \"open\";\n        case \"reconnecting\":\n            return \"unavailable\";\n        case \"disconnected\":\n            return \"failed\";\n        case \"initial\":\n            return \"closed\";\n        default:\n            return \"closed\";\n    }\n}\nfunction toNewConnectionStatus(machine) {\n    const state = machine.currentState;\n    switch(state){\n        case \"@ok.connected\":\n        case \"@ok.awaiting-pong\":\n            return \"connected\";\n        case \"@idle.initial\":\n            return \"initial\";\n        case \"@auth.busy\":\n        case \"@auth.backoff\":\n        case \"@connecting.busy\":\n        case \"@connecting.backoff\":\n        case \"@idle.zombie\":\n            return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n        case \"@idle.failed\":\n            return \"disconnected\";\n        default:\n            return assertNever(state, \"Unknown state\");\n    }\n}\nvar BACKOFF_DELAYS = [\n    250,\n    500,\n    1e3,\n    2e3,\n    4e3,\n    8e3,\n    1e4\n];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [\n    2e3,\n    3e4,\n    6e4,\n    3e5\n];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n    constructor(reason){\n        super(reason);\n    }\n};\nvar LiveblocksError = class extends Error {\n    constructor(message, code){\n        super(message);\n        this.code = code;\n    }\n};\nfunction nextBackoffDelay(currentDelay, delays = BACKOFF_DELAYS) {\n    return delays.find((delay)=>delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay)\n    });\n}\nfunction increaseBackoffDelayAggressively(context) {\n    context.patch({\n        backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n    });\n}\nfunction resetSuccessCount(context) {\n    context.patch({\n        successCount: 0\n    });\n}\nfunction log(level, message) {\n    const logger = level === 2 /* ERROR */  ? error2 : level === 1 /* WARN */  ? warn : /* black hole */ ()=>{};\n    return ()=>{\n        logger(message);\n    };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n    const conn = \"Connection to Liveblocks websocket server\";\n    return (ctx)=>{\n        if (e instanceof Error) {\n            warn(`${conn} could not be established. ${String(e)}`);\n        } else {\n            warn(isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`);\n        }\n    };\n}\nfunction logCloseEvent(event) {\n    return (ctx)=>{\n        warn(`Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${ctx.backoffDelay}ms.`);\n    };\n}\nvar logPermanentClose = log(1 /* WARN */ , \"Connection to WebSocket closed permanently. Won't retry.\");\nfunction isCloseEvent(error3) {\n    return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n    const start = /* @__PURE__ */ new Date().getTime();\n    function log2(...args) {\n        warn(`${((/* @__PURE__ */ new Date().getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`, ...args);\n    }\n    const unsubs = [\n        machine.events.didReceiveEvent.subscribe((e)=>log2(`Event ${e.type}`)),\n        machine.events.willTransition.subscribe(({ from, to })=>log2(\"Transitioning\", from, \"â†’\", to)),\n        machine.events.didIgnoreEvent.subscribe((e)=>log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\"))\n    ];\n    return ()=>{\n        for (const unsub of unsubs){\n            unsub();\n        }\n    };\n}\nfunction defineConnectivityEvents(machine) {\n    const statusDidChange = makeEventSource();\n    const didConnect = makeEventSource();\n    const didDisconnect = makeEventSource();\n    let lastStatus = null;\n    const unsubscribe = machine.events.didEnterState.subscribe(()=>{\n        const currStatus = toNewConnectionStatus(machine);\n        if (currStatus !== lastStatus) {\n            statusDidChange.notify(currStatus);\n        }\n        if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n            didDisconnect.notify();\n        } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n            didConnect.notify();\n        }\n        lastStatus = currStatus;\n    });\n    return {\n        statusDidChange: statusDidChange.observable,\n        didConnect: didConnect.observable,\n        didDisconnect: didDisconnect.observable,\n        unsubscribe\n    };\n}\nvar assign = (patch)=>(ctx)=>ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n    const onMessage = makeEventSource();\n    onMessage.pause();\n    const onLiveblocksError = makeEventSource();\n    function fireErrorEvent(errmsg, errcode) {\n        return ()=>{\n            const err = new LiveblocksError(errmsg, errcode);\n            onLiveblocksError.notify(err);\n        };\n    }\n    const initialContext = {\n        successCount: 0,\n        authValue: null,\n        socket: null,\n        backoffDelay: RESET_DELAY\n    };\n    const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n    machine.addTransitions(\"*\", {\n        RECONNECT: {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                resetSuccessCount\n            ]\n        },\n        DISCONNECT: \"@idle.initial\"\n    });\n    machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n        CONNECT: (_, ctx)=>// If we still have a known authValue, try to reconnect to the socket directly,\n            // otherwise, try to obtain a new authValue\n            ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    });\n    machine.addTransitions(\"@auth.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@auth.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@auth.backoff\", (ctx)=>ctx.backoffDelay, \"@auth.busy\").onEnterAsync(\"@auth.busy\", ()=>withTimeout(delegates.authenticate(), AUTH_TIMEOUT, \"Timed out during auth\"), // On successful authentication\n    (okEvent)=>({\n            target: \"@connecting.busy\",\n            effect: assign({\n                authValue: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // Auth failed\n    (failedEvent)=>{\n        if (failedEvent.reason instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , failedEvent.reason.message),\n                    fireErrorEvent(failedEvent.reason.message, -1)\n                ]\n            };\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                log(2 /* ERROR */ , `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`)\n            ]\n        };\n    });\n    const onSocketError = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_ERROR\",\n            event\n        });\n    const onSocketClose = (event)=>machine.send({\n            type: \"EXPLICIT_SOCKET_CLOSE\",\n            event\n        });\n    const onSocketMessage = (event)=>event.data === \"pong\" ? machine.send({\n            type: \"PONG\"\n        }) : onMessage.notify(event);\n    function teardownSocket(socket) {\n        if (socket) {\n            socket.removeEventListener(\"error\", onSocketError);\n            socket.removeEventListener(\"close\", onSocketClose);\n            socket.removeEventListener(\"message\", onSocketMessage);\n            socket.close();\n        }\n    }\n    machine.addTransitions(\"@connecting.backoff\", {\n        NAVIGATOR_ONLINE: {\n            target: \"@connecting.busy\",\n            effect: assign({\n                backoffDelay: RESET_DELAY\n            })\n        }\n    }).addTimedTransition(\"@connecting.backoff\", (ctx)=>ctx.backoffDelay, \"@connecting.busy\").onEnterAsync(\"@connecting.busy\", //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx)=>{\n        let capturedPrematureEvent = null;\n        const connect$ = new Promise((resolve, rej)=>{\n            if (ctx.authValue === null) {\n                throw new Error(\"No auth authValue\");\n            }\n            const socket = delegates.createSocket(ctx.authValue);\n            function reject(event) {\n                capturedPrematureEvent = event;\n                socket.removeEventListener(\"message\", onSocketMessage);\n                rej(event);\n            }\n            const [actor$, didReceiveActor] = controlledPromise();\n            if (!options.waitForActorId) {\n                didReceiveActor();\n            }\n            function waitForActorId(event) {\n                const serverMsg = tryParseJson(event.data);\n                if (serverMsg?.type === 104 /* ROOM_STATE */ ) {\n                    didReceiveActor();\n                }\n            }\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n                socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject);\n            socket.addEventListener(\"close\", reject);\n            socket.addEventListener(\"open\", ()=>{\n                socket.addEventListener(\"error\", onSocketError);\n                socket.addEventListener(\"close\", onSocketClose);\n                const unsub = ()=>{\n                    socket.removeEventListener(\"error\", reject);\n                    socket.removeEventListener(\"close\", reject);\n                    socket.removeEventListener(\"message\", waitForActorId);\n                };\n                void actor$.then(()=>{\n                    resolve([\n                        socket,\n                        unsub\n                    ]);\n                });\n            });\n        });\n        return withTimeout(connect$, SOCKET_CONNECT_TIMEOUT, \"Timed out during websocket connection\").then(//\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub])=>{\n            unsub();\n            if (capturedPrematureEvent) {\n                throw capturedPrematureEvent;\n            }\n            return socket;\n        });\n    }, // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent)=>({\n            target: \"@ok.connected\",\n            effect: assign({\n                socket: okEvent.data,\n                backoffDelay: RESET_DELAY\n            })\n        }), // If the WebSocket connection cannot be established\n    (failure)=>{\n        const err = failure.reason;\n        if (err instanceof StopRetrying) {\n            return {\n                target: \"@idle.failed\",\n                effect: [\n                    log(2 /* ERROR */ , err.message),\n                    fireErrorEvent(err.message, -1)\n                ]\n            };\n        }\n        if (isCloseEvent(err)) {\n            if (err.code === 4109 /* TOKEN_EXPIRED */ ) {\n                return \"@auth.busy\";\n            }\n            if (shouldRetryWithoutReauth(err.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logPrematureErrorOrCloseEvent(err)\n                    ]\n                };\n            }\n            if (shouldDisconnect(err.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        log(2 /* ERROR */ , err.reason),\n                        fireErrorEvent(err.reason, err.code)\n                    ]\n                };\n            }\n        }\n        return {\n            target: \"@auth.backoff\",\n            effect: [\n                increaseBackoffDelay,\n                logPrematureErrorOrCloseEvent(err)\n            ]\n        };\n    });\n    const sendHeartbeat = {\n        target: \"@ok.awaiting-pong\",\n        effect: (ctx)=>{\n            ctx.socket?.send(\"ping\");\n        }\n    };\n    const maybeHeartbeat = ()=>{\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n        return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n    };\n    machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n        NAVIGATOR_OFFLINE: maybeHeartbeat,\n        // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n        WINDOW_GOT_FOCUS: sendHeartbeat\n    });\n    machine.addTransitions(\"@idle.zombie\", {\n        WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    });\n    machine.onEnter(\"@ok.*\", (ctx)=>{\n        ctx.patch({\n            successCount: ctx.successCount + 1\n        });\n        const timerID = setTimeout(// On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause, 0);\n        return (ctx2)=>{\n            teardownSocket(ctx2.socket);\n            ctx2.patch({\n                socket: null\n            });\n            clearTimeout(timerID);\n            onMessage.pause();\n        };\n    }).addTransitions(\"@ok.awaiting-pong\", {\n        PONG: \"@ok.connected\"\n    }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n        target: \"@connecting.busy\",\n        // Log implicit connection loss and drop the current open socket\n        effect: log(1 /* WARN */ , \"Received no pong from server, assume implicit connection loss.\")\n    }).addTransitions(\"@ok.*\", {\n        // When a socket receives an error, this can cause the closing of the\n        // socket, or not. So always check to see if the socket is still OPEN or\n        // not. When still OPEN, don't transition.\n        EXPLICIT_SOCKET_ERROR: (_, context)=>{\n            if (context.socket?.readyState === 1) {\n                return null;\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: increaseBackoffDelay\n            };\n        },\n        EXPLICIT_SOCKET_CLOSE: (e)=>{\n            if (shouldDisconnect(e.event.code)) {\n                return {\n                    target: \"@idle.failed\",\n                    effect: [\n                        logPermanentClose,\n                        fireErrorEvent(e.event.reason, e.event.code)\n                    ]\n                };\n            }\n            if (shouldReauth(e.event.code)) {\n                if (e.event.code === 4109 /* TOKEN_EXPIRED */ ) {\n                    return \"@auth.busy\";\n                } else {\n                    return {\n                        target: \"@auth.backoff\",\n                        effect: [\n                            increaseBackoffDelay,\n                            logCloseEvent(e.event)\n                        ]\n                    };\n                }\n            }\n            if (shouldRetryWithoutReauth(e.event.code)) {\n                return {\n                    target: \"@connecting.backoff\",\n                    effect: [\n                        increaseBackoffDelayAggressively,\n                        logCloseEvent(e.event)\n                    ]\n                };\n            }\n            return {\n                target: \"@connecting.backoff\",\n                effect: [\n                    increaseBackoffDelay,\n                    logCloseEvent(e.event)\n                ]\n            };\n        }\n    });\n    if (typeof document !== \"undefined\") {\n        const doc = typeof document !== \"undefined\" ? document : void 0;\n        const win =  false ? 0 : void 0;\n        const root = win ?? doc;\n        machine.onEnter(\"*\", (ctx)=>{\n            function onNetworkOffline() {\n                machine.send({\n                    type: \"NAVIGATOR_OFFLINE\"\n                });\n            }\n            function onNetworkBackOnline() {\n                machine.send({\n                    type: \"NAVIGATOR_ONLINE\"\n                });\n            }\n            function onVisibilityChange() {\n                if (doc?.visibilityState === \"visible\") {\n                    machine.send({\n                        type: \"WINDOW_GOT_FOCUS\"\n                    });\n                }\n            }\n            win?.addEventListener(\"online\", onNetworkBackOnline);\n            win?.addEventListener(\"offline\", onNetworkOffline);\n            root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n            return ()=>{\n                root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n                win?.removeEventListener(\"online\", onNetworkBackOnline);\n                win?.removeEventListener(\"offline\", onNetworkOffline);\n                teardownSocket(ctx.socket);\n            };\n        });\n    }\n    const cleanups = [];\n    const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n    cleanups.push(unsubscribe);\n    if (options.enableDebugLogging) {\n        cleanups.push(enableTracing(machine));\n    }\n    machine.start();\n    return {\n        machine,\n        cleanups,\n        // Observable events that will be emitted by this machine\n        events: {\n            statusDidChange,\n            didConnect,\n            didDisconnect,\n            onMessage: onMessage.observable,\n            onLiveblocksError: onLiveblocksError.observable\n        }\n    };\n}\nvar ManagedSocket = class {\n    constructor(delegates, enableDebugLogging = false, waitForActorId = true){\n        const { machine, events, cleanups } = createConnectionStateMachine(delegates, {\n            waitForActorId,\n            enableDebugLogging\n        });\n        this.machine = machine;\n        this.events = events;\n        this.cleanups = cleanups;\n    }\n    getLegacyStatus() {\n        return newToLegacyStatus(this.getStatus());\n    }\n    getStatus() {\n        try {\n            return toNewConnectionStatus(this.machine);\n        } catch  {\n            return \"initial\";\n        }\n    }\n    /**\n   * Returns the current auth authValue.\n   */ get authValue() {\n        return this.machine.context.authValue;\n    }\n    /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */ connect() {\n        this.machine.send({\n            type: \"CONNECT\"\n        });\n    }\n    /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */ reconnect() {\n        this.machine.send({\n            type: \"RECONNECT\"\n        });\n    }\n    /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */ disconnect() {\n        this.machine.send({\n            type: \"DISCONNECT\"\n        });\n    }\n    /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */ destroy() {\n        this.machine.stop();\n        let cleanup;\n        while(cleanup = this.cleanups.pop()){\n            cleanup();\n        }\n    }\n    /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */ send(data) {\n        const socket = this.machine.context?.socket;\n        if (socket === null) {\n            warn(\"Cannot send: not connected yet\", data);\n        } else if (socket.readyState !== 1) {\n            warn(\"Cannot send: WebSocket no longer open\", data);\n        } else {\n            socket.send(data);\n        }\n    }\n    /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */ _privateSendMachineEvent(event) {\n        this.machine.send(event);\n    }\n};\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n    return scopes.includes(\"room:write\" /* Write */ );\n}\nfunction canComment(scopes) {\n    return scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:write\" /* Write */ );\n}\nfunction isValidAuthTokenPayload(data) {\n    return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */  || data.k === \"id\" /* ID_TOKEN */  || data.k === \"sec-legacy\" /* SECRET_LEGACY */ );\n}\nfunction parseAuthToken(rawTokenString) {\n    const tokenParts = rawTokenString.split(\".\");\n    if (tokenParts.length !== 3) {\n        throw new Error(\"Authentication error: invalid JWT token\");\n    }\n    const payload = tryParseJson(b64decode(tokenParts[1]));\n    if (!(payload && isValidAuthTokenPayload(payload))) {\n        throw new Error(\"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\");\n    }\n    return {\n        raw: rawTokenString,\n        parsed: payload\n    };\n}\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n    const authentication = prepareAuthentication(authOptions);\n    const seenTokens = /* @__PURE__ */ new Set();\n    const tokens = [];\n    const expiryTimes = [];\n    const requestPromises = /* @__PURE__ */ new Map();\n    function reset() {\n        seenTokens.clear();\n        tokens.length = 0;\n        expiryTimes.length = 0;\n        requestPromises.clear();\n    }\n    function hasCorrespondingScopes(requestedScope, scopes) {\n        if (requestedScope === \"comments:read\") {\n            return scopes.includes(\"comments:read\" /* CommentsRead */ ) || scopes.includes(\"comments:write\" /* CommentsWrite */ ) || scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        } else if (requestedScope === \"room:read\") {\n            return scopes.includes(\"room:read\" /* Read */ ) || scopes.includes(\"room:write\" /* Write */ );\n        }\n        return false;\n    }\n    function getCachedToken(requestedScope, roomId) {\n        const now = Math.ceil(Date.now() / 1e3);\n        for(let i = tokens.length - 1; i >= 0; i--){\n            const token = tokens[i];\n            const expiresAt = expiryTimes[i];\n            if (expiresAt <= now) {\n                tokens.splice(i, 1);\n                expiryTimes.splice(i, 1);\n                continue;\n            }\n            if (token.parsed.k === \"id\" /* ID_TOKEN */ ) {\n                return token;\n            } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */ ) {\n                for (const [resource, scopes] of Object.entries(token.parsed.perms)){\n                    if (resource.includes(\"*\") && roomId.startsWith(resource.replace(\"*\", \"\")) || roomId === resource && hasCorrespondingScopes(requestedScope, scopes)) {\n                        return token;\n                    }\n                }\n            }\n        }\n        return void 0;\n    }\n    async function makeAuthRequest(roomId) {\n        const fetcher = authOptions.polyfills?.fetch ?? ( true ? void 0 : 0);\n        if (authentication.type === \"private\") {\n            if (fetcher === void 0) {\n                throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\");\n            }\n            const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n                room: roomId\n            });\n            const parsed = parseAuthToken(response.token);\n            if (seenTokens.has(parsed.raw)) {\n                throw new StopRetrying(\"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\");\n            }\n            return parsed;\n        }\n        if (authentication.type === \"custom\") {\n            const response = await authentication.callback(roomId);\n            if (response && typeof response === \"object\") {\n                if (typeof response.token === \"string\") {\n                    return parseAuthToken(response.token);\n                } else if (typeof response.error === \"string\") {\n                    const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n                    if (response.error === \"forbidden\") {\n                        throw new StopRetrying(reason);\n                    } else {\n                        throw new Error(reason);\n                    }\n                }\n            }\n            throw new Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }');\n        }\n        throw new Error(\"Unexpected authentication type. Must be private or custom.\");\n    }\n    async function getAuthValue(requestedScope, roomId) {\n        if (authentication.type === \"public\") {\n            return {\n                type: \"public\",\n                publicApiKey: authentication.publicApiKey\n            };\n        }\n        const cachedToken = getCachedToken(requestedScope, roomId);\n        if (cachedToken !== void 0) {\n            return {\n                type: \"secret\",\n                token: cachedToken\n            };\n        }\n        let currentPromise = requestPromises.get(roomId);\n        if (currentPromise === void 0) {\n            currentPromise = makeAuthRequest(roomId);\n            requestPromises.set(roomId, currentPromise);\n        }\n        try {\n            const token = await currentPromise;\n            const BUFFER = 30;\n            const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n            seenTokens.add(token.raw);\n            if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */ ) {\n                tokens.push(token);\n                expiryTimes.push(expiresAt);\n            }\n            return {\n                type: \"secret\",\n                token\n            };\n        } finally{\n            requestPromises.delete(roomId);\n        }\n    }\n    return {\n        reset,\n        getAuthValue\n    };\n}\nfunction prepareAuthentication(authOptions) {\n    const { publicApiKey, authEndpoint } = authOptions;\n    if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n        throw new Error(\"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n    }\n    if (typeof publicApiKey === \"string\") {\n        if (publicApiKey.startsWith(\"sk_\")) {\n            throw new Error(\"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        } else if (!publicApiKey.startsWith(\"pk_\")) {\n            throw new Error(\"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n        }\n        return {\n            type: \"public\",\n            publicApiKey\n        };\n    }\n    if (typeof authEndpoint === \"string\") {\n        return {\n            type: \"private\",\n            url: authEndpoint\n        };\n    } else if (typeof authEndpoint === \"function\") {\n        return {\n            type: \"custom\",\n            callback: authEndpoint\n        };\n    } else if (authEndpoint !== void 0) {\n        throw new Error(\"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\");\n    }\n    throw new Error(\"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n    const res = await fetch2(endpoint, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n    });\n    if (!res.ok) {\n        const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n        if (res.status === 401 || res.status === 403) {\n            throw new StopRetrying(`Unauthorized: ${reason}`);\n        } else {\n            throw new Error(`Failed to authenticate: ${reason}`);\n        }\n    }\n    let data;\n    try {\n        data = await res.json();\n    } catch (er) {\n        throw new Error(`Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(er)}`);\n    }\n    if (!isPlainObject(data) || typeof data.token !== \"string\") {\n        throw new Error(`Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(data)}`);\n    }\n    const { token } = data;\n    return {\n        token\n    };\n}\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n    _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n    if (true) {\n        return;\n    }\n    const fullMsg = {\n        ...message,\n        source: \"liveblocks-devtools-client\"\n    };\n    if (!(options?.force || _bridgeActive)) {\n        return;\n    }\n    window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (false) {}\nvar onMessageFromPanel = eventSource.observable;\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n    if (true) {\n        return;\n    }\n    if (_devtoolsSetupHasRun) {\n        return;\n    }\n    _devtoolsSetupHasRun = true;\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"connect\":\n                {\n                    activateBridge(true);\n                    for (const roomId of getAllRooms()){\n                        sendToPanel({\n                            msg: \"room::available\",\n                            roomId,\n                            clientVersion: VERSION\n                        });\n                    }\n                    break;\n                }\n        }\n    });\n    sendToPanel({\n        msg: \"wake-up-devtools\"\n    }, {\n        force: true\n    });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n    const unsubs = unsubsByRoomId.get(roomId) ?? [];\n    unsubsByRoomId.delete(roomId);\n    for (const unsub of unsubs){\n        unsub();\n    }\n}\nfunction startSyncStream(room) {\n    stopSyncStream(room.id);\n    fullSync(room);\n    unsubsByRoomId.set(room.id, [\n        // When the connection status changes\n        room.events.status.subscribe(()=>partialSyncConnection(room)),\n        // When storage initializes, send the update\n        room.events.storageDidLoad.subscribeOnce(()=>partialSyncStorage(room)),\n        // Any time storage updates, send the new storage root\n        room.events.storage.subscribe(()=>partialSyncStorage(room)),\n        // Any time \"me\" or \"others\" updates, send the new values accordingly\n        room.events.self.subscribe(()=>partialSyncMe(room)),\n        room.events.others.subscribe(()=>partialSyncOthers(room)),\n        // Any time ydoc is updated, forward the update\n        room.events.ydoc.subscribe((update)=>syncYdocUpdate(room, update)),\n        // Any time a custom room event is received, forward it\n        room.events.customEvent.subscribe((eventData)=>forwardEvent(room, eventData))\n    ]);\n}\nfunction syncYdocUpdate(room, update) {\n    sendToPanel({\n        msg: \"room::sync::ydoc\",\n        roomId: room.id,\n        update\n    });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n    return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n    sendToPanel({\n        msg: \"room::events::custom-event\",\n        roomId: room.id,\n        event: {\n            type: \"CustomEvent\",\n            id: nextEventId(),\n            key: \"Event\",\n            connectionId: eventData.connectionId,\n            payload: eventData.event\n        }\n    });\n}\nfunction partialSyncConnection(room) {\n    sendToPanel({\n        msg: \"room::sync::partial\",\n        roomId: room.id,\n        status: room.getStatus()\n    });\n}\nfunction partialSyncStorage(room) {\n    const root = room.getStorageSnapshot();\n    if (root) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            storage: root.toTreeNode(\"root\").payload\n        });\n    }\n}\nfunction partialSyncMe(room) {\n    const me = room.__internal.getSelf_forDevTools();\n    if (me) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            me\n        });\n    }\n}\nfunction partialSyncOthers(room) {\n    const others = room.__internal.getOthers_forDevTools();\n    if (others) {\n        sendToPanel({\n            msg: \"room::sync::partial\",\n            roomId: room.id,\n            others\n        });\n    }\n}\nfunction fullSync(room) {\n    const root = room.getStorageSnapshot();\n    const me = room.__internal.getSelf_forDevTools();\n    const others = room.__internal.getOthers_forDevTools();\n    room.fetchYDoc(\"\");\n    sendToPanel({\n        msg: \"room::sync::full\",\n        roomId: room.id,\n        status: room.getStatus(),\n        storage: root?.toTreeNode(\"root\").payload ?? null,\n        me,\n        others\n    });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n    const listener = roomChannelListeners.get(roomId);\n    roomChannelListeners.delete(roomId);\n    if (listener) {\n        listener();\n    }\n}\nfunction linkDevTools(roomId, room) {\n    if (true) {\n        return;\n    }\n    sendToPanel({\n        msg: \"room::available\",\n        roomId,\n        clientVersion: VERSION\n    });\n    stopRoomChannelListener(roomId);\n    roomChannelListeners.set(roomId, // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg)=>{\n        switch(msg.msg){\n            case \"room::subscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        startSyncStream(room);\n                    }\n                    break;\n                }\n            case \"room::unsubscribe\":\n                {\n                    if (msg.roomId === roomId) {\n                        stopSyncStream(roomId);\n                    }\n                    break;\n                }\n        }\n    }));\n}\nfunction unlinkDevTools(roomId) {\n    if (true) {\n        return;\n    }\n    stopSyncStream(roomId);\n    stopRoomChannelListener(roomId);\n    sendToPanel({\n        msg: \"room::unavailable\",\n        roomId\n    });\n}\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n    if (true) {\n        if (!_emittedDeprecationWarnings.has(key)) {\n            _emittedDeprecationWarnings.add(key);\n            errorWithTitle(\"Deprecation warning\", message);\n        }\n    }\n}\nfunction deprecateIf(condition, message, key = message) {\n    if (true) {\n        if (condition) {\n            deprecate(message, key);\n        }\n    }\n}\nfunction throwUsageError(message) {\n    if (true) {\n        const usageError = new Error(message);\n        usageError.name = \"Usage error\";\n        errorWithTitle(\"Usage error\", message);\n        throw usageError;\n    }\n}\nfunction errorIf(condition, message) {\n    if (true) {\n        if (condition) {\n            throwUsageError(message);\n        }\n    }\n}\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n    return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n    return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n    return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n    paragraph: isCommentBodyParagraph,\n    text: isCommentBodyText,\n    link: isCommentBodyLink,\n    mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n    paragraph: \"block\",\n    text: \"inline\",\n    link: \"inline\",\n    mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n    if (!body || !body?.content) {\n        return;\n    }\n    const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n    const type = element ? commentBodyElementsTypes[element] : \"all\";\n    const guard = element ? commentBodyElementsGuards[element] : ()=>true;\n    const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n    for (const block of body.content){\n        if (type === \"all\" || type === \"block\") {\n            if (guard(block)) {\n                visitor?.(block);\n            }\n        }\n        if (type === \"all\" || type === \"inline\") {\n            for (const inline of block.children){\n                if (guard(inline)) {\n                    visitor?.(inline);\n                }\n            }\n        }\n    }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n    const mentionedIds = /* @__PURE__ */ new Set();\n    traverseCommentBody(body, \"mention\", (mention)=>mentionedIds.add(mention.id));\n    return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n    const resolvedUsers = /* @__PURE__ */ new Map();\n    if (!resolveUsers) {\n        return resolvedUsers;\n    }\n    const userIds = getMentionedIdsFromCommentBody(body);\n    const users = await resolveUsers({\n        userIds\n    });\n    for (const [index, userId] of userIds.entries()){\n        const user = users?.[index];\n        if (user) {\n            resolvedUsers.set(userId, user);\n        }\n    }\n    return resolvedUsers;\n}\nvar htmlEscapables = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(Object.keys(htmlEscapables).map((entity)=>`\\\\${entity}`).join(\"|\"), \"g\");\nfunction htmlSafe(value) {\n    return new HtmlSafeString([\n        String(value)\n    ], []);\n}\nfunction joinHtml(strings) {\n    if (strings.length <= 0) {\n        return new HtmlSafeString([\n            \"\"\n        ], []);\n    }\n    return new HtmlSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeHtml(value) {\n    if (value instanceof HtmlSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinHtml(value).toString();\n    }\n    return String(value).replace(htmlEscapablesRegex, (character)=>htmlEscapables[character]);\n}\nvar HtmlSafeString = class {\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeHtml(nn(this._values[i - 1])) + str;\n        });\n    }\n};\nfunction html(strings, ...values) {\n    return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n    _: \"\\\\_\",\n    \"*\": \"\\\\*\",\n    \"#\": \"\\\\#\",\n    \"`\": \"\\\\`\",\n    \"~\": \"\\\\~\",\n    \"!\": \"\\\\!\",\n    \"|\": \"\\\\|\",\n    \"(\": \"\\\\(\",\n    \")\": \"\\\\)\",\n    \"{\": \"\\\\{\",\n    \"}\": \"\\\\}\",\n    \"[\": \"\\\\[\",\n    \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(Object.keys(markdownEscapables).map((entity)=>`\\\\${entity}`).join(\"|\"), \"g\");\nfunction joinMarkdown(strings) {\n    if (strings.length <= 0) {\n        return new MarkdownSafeString([\n            \"\"\n        ], []);\n    }\n    return new MarkdownSafeString([\n        \"\",\n        ...Array(strings.length - 1).fill(\"\"),\n        \"\"\n    ], strings);\n}\nfunction escapeMarkdown(value) {\n    if (value instanceof MarkdownSafeString) {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return joinMarkdown(value).toString();\n    }\n    return String(value).replace(markdownEscapablesRegex, (character)=>markdownEscapables[character]);\n}\nvar MarkdownSafeString = class {\n    constructor(strings, values){\n        this._strings = strings;\n        this._values = values;\n    }\n    toString() {\n        return this._strings.reduce((result, str, i)=>{\n            return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n        });\n    }\n};\nfunction markdown(strings, ...values) {\n    return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n        return url;\n    } else if (url.startsWith(\"www.\")) {\n        return \"https://\" + url;\n    }\n    return;\n}\nvar stringifyCommentBodyPlainElements = {\n    paragraph: ({ children })=>children,\n    text: ({ element })=>element.text,\n    link: ({ element })=>element.url,\n    mention: ({ element, user })=>{\n        return `@${user?.name ?? element.id}`;\n    }\n};\nvar stringifyCommentBodyHtmlElements = {\n    paragraph: ({ children })=>{\n        return children ? html`<p>${htmlSafe(children)}</p>` : children;\n    },\n    text: ({ element })=>{\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = html`<strong>${children}</strong>`;\n        }\n        if (element.italic) {\n            children = html`<em>${children}</em>`;\n        }\n        if (element.strikethrough) {\n            children = html`<s>${children}</s>`;\n        }\n        if (element.code) {\n            children = html`<code>${children}</code>`;\n        }\n        return children;\n    },\n    link: ({ element, href })=>{\n        return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n    },\n    mention: ({ element, user })=>{\n        return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n    }\n};\nvar stringifyCommentBodyMarkdownElements = {\n    paragraph: ({ children })=>{\n        return children;\n    },\n    text: ({ element })=>{\n        let children = element.text;\n        if (!children) {\n            return children;\n        }\n        if (element.bold) {\n            children = markdown`**${children}**`;\n        }\n        if (element.italic) {\n            children = markdown`_${children}_`;\n        }\n        if (element.strikethrough) {\n            children = markdown`~~${children}~~`;\n        }\n        if (element.code) {\n            children = markdown`\\`${children}\\``;\n        }\n        return children;\n    },\n    link: ({ element, href })=>{\n        return markdown`[${element.url}](${href})`;\n    },\n    mention: ({ element, user })=>{\n        return markdown`@${user?.name ?? element.id}`;\n    }\n};\nasync function stringifyCommentBody(body, options) {\n    const format = options?.format ?? \"plain\";\n    const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n    const elements = {\n        ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n        ...options?.elements\n    };\n    const resolvedUsers = await resolveUsersInCommentBody(body, options?.resolveUsers);\n    const blocks = body.content.flatMap((block, blockIndex)=>{\n        switch(block.type){\n            case \"paragraph\":\n                {\n                    const inlines = block.children.flatMap((inline, inlineIndex)=>{\n                        if (isCommentBodyMention(inline)) {\n                            return inline.id ? [\n                                elements.mention({\n                                    element: inline,\n                                    user: resolvedUsers.get(inline.id)\n                                }, inlineIndex)\n                            ] : [];\n                        }\n                        if (isCommentBodyLink(inline)) {\n                            return [\n                                elements.link({\n                                    element: inline,\n                                    href: toAbsoluteUrl(inline.url) ?? inline.url\n                                }, inlineIndex)\n                            ];\n                        }\n                        if (isCommentBodyText(inline)) {\n                            return [\n                                elements.text({\n                                    element: inline\n                                }, inlineIndex)\n                            ];\n                        }\n                        return [];\n                    });\n                    return [\n                        elements.paragraph({\n                            element: block,\n                            children: inlines.join(\"\")\n                        }, blockIndex)\n                    ];\n                }\n            default:\n                return [];\n        }\n    });\n    return blocks.join(separator);\n}\nfunction convertToCommentData(data) {\n    const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const reactions = data.reactions.map((reaction)=>({\n            ...reaction,\n            createdAt: new Date(reaction.createdAt)\n        }));\n    if (data.body) {\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt\n        };\n    } else {\n        const deletedAt = new Date(data.deletedAt);\n        return {\n            ...data,\n            reactions,\n            createdAt,\n            editedAt,\n            deletedAt\n        };\n    }\n}\nfunction convertToThreadData(data) {\n    const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    const comments = data.comments.map((comment)=>convertToCommentData(comment));\n    return {\n        ...data,\n        createdAt,\n        updatedAt,\n        comments\n    };\n}\nfunction convertToCommentUserReaction(data) {\n    return {\n        ...data,\n        createdAt: new Date(data.createdAt)\n    };\n}\n// src/comments/index.ts\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n    if (authValue.type === \"public\") {\n        return authValue.publicApiKey;\n    } else {\n        return authValue.token.raw;\n    }\n}\nvar CommentsApiError = class extends Error {\n    constructor(message, status, details){\n        super(message);\n        this.message = message;\n        this.status = status;\n        this.details = details;\n    }\n};\nfunction createCommentsApi(roomId, getAuthValue, config) {\n    async function fetchJson(endpoint, options) {\n        const response = await fetchApi(roomId, endpoint, options);\n        if (!response.ok) {\n            if (response.status >= 400 && response.status < 600) {\n                let error3;\n                try {\n                    const errorBody = await response.json();\n                    error3 = new CommentsApiError(errorBody.message, response.status, errorBody);\n                } catch  {\n                    error3 = new CommentsApiError(response.statusText, response.status);\n                }\n                throw error3;\n            }\n        }\n        let body;\n        try {\n            body = await response.json();\n        } catch  {\n            body = {};\n        }\n        return body;\n    }\n    async function fetchApi(roomId2, endpoint, options) {\n        const authValue = await getAuthValue();\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(roomId2)}${endpoint}`, config.baseUrl);\n        return await fetch(url.toString(), {\n            ...options,\n            headers: {\n                ...options?.headers,\n                Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n            }\n        });\n    }\n    async function getThreads(options) {\n        const response = await fetchApi(roomId, \"/threads/search\", {\n            body: JSON.stringify({\n                ...options?.query?.metadata && {\n                    metadata: options.query.metadata\n                }\n            }),\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\"\n        });\n        if (response.ok) {\n            const json = await response.json();\n            return json.data.map((thread)=>convertToThreadData(thread));\n        } else if (response.status === 404) {\n            return [];\n        } else {\n            throw new Error(\"There was an error while getting threads.\");\n        }\n    }\n    async function createThread({ metadata, body, commentId, threadId }) {\n        const thread = await fetchJson(\"/threads\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: threadId,\n                comment: {\n                    id: commentId,\n                    body\n                },\n                metadata\n            })\n        });\n        return convertToThreadData(thread);\n    }\n    async function editThreadMetadata({ metadata, threadId }) {\n        return await fetchJson(`/threads/${encodeURIComponent(threadId)}/metadata`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(metadata)\n        });\n    }\n    async function createComment({ threadId, commentId, body }) {\n        const comment = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                id: commentId,\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function editComment({ threadId, commentId, body }) {\n        const comment = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                body\n            })\n        });\n        return convertToCommentData(comment);\n    }\n    async function deleteComment({ threadId, commentId }) {\n        await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}`, {\n            method: \"DELETE\"\n        });\n    }\n    async function addReaction({ threadId, commentId, emoji }) {\n        const reaction = await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}/reactions`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                emoji\n            })\n        });\n        return convertToCommentUserReaction(reaction);\n    }\n    async function removeReaction({ threadId, commentId, emoji }) {\n        await fetchJson(`/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(commentId)}/reactions/${encodeURIComponent(emoji)}`, {\n            method: \"DELETE\"\n        });\n    }\n    return {\n        getThreads,\n        createThread,\n        editThreadMetadata,\n        createComment,\n        editComment,\n        deleteComment,\n        addReaction,\n        removeReaction\n    };\n}\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n    const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n    if (code < MIN_CODE || code > MAX_CODE) {\n        throw new Error(`Invalid n value: ${n}`);\n    }\n    return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n    if (x !== void 0 && y !== void 0) {\n        return between(x, y);\n    } else if (x !== void 0) {\n        return after(x);\n    } else if (y !== void 0) {\n        return before(y);\n    } else {\n        return ONE;\n    }\n}\nfunction before(pos) {\n    const lastIndex = pos.length - 1;\n    for(let i = 0; i <= lastIndex; i++){\n        const code = pos.charCodeAt(i);\n        if (code <= MIN_CODE) {\n            continue;\n        }\n        if (i === lastIndex) {\n            if (code === MIN_CODE + 1) {\n                return pos.substring(0, i) + ZERO_NINE;\n            } else {\n                return pos.substring(0, i) + String.fromCharCode(code - 1);\n            }\n        } else {\n            return pos.substring(0, i + 1);\n        }\n    }\n    return ONE;\n}\nfunction after(pos) {\n    for(let i = 0; i <= pos.length - 1; i++){\n        const code = pos.charCodeAt(i);\n        if (code >= MAX_CODE) {\n            continue;\n        }\n        return pos.substring(0, i) + String.fromCharCode(code + 1);\n    }\n    return pos + ONE;\n}\nfunction between(lo, hi) {\n    if (lo < hi) {\n        return _between(lo, hi);\n    } else if (lo > hi) {\n        return _between(hi, lo);\n    } else {\n        throw new Error(\"Cannot compute value between two equal positions\");\n    }\n}\nfunction _between(lo, hi) {\n    let index = 0;\n    const loLen = lo.length;\n    const hiLen = hi.length;\n    while(true){\n        const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n        const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n        if (loCode === hiCode) {\n            index++;\n            continue;\n        }\n        if (hiCode - loCode === 1) {\n            const size = index + 1;\n            let prefix = lo.substring(0, size);\n            if (prefix.length < size) {\n                prefix += ZERO.repeat(size - prefix.length);\n            }\n            const suffix = lo.substring(size);\n            const nines = \"\";\n            return prefix + _between(suffix, nines);\n        } else {\n            return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n        }\n    }\n}\nfunction takeN(pos, n) {\n    return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n    if (str === \"\") {\n        return false;\n    }\n    const lastIdx = str.length - 1;\n    const last = str.charCodeAt(lastIdx);\n    if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n        return false;\n    }\n    for(let i = 0; i < lastIdx; i++){\n        const code = str.charCodeAt(i);\n        if (code < MIN_CODE || code > MAX_CODE) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction convertToPos(str) {\n    const codes = [];\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n    }\n    while(codes.length > 0 && codes[codes.length - 1] === MIN_CODE){\n        codes.length--;\n    }\n    return codes.length > 0 ? String.fromCharCode(...codes) : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE;\n}\nfunction asPos(str) {\n    return isPos(str) ? str : convertToPos(str);\n}\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2)=>{\n    OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n    OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n    OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n    OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n    OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n    OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n    OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n    OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n    OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n    return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n    return {\n        type: 5 /* DELETE_CRDT */ ,\n        id: \"ACK\",\n        // (H)ACK\n        opId\n    };\n}\nfunction isAckOp(op) {\n    return op.type === 5 /* DELETE_CRDT */  && op.id === \"ACK\";\n}\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n    return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n    return Object.freeze({\n        type: \"HasParent\",\n        node,\n        key,\n        pos\n    });\n}\nvar NoParent = Object.freeze({\n    type: \"NoParent\"\n});\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n    return Object.freeze({\n        type: \"Orphaned\",\n        oldKey,\n        oldPos\n    });\n}\nvar AbstractCrdt = class {\n    constructor(){\n        /** @internal */ this._parent = NoParent;\n    }\n    /** @internal */ _getParentKeyOrThrow() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _parentPos() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.pos;\n            case \"NoParent\":\n                throw new Error(\"Parent key is missing\");\n            case \"Orphaned\":\n                return this.parent.oldPos;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ get _pool() {\n        return this.__pool;\n    }\n    get roomId() {\n        return this.__pool ? this.__pool.roomId : null;\n    }\n    /** @internal */ get _id() {\n        return this.__id;\n    }\n    /** @internal */ get parent() {\n        return this._parent;\n    }\n    /** @internal */ get _parentKey() {\n        switch(this.parent.type){\n            case \"HasParent\":\n                return this.parent.key;\n            case \"NoParent\":\n                return null;\n            case \"Orphaned\":\n                return this.parent.oldKey;\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _apply(op, _isLocal) {\n        switch(op.type){\n            case 5 /* DELETE_CRDT */ :\n                {\n                    if (this.parent.type === \"HasParent\") {\n                        return this.parent.node._detachChild(crdtAsLiveNode(this));\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _setParentLink(newParentNode, newParentKey) {\n        switch(this.parent.type){\n            case \"HasParent\":\n                if (this.parent.node !== newParentNode) {\n                    throw new Error(\"Cannot set parent: node already has a parent\");\n                } else {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            case \"Orphaned\":\n            case \"NoParent\":\n                {\n                    this._parent = HasParent(newParentNode, newParentKey);\n                    return;\n                }\n            default:\n                return assertNever(this.parent, \"Unknown state\");\n        }\n    }\n    /** @internal */ _attach(id, pool) {\n        if (this.__id || this.__pool) {\n            throw new Error(\"Cannot attach node: already attached\");\n        }\n        pool.addNode(id, crdtAsLiveNode(this));\n        this.__id = id;\n        this.__pool = pool;\n    }\n    /** @internal */ _detach() {\n        if (this.__pool && this.__id) {\n            this.__pool.deleteNode(this.__id);\n        }\n        switch(this.parent.type){\n            case \"HasParent\":\n                {\n                    this._parent = Orphaned(this.parent.key, this.parent.pos);\n                    break;\n                }\n            case \"NoParent\":\n                {\n                    this._parent = NoParent;\n                    break;\n                }\n            case \"Orphaned\":\n                {\n                    break;\n                }\n            default:\n                assertNever(this.parent, \"Unknown state\");\n        }\n        this.__pool = void 0;\n    }\n    /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */ invalidate() {\n        if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n            this._cachedImmutable = void 0;\n            this._cachedTreeNode = void 0;\n            if (this.parent.type === \"HasParent\") {\n                this.parent.node.invalidate();\n            }\n        }\n    }\n    /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */ toTreeNode(key) {\n        if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n            this._cachedTreeNodeKey = key;\n            this._cachedTreeNode = this._toTreeNode(key);\n        }\n        return this._cachedTreeNode;\n    }\n    /**\n   * Return an immutable snapshot of this Live node and its children.\n   */ toImmutable() {\n        if (this._cachedImmutable === void 0) {\n            this._cachedImmutable = this._toImmutable();\n        }\n        return this._cachedImmutable;\n    }\n};\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2)=>{\n    CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n    CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n    CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n    CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n    return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n    return crdt.type === 0 /* OBJECT */  && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n    return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n    const len = alphabet.length;\n    return Array.from({\n        length\n    }, ()=>alphabet.charAt(Math.floor(Math.random() * len))).join(\"\");\n}\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n    constructor(data){\n        super();\n        this._data = data;\n    }\n    get data() {\n        return this._data;\n    }\n    /** @internal */ static _deserialize([id, item], _parentToChildren, pool) {\n        const register = new _LiveRegister(item.data);\n        register._attach(id, pool);\n        return register;\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize register if parentId or parentKey is undefined\");\n        }\n        return [\n            {\n                type: 8 /* CREATE_REGISTER */ ,\n                opId: pool?.generateOpId(),\n                id: this._id,\n                parentId,\n                parentKey,\n                data: this.data\n            }\n        ];\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n        }\n        return {\n            type: 3 /* REGISTER */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key,\n            data: this.data\n        };\n    }\n    /** @internal */ _attachChild(_op) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _detachChild(_crdt) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"Json\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: this._data\n        };\n    }\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    clone() {\n        return deepClone(this.data);\n    }\n};\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n    const posA = itemA._parentPos;\n    const posB = itemB._parentPos;\n    return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n    constructor(items = []){\n        super();\n        this._items = [];\n        this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n        this._unacknowledgedSets = /* @__PURE__ */ new Map();\n        let position = void 0;\n        for (const item of items){\n            const newPosition = makePosition(position);\n            const node = lsonToLiveNode(item);\n            node._setParentLink(this, newPosition);\n            this._items.push(node);\n            position = newPosition;\n        }\n    }\n    /** @internal */ static _deserialize([id], parentToChildren, pool) {\n        const list = new _LiveList();\n        list._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return list;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(list, crdt.parentKey);\n            list._insertAndSort(child);\n        }\n        return list;\n    }\n    /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool?.generateOpId(),\n            type: 2 /* CREATE_LIST */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const item of this._items){\n            const parentKey2 = item._getParentKeyOrThrow();\n            const childOps = HACK_addIntentAndDeletedIdToOperation(item._toOps(this._id, parentKey2, pool), void 0);\n            const childOpId = childOps[0].opId;\n            if (childOpId !== void 0) {\n                this._unacknowledgedSets.set(parentKey2, childOpId);\n            }\n            ops.push(...childOps);\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */ _insertAndSort(item) {\n        this._items.push(item);\n        this._sortItems();\n    }\n    /** @internal */ _sortItems() {\n        this._items.sort(compareNodePosition);\n        this.invalidate();\n    }\n    /** @internal */ _indexOfPosition(position) {\n        return this._items.findIndex((item)=>item._getParentKeyOrThrow() === position);\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const item of this._items){\n            item._attach(pool.generateId(), pool);\n        }\n    }\n    /** @internal */ _detach() {\n        super._detach();\n        for (const item of this._items){\n            item._detach();\n        }\n    }\n    /** @internal */ _applySetRemote(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        child._attach(id, this._pool);\n        child._setParentLink(this, key);\n        const deletedId = op.deletedId;\n        const indexOfItemWithSamePosition = this._indexOfPosition(key);\n        if (indexOfItemWithSamePosition !== -1) {\n            const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n            if (itemWithSamePosition._id === deletedId) {\n                itemWithSamePosition._detach();\n                this._items[indexOfItemWithSamePosition] = child;\n                return {\n                    modified: makeUpdate(this, [\n                        setDelta(indexOfItemWithSamePosition, child)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                this._implicitlyDeletedItems.add(itemWithSamePosition);\n                this._items[indexOfItemWithSamePosition] = child;\n                const delta = [\n                    setDelta(indexOfItemWithSamePosition, child)\n                ];\n                const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n                if (deleteDelta2) {\n                    delta.push(deleteDelta2);\n                }\n                return {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            }\n        } else {\n            const updates = [];\n            const deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deleteDelta2) {\n                updates.push(deleteDelta2);\n            }\n            this._insertAndSort(child);\n            updates.push(insertDelta(this._indexOfPosition(key), child));\n            return {\n                reverse: [],\n                modified: makeUpdate(this, updates)\n            };\n        }\n    }\n    /** @internal */ _applySetAck(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const delta = [];\n        const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n        if (deletedDelta) {\n            delta.push(deletedDelta);\n        }\n        const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n        if (unacknowledgedOpId !== void 0) {\n            if (unacknowledgedOpId !== op.opId) {\n                return delta.length === 0 ? {\n                    modified: false\n                } : {\n                    modified: makeUpdate(this, delta),\n                    reverse: []\n                };\n            } else {\n                this._unacknowledgedSets.delete(op.parentKey);\n            }\n        }\n        const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        if (existingItem !== void 0) {\n            if (existingItem._parentKey === op.parentKey) {\n                return {\n                    modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                    reverse: []\n                };\n            }\n            if (indexOfItemWithSamePosition !== -1) {\n                this._implicitlyDeletedItems.add(this._items[indexOfItemWithSamePosition]);\n                this._items.splice(indexOfItemWithSamePosition, 1);\n                delta.push(deleteDelta(indexOfItemWithSamePosition));\n            }\n            const previousIndex = this._items.indexOf(existingItem);\n            existingItem._setParentLink(this, op.parentKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(existingItem);\n            if (newIndex !== previousIndex) {\n                delta.push(moveDelta(previousIndex, newIndex, existingItem));\n            }\n            return {\n                modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n                reverse: []\n            };\n        } else {\n            const orphan = this._pool.getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, op.parentKey);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const recreatedItemIndex = this._items.indexOf(orphan);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (indexOfItemWithSamePosition !== -1) {\n                    this._items.splice(indexOfItemWithSamePosition, 1);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, op.parentKey);\n                return {\n                    modified: makeUpdate(this, [\n                        // If there is an item at this position, update is a set, else it's an insert\n                        indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n                        ...delta\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */ _detachItemAssociatedToSetOperation(deletedId) {\n        if (deletedId === void 0 || this._pool === void 0) {\n            return null;\n        }\n        const deletedItem = this._pool.getNode(deletedId);\n        if (deletedItem === void 0) {\n            return null;\n        }\n        const result = this._detachChild(deletedItem);\n        if (result.modified === false) {\n            return null;\n        }\n        return result.modified.updates[0];\n    }\n    /** @internal */ _applyRemoteInsert(op) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const key = asPos(op.parentKey);\n        const existingItemIndex = this._indexOfPosition(key);\n        if (existingItemIndex !== -1) {\n            this._shiftItemPosition(existingItemIndex, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, newItem)\n            ]),\n            reverse: []\n        };\n    }\n    /** @internal */ _applyInsertAck(op) {\n        const existingItem = this._items.find((item)=>item._id === op.id);\n        const key = asPos(op.parentKey);\n        const itemIndexAtPosition = this._indexOfPosition(key);\n        if (existingItem) {\n            if (existingItem._parentKey === key) {\n                return {\n                    modified: false\n                };\n            } else {\n                const oldPositionIndex = this._items.indexOf(existingItem);\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                existingItem._setParentLink(this, key);\n                this._sortItems();\n                const newIndex = this._indexOfPosition(key);\n                if (newIndex === oldPositionIndex) {\n                    return {\n                        modified: false\n                    };\n                }\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(oldPositionIndex, newIndex, existingItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        } else {\n            const orphan = nn(this._pool).getNode(op.id);\n            if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n                orphan._setParentLink(this, key);\n                this._implicitlyDeletedItems.delete(orphan);\n                this._insertAndSort(orphan);\n                const newIndex = this._indexOfPosition(key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, orphan)\n                    ]),\n                    reverse: []\n                };\n            } else {\n                if (itemIndexAtPosition !== -1) {\n                    this._shiftItemPosition(itemIndexAtPosition, key);\n                }\n                const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n                return {\n                    modified: makeUpdate(this, [\n                        insertDelta(newIndex, newItem)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applyInsertUndoRedo(op) {\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (this._pool?.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const existingItemIndex = this._indexOfPosition(key);\n        let newKey = key;\n        if (existingItemIndex !== -1) {\n            const before2 = this._items[existingItemIndex]?._parentPos;\n            const after2 = this._items[existingItemIndex + 1]?._parentPos;\n            newKey = makePosition(before2, after2);\n            child._setParentLink(this, newKey);\n        }\n        this._insertAndSort(child);\n        const newIndex = this._indexOfPosition(newKey);\n        return {\n            modified: makeUpdate(this, [\n                insertDelta(newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ]\n        };\n    }\n    /** @internal */ _applySetUndoRedo(op) {\n        const { id, parentKey: key } = op;\n        const child = creationOpToLiveNode(op);\n        if (this._pool?.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        this._unacknowledgedSets.set(key, nn(op.opId));\n        const indexOfItemWithSameKey = this._indexOfPosition(key);\n        child._attach(id, nn(this._pool));\n        child._setParentLink(this, key);\n        const newKey = key;\n        if (indexOfItemWithSameKey !== -1) {\n            const existingItem = this._items[indexOfItemWithSameKey];\n            existingItem._detach();\n            this._items[indexOfItemWithSameKey] = child;\n            const reverse = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(nn(this._id), key, this._pool), op.id);\n            const delta = [\n                setDelta(indexOfItemWithSameKey, child)\n            ];\n            const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n            if (deletedDelta) {\n                delta.push(deletedDelta);\n            }\n            return {\n                modified: makeUpdate(this, delta),\n                reverse\n            };\n        } else {\n            this._insertAndSort(child);\n            this._detachItemAssociatedToSetOperation(op.deletedId);\n            const newIndex = this._indexOfPosition(newKey);\n            return {\n                reverse: [\n                    {\n                        type: 5 /* DELETE_CRDT */ ,\n                        id\n                    }\n                ],\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ])\n            };\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        let result;\n        if (op.intent === \"set\") {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applySetRemote(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applySetAck(op);\n            } else {\n                result = this._applySetUndoRedo(op);\n            }\n        } else {\n            if (source === 1 /* REMOTE */ ) {\n                result = this._applyRemoteInsert(op);\n            } else if (source === 2 /* ACK */ ) {\n                result = this._applyInsertAck(op);\n            } else {\n                result = this._applyInsertUndoRedo(op);\n            }\n        }\n        if (result.modified !== false) {\n            this.invalidate();\n        }\n        return result;\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n            const indexToDelete = this._items.indexOf(child);\n            if (indexToDelete === -1) {\n                return {\n                    modified: false\n                };\n            }\n            this._items.splice(indexToDelete, 1);\n            this.invalidate();\n            child._detach();\n            return {\n                modified: makeUpdate(this, [\n                    deleteDelta(indexToDelete)\n                ]),\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /** @internal */ _applySetChildKeyRemote(newKey, child) {\n        if (this._implicitlyDeletedItems.has(child)) {\n            this._implicitlyDeletedItems.delete(child);\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            const newIndex = this._items.indexOf(child);\n            return {\n                modified: makeUpdate(this, [\n                    insertDelta(newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n        const previousKey = child._parentKey;\n        if (newKey === previousKey) {\n            return {\n                modified: false\n            };\n        }\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex === -1) {\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        } else {\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            const previousIndex = this._items.indexOf(child);\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (newIndex === previousIndex) {\n                return {\n                    modified: false\n                };\n            }\n            return {\n                modified: makeUpdate(this, [\n                    moveDelta(previousIndex, newIndex, child)\n                ]),\n                reverse: []\n            };\n        }\n    }\n    /** @internal */ _applySetChildKeyAck(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        if (this._implicitlyDeletedItems.has(child)) {\n            const existingItemIndex = this._indexOfPosition(newKey);\n            this._implicitlyDeletedItems.delete(child);\n            if (existingItemIndex !== -1) {\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._insertAndSort(child);\n            return {\n                modified: false\n            };\n        } else {\n            if (newKey === previousKey) {\n                return {\n                    modified: false\n                };\n            }\n            const previousIndex = this._items.indexOf(child);\n            const existingItemIndex = this._indexOfPosition(newKey);\n            if (existingItemIndex !== -1) {\n                this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n            }\n            child._setParentLink(this, newKey);\n            this._sortItems();\n            const newIndex = this._items.indexOf(child);\n            if (previousIndex === newIndex) {\n                return {\n                    modified: false\n                };\n            } else {\n                return {\n                    modified: makeUpdate(this, [\n                        moveDelta(previousIndex, newIndex, child)\n                    ]),\n                    reverse: []\n                };\n            }\n        }\n    }\n    /** @internal */ _applySetChildKeyUndoRedo(newKey, child) {\n        const previousKey = nn(child._parentKey);\n        const previousIndex = this._items.indexOf(child);\n        const existingItemIndex = this._indexOfPosition(newKey);\n        if (existingItemIndex !== -1) {\n            this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos));\n        }\n        child._setParentLink(this, newKey);\n        this._sortItems();\n        const newIndex = this._items.indexOf(child);\n        if (previousIndex === newIndex) {\n            return {\n                modified: false\n            };\n        }\n        return {\n            modified: makeUpdate(this, [\n                moveDelta(previousIndex, newIndex, child)\n            ]),\n            reverse: [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(child._id),\n                    parentKey: previousKey\n                }\n            ]\n        };\n    }\n    /** @internal */ _setChildKey(newKey, child, source) {\n        if (source === 1 /* REMOTE */ ) {\n            return this._applySetChildKeyRemote(newKey, child);\n        } else if (source === 2 /* ACK */ ) {\n            return this._applySetChildKeyAck(newKey, child);\n        } else {\n            return this._applySetChildKeyUndoRedo(newKey, child);\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        return super._apply(op, isLocal);\n    }\n    /** @internal */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveList if parent is missing\");\n        }\n        return {\n            type: 1 /* LIST */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns the number of elements.\n   */ get length() {\n        return this._items.length;\n    }\n    /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */ push(element) {\n        this._pool?.assertStorageIsWritable();\n        return this.insert(element, this.length);\n    }\n    /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */ insert(element, index) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index > this._items.length) {\n            throw new Error(`Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`);\n        }\n        const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n        const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n        const position = makePosition(before2, after2);\n        const value = lsonToLiveNode(element);\n        value._setParentLink(this, position);\n        this._insertAndSort(value);\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            this._pool.dispatch(value._toOps(this._id, position, this._pool), [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        insertDelta(index, value)\n                    ])\n                ]\n            ]));\n        }\n    }\n    /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */ move(index, targetIndex) {\n        this._pool?.assertStorageIsWritable();\n        if (targetIndex < 0) {\n            throw new Error(\"targetIndex cannot be less than 0\");\n        }\n        if (targetIndex >= this._items.length) {\n            throw new Error(\"targetIndex cannot be greater or equal than the list length\");\n        }\n        if (index < 0) {\n            throw new Error(\"index cannot be less than 0\");\n        }\n        if (index >= this._items.length) {\n            throw new Error(\"index cannot be greater or equal than the list length\");\n        }\n        let beforePosition = null;\n        let afterPosition = null;\n        if (index < targetIndex) {\n            afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n            beforePosition = this._items[targetIndex]._parentPos;\n        } else {\n            afterPosition = this._items[targetIndex]._parentPos;\n            beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n        }\n        const position = makePosition(beforePosition, afterPosition);\n        const item = this._items[index];\n        const previousPosition = item._getParentKeyOrThrow();\n        item._setParentLink(this, position);\n        this._sortItems();\n        if (this._pool && this._id) {\n            const storageUpdates = /* @__PURE__ */ new Map([\n                [\n                    this._id,\n                    makeUpdate(this, [\n                        moveDelta(index, targetIndex, item)\n                    ])\n                ]\n            ]);\n            this._pool.dispatch([\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    opId: this._pool.generateOpId(),\n                    parentKey: position\n                }\n            ], [\n                {\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id: nn(item._id),\n                    parentKey: previousPosition\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */ delete(index) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error(`Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`);\n        }\n        const item = this._items[index];\n        item._detach();\n        this._items.splice(index, 1);\n        this.invalidate();\n        if (this._pool) {\n            const childRecordId = item._id;\n            if (childRecordId) {\n                const storageUpdates = /* @__PURE__ */ new Map();\n                storageUpdates.set(nn(this._id), makeUpdate(this, [\n                    deleteDelta(index)\n                ]));\n                this._pool.dispatch([\n                    {\n                        id: childRecordId,\n                        opId: this._pool.generateOpId(),\n                        type: 5 /* DELETE_CRDT */ \n                    }\n                ], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);\n            }\n        }\n    }\n    clear() {\n        this._pool?.assertStorageIsWritable();\n        if (this._pool) {\n            const ops = [];\n            const reverseOps = [];\n            const updateDelta = [];\n            for (const item of this._items){\n                item._detach();\n                const childId = item._id;\n                if (childId) {\n                    ops.push({\n                        type: 5 /* DELETE_CRDT */ ,\n                        id: childId,\n                        opId: this._pool.generateOpId()\n                    });\n                    reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow()));\n                    updateDelta.push(deleteDelta(0));\n                }\n            }\n            this._items = [];\n            this.invalidate();\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        } else {\n            for (const item of this._items){\n                item._detach();\n            }\n            this._items = [];\n            this.invalidate();\n        }\n    }\n    set(index, item) {\n        this._pool?.assertStorageIsWritable();\n        if (index < 0 || index >= this._items.length) {\n            throw new Error(`Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`);\n        }\n        const existingItem = this._items[index];\n        const position = existingItem._getParentKeyOrThrow();\n        const existingId = existingItem._id;\n        existingItem._detach();\n        const value = lsonToLiveNode(item);\n        value._setParentLink(this, position);\n        this._items[index] = value;\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            value._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, makeUpdate(this, [\n                setDelta(index, value)\n            ]));\n            const ops = HACK_addIntentAndDeletedIdToOperation(value._toOps(this._id, position, this._pool), existingId);\n            this._unacknowledgedSets.set(position, nn(ops[0].opId));\n            const reverseOps = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(this._id, position, void 0), id);\n            this._pool.dispatch(ops, reverseOps, storageUpdates);\n        }\n    }\n    /**\n   * Returns an Array of all the elements in the LiveList.\n   */ toArray() {\n        return this._items.map((entry)=>liveNodeToLson(entry));\n    }\n    /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */ every(predicate) {\n        return this.toArray().every(predicate);\n    }\n    /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */ filter(predicate) {\n        return this.toArray().filter(predicate);\n    }\n    /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */ find(predicate) {\n        return this.toArray().find(predicate);\n    }\n    /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */ findIndex(predicate) {\n        return this.toArray().findIndex(predicate);\n    }\n    /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */ forEach(callbackfn) {\n        return this.toArray().forEach(callbackfn);\n    }\n    /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */ get(index) {\n        if (index < 0 || index >= this._items.length) {\n            return void 0;\n        }\n        return liveNodeToLson(this._items[index]);\n    }\n    /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */ indexOf(searchElement, fromIndex) {\n        return this.toArray().indexOf(searchElement, fromIndex);\n    }\n    /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */ lastIndexOf(searchElement, fromIndex) {\n        return this.toArray().lastIndexOf(searchElement, fromIndex);\n    }\n    /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */ map(callback) {\n        return this._items.map((entry, i)=>callback(liveNodeToLson(entry), //                    ^^^^^^^^\n            //                    FIXME! This isn't safe.\n            i));\n    }\n    /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */ some(predicate) {\n        return this.toArray().some(predicate);\n    }\n    [Symbol.iterator]() {\n        return new LiveListIterator(this._items);\n    }\n    /** @internal */ _createAttachItemAndSort(op, key) {\n        const newItem = creationOpToLiveNode(op);\n        newItem._attach(op.id, nn(this._pool));\n        newItem._setParentLink(this, key);\n        this._insertAndSort(newItem);\n        const newIndex = this._indexOfPosition(key);\n        return {\n            newItem,\n            newIndex\n        };\n    }\n    /** @internal */ _shiftItemPosition(index, key) {\n        const shiftedPosition = makePosition(key, this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0);\n        this._items[index]._setParentLink(this, shiftedPosition);\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"LiveList\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: this._items.map((item, index)=>item.toTreeNode(index.toString()))\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = this._items.map((node)=>node.toImmutable());\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveList(this._items.map((item)=>item.clone()));\n    }\n};\nvar LiveListIterator = class {\n    constructor(items){\n        this._innerIterator = items[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const result = this._innerIterator.next();\n        if (result.done) {\n            return {\n                done: true,\n                value: void 0\n            };\n        }\n        const value = liveNodeToLson(result.value);\n        return {\n            value\n        };\n    }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n    return {\n        node: liveList,\n        type: \"LiveList\",\n        updates: deltaUpdates\n    };\n}\nfunction setDelta(index, item) {\n    return {\n        index,\n        type: \"set\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction deleteDelta(index) {\n    return {\n        index,\n        type: \"delete\"\n    };\n}\nfunction insertDelta(index, item) {\n    return {\n        index,\n        type: \"insert\",\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction moveDelta(previousIndex, index, item) {\n    return {\n        index,\n        type: \"move\",\n        previousIndex,\n        item: item instanceof LiveRegister ? item.data : item\n    };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n    return ops.map((op, index)=>{\n        if (index === 0) {\n            const firstOp = op;\n            return {\n                ...firstOp,\n                intent: \"set\",\n                deletedId\n            };\n        } else {\n            return op;\n        }\n    });\n}\n// src/lib/freeze.ts\nvar freeze =  false ? /* istanbul ignore next */ 0 : Object.freeze;\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n    constructor(entries2){\n        super();\n        this.unacknowledgedSet = /* @__PURE__ */ new Map();\n        if (entries2) {\n            const mappedEntries = [];\n            for (const [key, value] of entries2){\n                const node = lsonToLiveNode(value);\n                node._setParentLink(this, key);\n                mappedEntries.push([\n                    key,\n                    node\n                ]);\n            }\n            this._map = new Map(mappedEntries);\n        } else {\n            this._map = /* @__PURE__ */ new Map();\n        }\n    }\n    /**\n   * @internal\n   */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const ops = [];\n        const op = {\n            id: this._id,\n            opId: pool?.generateOpId(),\n            type: 7 /* CREATE_MAP */ ,\n            parentId,\n            parentKey\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            ops.push(...value._toOps(this._id, key, pool));\n        }\n        return ops;\n    }\n    /**\n   * @internal\n   */ static _deserialize([id, _item], parentToChildren, pool) {\n        const map = new _LiveMap();\n        map._attach(id, pool);\n        const children = parentToChildren.get(id);\n        if (children === void 0) {\n            return map;\n        }\n        for (const [id2, crdt] of children){\n            const child = deserialize([\n                id2,\n                crdt\n            ], parentToChildren, pool);\n            child._setParentLink(map, crdt.parentKey);\n            map._map.set(crdt.parentKey, child);\n            map.invalidate();\n        }\n        return map;\n    }\n    /**\n   * @internal\n   */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, parentKey, opId } = op;\n        const key = parentKey;\n        const child = creationOpToLiveNode(op);\n        if (this._pool.getNode(id) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        if (source === 2 /* ACK */ ) {\n            const lastUpdateOpId = this.unacknowledgedSet.get(key);\n            if (lastUpdateOpId === opId) {\n                this.unacknowledgedSet.delete(key);\n                return {\n                    modified: false\n                };\n            } else if (lastUpdateOpId !== void 0) {\n                return {\n                    modified: false\n                };\n            }\n        } else if (source === 1 /* REMOTE */ ) {\n            this.unacknowledgedSet.delete(key);\n        }\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (previousValue) {\n            const thisId = nn(this._id);\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else {\n            reverse = [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ];\n        }\n        child._setParentLink(this, key);\n        child._attach(id, this._pool);\n        this._map.set(key, child);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const item of this._map.values()){\n            item._detach();\n        }\n    }\n    /**\n   * @internal\n   */ _detachChild(child) {\n        const id = nn(this._id);\n        const parentKey = nn(child._parentKey);\n        const reverse = child._toOps(id, parentKey, this._pool);\n        for (const [key, value] of this._map){\n            if (value === child) {\n                this._map.delete(key);\n                this.invalidate();\n            }\n        }\n        child._detach();\n        const storageUpdate = {\n            node: this,\n            type: \"LiveMap\",\n            updates: {\n                [parentKey]: {\n                    type: \"delete\"\n                }\n            }\n        };\n        return {\n            modified: storageUpdate,\n            reverse\n        };\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        if (this.parent.type !== \"HasParent\") {\n            throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n        }\n        return {\n            type: 2 /* MAP */ ,\n            parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n            parentKey: this.parent.key\n        };\n    }\n    /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */ get(key) {\n        const value = this._map.get(key);\n        if (value === void 0) {\n            return void 0;\n        }\n        return liveNodeToLson(value);\n    }\n    /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */ set(key, value) {\n        this._pool?.assertStorageIsWritable();\n        const oldValue = this._map.get(key);\n        if (oldValue) {\n            oldValue._detach();\n        }\n        const item = lsonToLiveNode(value);\n        item._setParentLink(this, key);\n        this._map.set(key, item);\n        this.invalidate();\n        if (this._pool && this._id) {\n            const id = this._pool.generateId();\n            item._attach(id, this._pool);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(this._id, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            });\n            const ops = item._toOps(this._id, key, this._pool);\n            this.unacknowledgedSet.set(key, nn(ops[0].opId));\n            this._pool.dispatch(item._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id\n                }\n            ], storageUpdates);\n        }\n    }\n    /**\n   * Returns the number of elements in the LiveMap.\n   */ get size() {\n        return this._map.size;\n    }\n    /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */ has(key) {\n        return this._map.has(key);\n    }\n    /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */ delete(key) {\n        this._pool?.assertStorageIsWritable();\n        const item = this._map.get(key);\n        if (item === void 0) {\n            return false;\n        }\n        item._detach();\n        this._map.delete(key);\n        this.invalidate();\n        if (this._pool && item._id) {\n            const thisId = nn(this._id);\n            const storageUpdates = /* @__PURE__ */ new Map();\n            storageUpdates.set(thisId, {\n                node: this,\n                type: \"LiveMap\",\n                updates: {\n                    [key]: {\n                        type: \"delete\"\n                    }\n                }\n            });\n            this._pool.dispatch([\n                {\n                    type: 5 /* DELETE_CRDT */ ,\n                    id: item._id,\n                    opId: this._pool.generateOpId()\n                }\n            ], item._toOps(thisId, key), storageUpdates);\n        }\n        return true;\n    }\n    /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */ entries() {\n        const innerIterator = this._map.entries();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const entry = iteratorValue.value;\n                const key = entry[0];\n                const value = liveNodeToLson(iteratorValue.value[1]);\n                return {\n                    value: [\n                        key,\n                        value\n                    ]\n                };\n            }\n        };\n    }\n    /**\n   * Same function object as the initial value of the entries method.\n   */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */ keys() {\n        return this._map.keys();\n    }\n    /**\n   * Returns a new Iterator object that contains the values for each element.\n   */ values() {\n        const innerIterator = this._map.values();\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                const iteratorValue = innerIterator.next();\n                if (iteratorValue.done) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const value = liveNodeToLson(iteratorValue.value);\n                return {\n                    value\n                };\n            }\n        };\n    }\n    /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */ forEach(callback) {\n        for (const entry of this){\n            callback(entry[1], entry[0], this);\n        }\n    }\n    /** @internal */ _toTreeNode(key) {\n        return {\n            type: \"LiveMap\",\n            id: this._id ?? nanoid(),\n            key,\n            payload: Array.from(this._map.entries()).map(([key2, val])=>val.toTreeNode(key2))\n        };\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ _toImmutable() {\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, value] of this._map){\n            result.set(key, value.toImmutable());\n        }\n        return freeze(result);\n    }\n    clone() {\n        return new _LiveMap(Array.from(this._map).map(([key, node])=>[\n                key,\n                node.clone()\n            ]));\n    }\n};\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n    constructor(obj = {}){\n        super();\n        this._propToLastUpdate = /* @__PURE__ */ new Map();\n        for(const key in obj){\n            const value = obj[key];\n            if (value === void 0) {\n                continue;\n            } else if (isLiveNode(value)) {\n                value._setParentLink(this, key);\n            }\n        }\n        this._map = new Map(Object.entries(obj));\n    }\n    /** @internal */ static _buildRootAndParentToChildren(items) {\n        const parentToChildren = /* @__PURE__ */ new Map();\n        let root = null;\n        for (const [id, crdt] of items){\n            if (isRootCrdt(crdt)) {\n                root = [\n                    id,\n                    crdt\n                ];\n            } else {\n                const tuple = [\n                    id,\n                    crdt\n                ];\n                const children = parentToChildren.get(crdt.parentId);\n                if (children !== void 0) {\n                    children.push(tuple);\n                } else {\n                    parentToChildren.set(crdt.parentId, [\n                        tuple\n                    ]);\n                }\n            }\n        }\n        if (root === null) {\n            throw new Error(\"Root can't be null\");\n        }\n        return [\n            root,\n            parentToChildren\n        ];\n    }\n    /** @internal */ static _fromItems(items, pool) {\n        const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n        return _LiveObject._deserialize(root, parentToChildren, pool);\n    }\n    /** @internal */ _toOps(parentId, parentKey, pool) {\n        if (this._id === void 0) {\n            throw new Error(\"Cannot serialize item is not attached\");\n        }\n        const opId = pool?.generateOpId();\n        const ops = [];\n        const op = {\n            type: 4 /* CREATE_OBJECT */ ,\n            id: this._id,\n            opId,\n            parentId,\n            parentKey,\n            data: {}\n        };\n        ops.push(op);\n        for (const [key, value] of this._map){\n            if (isLiveNode(value)) {\n                ops.push(...value._toOps(this._id, key, pool));\n            } else {\n                op.data[key] = value;\n            }\n        }\n        return ops;\n    }\n    /** @internal */ static _deserialize([id, item], parentToChildren, pool) {\n        const liveObj = new _LiveObject(item.data);\n        liveObj._attach(id, pool);\n        return this._deserializeChildren(liveObj, parentToChildren, pool);\n    }\n    /** @internal */ static _deserializeChildren(liveObj, parentToChildren, pool) {\n        const children = parentToChildren.get(nn(liveObj._id));\n        if (children === void 0) {\n            return liveObj;\n        }\n        for (const [id, crdt] of children){\n            const child = deserializeToLson([\n                id,\n                crdt\n            ], parentToChildren, pool);\n            if (isLiveStructure(child)) {\n                child._setParentLink(liveObj, crdt.parentKey);\n            }\n            liveObj._map.set(crdt.parentKey, child);\n            liveObj.invalidate();\n        }\n        return liveObj;\n    }\n    /** @internal */ _attach(id, pool) {\n        super._attach(id, pool);\n        for (const [_key, value] of this._map){\n            if (isLiveNode(value)) {\n                value._attach(pool.generateId(), pool);\n            }\n        }\n    }\n    /** @internal */ _attachChild(op, source) {\n        if (this._pool === void 0) {\n            throw new Error(\"Can't attach child if managed pool is not present\");\n        }\n        const { id, opId, parentKey: key } = op;\n        const child = creationOpToLson(op);\n        if (this._pool.getNode(id) !== void 0) {\n            if (this._propToLastUpdate.get(key) === opId) {\n                this._propToLastUpdate.delete(key);\n            }\n            return {\n                modified: false\n            };\n        }\n        if (source === 0 /* UNDOREDO_RECONNECT */ ) {\n            this._propToLastUpdate.set(key, nn(opId));\n        } else if (this._propToLastUpdate.get(key) === void 0) {} else if (this._propToLastUpdate.get(key) === opId) {\n            this._propToLastUpdate.delete(key);\n            return {\n                modified: false\n            };\n        } else {\n            return {\n                modified: false\n            };\n        }\n        const thisId = nn(this._id);\n        const previousValue = this._map.get(key);\n        let reverse;\n        if (isLiveNode(previousValue)) {\n            reverse = previousValue._toOps(thisId, key);\n            previousValue._detach();\n        } else if (previousValue === void 0) {\n            reverse = [\n                {\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: thisId,\n                    key\n                }\n            ];\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id: thisId,\n                    data: {\n                        [key]: previousValue\n                    }\n                }\n            ];\n        }\n        this._map.set(key, child);\n        this.invalidate();\n        if (isLiveStructure(child)) {\n            child._setParentLink(this, key);\n            child._attach(id, this._pool);\n        }\n        return {\n            reverse,\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [key]: {\n                        type: \"update\"\n                    }\n                }\n            }\n        };\n    }\n    /** @internal */ _detachChild(child) {\n        if (child) {\n            const id = nn(this._id);\n            const parentKey = nn(child._parentKey);\n            const reverse = child._toOps(id, parentKey, this._pool);\n            for (const [key, value] of this._map){\n                if (value === child) {\n                    this._map.delete(key);\n                    this.invalidate();\n                }\n            }\n            child._detach();\n            const storageUpdate = {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [parentKey]: {\n                        type: \"delete\"\n                    }\n                }\n            };\n            return {\n                modified: storageUpdate,\n                reverse\n            };\n        }\n        return {\n            modified: false\n        };\n    }\n    /**\n   * @internal\n   */ _detach() {\n        super._detach();\n        for (const value of this._map.values()){\n            if (isLiveNode(value)) {\n                value._detach();\n            }\n        }\n    }\n    /** @internal */ _apply(op, isLocal) {\n        if (op.type === 3 /* UPDATE_OBJECT */ ) {\n            return this._applyUpdate(op, isLocal);\n        } else if (op.type === 6 /* DELETE_OBJECT_KEY */ ) {\n            return this._applyDeleteObjectKey(op, isLocal);\n        }\n        return super._apply(op, isLocal);\n    }\n    /**\n   * @internal\n   */ _serialize() {\n        const data = {};\n        for (const [key, value] of this._map){\n            if (!isLiveNode(value)) {\n                data[key] = value;\n            }\n        }\n        if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n            return {\n                type: 0 /* OBJECT */ ,\n                parentId: this.parent.node._id,\n                parentKey: this.parent.key,\n                data\n            };\n        } else {\n            return {\n                type: 0 /* OBJECT */ ,\n                data\n            };\n        }\n    }\n    /** @internal */ _applyUpdate(op, isLocal) {\n        let isModified = false;\n        const id = nn(this._id);\n        const reverse = [];\n        const reverseUpdate = {\n            type: 3 /* UPDATE_OBJECT */ ,\n            id,\n            data: {}\n        };\n        for(const key in op.data){\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverse.push(...oldValue._toOps(id, key));\n                oldValue._detach();\n            } else if (oldValue !== void 0) {\n                reverseUpdate.data[key] = oldValue;\n            } else if (oldValue === void 0) {\n                reverse.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id,\n                    key\n                });\n            }\n        }\n        const updateDelta = {};\n        for(const key in op.data){\n            const value = op.data[key];\n            if (value === void 0) {\n                continue;\n            }\n            if (isLocal) {\n                this._propToLastUpdate.set(key, nn(op.opId));\n            } else if (this._propToLastUpdate.get(key) === void 0) {\n                isModified = true;\n            } else if (this._propToLastUpdate.get(key) === op.opId) {\n                this._propToLastUpdate.delete(key);\n                continue;\n            } else {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            isModified = true;\n            updateDelta[key] = {\n                type: \"update\"\n            };\n            this._map.set(key, value);\n            this.invalidate();\n        }\n        if (Object.keys(reverseUpdate.data).length !== 0) {\n            reverse.unshift(reverseUpdate);\n        }\n        return isModified ? {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: updateDelta\n            },\n            reverse\n        } : {\n            modified: false\n        };\n    }\n    /** @internal */ _applyDeleteObjectKey(op, isLocal) {\n        const key = op.key;\n        if (this._map.has(key) === false) {\n            return {\n                modified: false\n            };\n        }\n        if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n            return {\n                modified: false\n            };\n        }\n        const oldValue = this._map.get(key);\n        const id = nn(this._id);\n        let reverse = [];\n        if (isLiveNode(oldValue)) {\n            reverse = oldValue._toOps(id, op.key);\n            oldValue._detach();\n        } else if (oldValue !== void 0) {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    id,\n                    data: {\n                        [key]: oldValue\n                    }\n                }\n            ];\n        }\n        this._map.delete(key);\n        this.invalidate();\n        return {\n            modified: {\n                node: this,\n                type: \"LiveObject\",\n                updates: {\n                    [op.key]: {\n                        type: \"delete\"\n                    }\n                }\n            },\n            reverse\n        };\n    }\n    /**\n   * Transform the LiveObject into a javascript object\n   */ toObject() {\n        return Object.fromEntries(this._map);\n    }\n    /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */ set(key, value) {\n        this._pool?.assertStorageIsWritable();\n        this.update({\n            [key]: value\n        });\n    }\n    /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */ get(key) {\n        return this._map.get(key);\n    }\n    /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */ delete(key) {\n        this._pool?.assertStorageIsWritable();\n        const keyAsString = key;\n        const oldValue = this._map.get(keyAsString);\n        if (oldValue === void 0) {\n            return;\n        }\n        if (this._pool === void 0 || this._id === void 0) {\n            if (isLiveNode(oldValue)) {\n                oldValue._detach();\n            }\n            this._map.delete(keyAsString);\n            this.invalidate();\n            return;\n        }\n        let reverse;\n        if (isLiveNode(oldValue)) {\n            oldValue._detach();\n            reverse = oldValue._toOps(this._id, keyAsString);\n        } else {\n            reverse = [\n                {\n                    type: 3 /* UPDATE_OBJECT */ ,\n                    data: {\n                        [keyAsString]: oldValue\n                    },\n                    id: this._id\n                }\n            ];\n        }\n        this._map.delete(keyAsString);\n        this.invalidate();\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: {\n                [key]: {\n                    type: \"delete\"\n                }\n            }\n        });\n        this._pool.dispatch([\n            {\n                type: 6 /* DELETE_OBJECT_KEY */ ,\n                key: keyAsString,\n                id: this._id,\n                opId: this._pool.generateOpId()\n            }\n        ], reverse, storageUpdates);\n    }\n    /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */ update(patch) {\n        this._pool?.assertStorageIsWritable();\n        if (this._pool === void 0 || this._id === void 0) {\n            for(const key in patch){\n                const newValue = patch[key];\n                if (newValue === void 0) {\n                    continue;\n                }\n                const oldValue = this._map.get(key);\n                if (isLiveNode(oldValue)) {\n                    oldValue._detach();\n                }\n                if (isLiveNode(newValue)) {\n                    newValue._setParentLink(this, key);\n                }\n                this._map.set(key, newValue);\n                this.invalidate();\n            }\n            return;\n        }\n        const ops = [];\n        const reverseOps = [];\n        const opId = this._pool.generateOpId();\n        const updatedProps = {};\n        const reverseUpdateOp = {\n            id: this._id,\n            type: 3 /* UPDATE_OBJECT */ ,\n            data: {}\n        };\n        const updateDelta = {};\n        for(const key in patch){\n            const newValue = patch[key];\n            if (newValue === void 0) {\n                continue;\n            }\n            const oldValue = this._map.get(key);\n            if (isLiveNode(oldValue)) {\n                reverseOps.push(...oldValue._toOps(this._id, key));\n                oldValue._detach();\n            } else if (oldValue === void 0) {\n                reverseOps.push({\n                    type: 6 /* DELETE_OBJECT_KEY */ ,\n                    id: this._id,\n                    key\n                });\n            } else {\n                reverseUpdateOp.data[key] = oldValue;\n            }\n            if (isLiveNode(newValue)) {\n                newValue._setParentLink(this, key);\n                newValue._attach(this._pool.generateId(), this._pool);\n                const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n                const createCrdtOp = newAttachChildOps.find((op)=>op.parentId === this._id);\n                if (createCrdtOp) {\n                    this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n                }\n                ops.push(...newAttachChildOps);\n            } else {\n                updatedProps[key] = newValue;\n                this._propToLastUpdate.set(key, opId);\n            }\n            this._map.set(key, newValue);\n            this.invalidate();\n            updateDelta[key] = {\n                type: \"update\"\n            };\n        }\n        if (Object.keys(reverseUpdateOp.data).length !== 0) {\n            reverseOps.unshift(reverseUpdateOp);\n        }\n        if (Object.keys(updatedProps).length !== 0) {\n            ops.unshift({\n                opId,\n                id: this._id,\n                type: 3 /* UPDATE_OBJECT */ ,\n                data: updatedProps\n            });\n        }\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(this._id, {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta\n        });\n        this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n    toImmutable() {\n        return super.toImmutable();\n    }\n    /** @internal */ toTreeNode(key) {\n        return super.toTreeNode(key);\n    }\n    /** @internal */ _toTreeNode(key) {\n        const nodeId = this._id ?? nanoid();\n        return {\n            type: \"LiveObject\",\n            id: nodeId,\n            key,\n            payload: Array.from(this._map.entries()).map(([key2, value])=>isLiveNode(value) ? value.toTreeNode(key2) : {\n                    type: \"Json\",\n                    id: `${nodeId}:${key2}`,\n                    key: key2,\n                    payload: value\n                })\n        };\n    }\n    /** @internal */ _toImmutable() {\n        const result = {};\n        for (const [key, val] of this._map){\n            result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n        }\n        return  false ? 0 : Object.freeze(result);\n    }\n    clone() {\n        return new _LiveObject(Object.fromEntries(Array.from(this._map).map(([key, value])=>[\n                key,\n                isLiveStructure(value) ? value.clone() : deepClone(value)\n            ])));\n    }\n};\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n    return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n    switch(op.type){\n        case 8 /* CREATE_REGISTER */ :\n            return op.data;\n        case 4 /* CREATE_OBJECT */ :\n            return new LiveObject(op.data);\n        case 7 /* CREATE_MAP */ :\n            return new LiveMap();\n        case 2 /* CREATE_LIST */ :\n            return new LiveList();\n        default:\n            return assertNever(op, \"Unknown creation Op\");\n    }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n    if (node === parent) {\n        return true;\n    }\n    if (node.parent.type === \"HasParent\") {\n        return isSameNodeOrChildOf(node.parent.node, parent);\n    }\n    return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return LiveRegister._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n    switch(crdt.type){\n        case 0 /* OBJECT */ :\n            {\n                return LiveObject._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 1 /* LIST */ :\n            {\n                return LiveList._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 2 /* MAP */ :\n            {\n                return LiveMap._deserialize([\n                    id,\n                    crdt\n                ], parentToChildren, pool);\n            }\n        case 3 /* REGISTER */ :\n            {\n                return crdt.data;\n            }\n        default:\n            {\n                throw new Error(\"Unexpected CRDT type\");\n            }\n    }\n}\nfunction isLiveStructure(value) {\n    return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n    return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n    return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n    return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n    return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n    return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n    return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n    if (obj instanceof LiveRegister) {\n        return obj.data;\n    } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n        return obj;\n    } else {\n        return assertNever(obj, \"Unknown AbstractCrdt\");\n    }\n}\nfunction lsonToLiveNode(value) {\n    if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n        return value;\n    } else {\n        return new LiveRegister(value);\n    }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n    const ops = [];\n    currentItems.forEach((_, id)=>{\n        if (!newItems.get(id)) {\n            ops.push({\n                type: 5 /* DELETE_CRDT */ ,\n                id\n            });\n        }\n    });\n    newItems.forEach((crdt, id)=>{\n        const currentCrdt = currentItems.get(id);\n        if (currentCrdt) {\n            if (crdt.type === 0 /* OBJECT */ ) {\n                if (currentCrdt.type !== 0 /* OBJECT */  || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n                    ops.push({\n                        type: 3 /* UPDATE_OBJECT */ ,\n                        id,\n                        data: crdt.data\n                    });\n                }\n            }\n            if (crdt.parentKey !== currentCrdt.parentKey) {\n                ops.push({\n                    type: 1 /* SET_PARENT_KEY */ ,\n                    id,\n                    parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n                });\n            }\n        } else {\n            switch(crdt.type){\n                case 3 /* REGISTER */ :\n                    ops.push({\n                        type: 8 /* CREATE_REGISTER */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 1 /* LIST */ :\n                    ops.push({\n                        type: 2 /* CREATE_LIST */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n                case 0 /* OBJECT */ :\n                    if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n                        throw new Error(\"Internal error. Cannot serialize storage root into an operation\");\n                    }\n                    ops.push({\n                        type: 4 /* CREATE_OBJECT */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey,\n                        data: crdt.data\n                    });\n                    break;\n                case 2 /* MAP */ :\n                    ops.push({\n                        type: 7 /* CREATE_MAP */ ,\n                        id,\n                        parentId: crdt.parentId,\n                        parentKey: crdt.parentKey\n                    });\n                    break;\n            }\n        }\n    });\n    return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeMapStorageUpdates(first, second) {\n    const updates = first.updates;\n    for (const [key, value] of entries(second.updates)){\n        updates[key] = value;\n    }\n    return {\n        ...second,\n        updates\n    };\n}\nfunction mergeListStorageUpdates(first, second) {\n    const updates = first.updates;\n    return {\n        ...second,\n        updates: updates.concat(second.updates)\n    };\n}\nfunction mergeStorageUpdates(first, second) {\n    if (first === void 0) {\n        return second;\n    }\n    if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n        return mergeObjectStorageUpdates(first, second);\n    } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n        return mergeMapStorageUpdates(first, second);\n    } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n        return mergeListStorageUpdates(first, second);\n    } else {}\n    return second;\n}\nfunction isPlain(value) {\n    const type = typeof value;\n    return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n    if (!isPlain) {\n        return {\n            path: path || \"root\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    for (const [key, nestedValue] of Object.entries(value)){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (!isPlain(nestedValue)) {\n            return {\n                path: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            const nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);\n            if (nonSerializableNestedValue) {\n                return nonSerializableNestedValue;\n            }\n        }\n    }\n    return false;\n}\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n    const errorLike = {\n        name: msg\n    };\n    if (typeof Error.captureStackTrace !== \"function\") {\n        return void 0;\n    }\n    Error.captureStackTrace(errorLike, traceRoot);\n    return errorLike.stack;\n}\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n    return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n    return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n    return !isJsonScalar(data) && !isJsonArray(data);\n}\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2)=>{\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n    ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n    ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n    return ClientMsgCode2;\n})(ClientMsgCode || {});\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n    let updated = false;\n    const newValue = {\n        ...target\n    };\n    Object.keys(patch).forEach((k)=>{\n        const key = k;\n        const val = patch[key];\n        if (newValue[key] !== val) {\n            if (val === void 0) {\n                delete newValue[key];\n            } else {\n                newValue[key] = val;\n            }\n            updated = true;\n        }\n    });\n    return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n    constructor(){\n        this._ev = makeEventSource();\n    }\n    get didInvalidate() {\n        return this._ev.observable;\n    }\n    invalidate() {\n        if (this._cache !== void 0) {\n            this._cache = void 0;\n            this._ev.notify();\n        }\n    }\n    get current() {\n        return this._cache ?? (this._cache = this._toImmutable());\n    }\n};\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n    const { connectionId, id, info } = conn;\n    const canWrite = canWriteStorage(conn.scopes);\n    return freeze(compactObject({\n        connectionId,\n        id,\n        info,\n        canWrite,\n        canComment: canComment(conn.scopes),\n        isReadOnly: !canWrite,\n        // Deprecated, kept for backward-compatibility\n        presence\n    }));\n}\nvar OthersRef = class extends ImmutableRef {\n    //\n    // --------------------------------------------------------------\n    //\n    constructor(){\n        super();\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n    }\n    connectionIds() {\n        return this._connections.keys();\n    }\n    /** @internal */ _toImmutable() {\n        const users = compact(Array.from(this._presences.keys()).map((connectionId)=>this.getUser(Number(connectionId))));\n        return users;\n    }\n    clearOthers() {\n        this._connections = /* @__PURE__ */ new Map();\n        this._presences = /* @__PURE__ */ new Map();\n        this._users = /* @__PURE__ */ new Map();\n        this.invalidate();\n    }\n    /** @internal */ _getUser(connectionId) {\n        const conn = this._connections.get(connectionId);\n        const presence = this._presences.get(connectionId);\n        if (conn !== void 0 && presence !== void 0) {\n            return makeUser(conn, presence);\n        }\n        return void 0;\n    }\n    getUser(connectionId) {\n        const cachedUser = this._users.get(connectionId);\n        if (cachedUser) {\n            return cachedUser;\n        }\n        const computedUser = this._getUser(connectionId);\n        if (computedUser) {\n            this._users.set(connectionId, computedUser);\n            return computedUser;\n        }\n        return void 0;\n    }\n    /** @internal */ _invalidateUser(connectionId) {\n        if (this._users.has(connectionId)) {\n            this._users.delete(connectionId);\n        }\n        this.invalidate();\n    }\n    /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */ setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n        this._connections.set(connectionId, freeze({\n            connectionId,\n            id: metaUserId,\n            info: metaUserInfo,\n            scopes\n        }));\n        if (this._presences.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */ removeConnection(connectionId) {\n        this._connections.delete(connectionId);\n        this._presences.delete(connectionId);\n        this._invalidateUser(connectionId);\n    }\n    /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */ setOther(connectionId, presence) {\n        this._presences.set(connectionId, freeze(compactObject(presence)));\n        if (this._connections.has(connectionId)) {\n            this._invalidateUser(connectionId);\n        }\n    }\n    /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */ patchOther(connectionId, patch) {\n        const oldPresence = this._presences.get(connectionId);\n        if (oldPresence === void 0) {\n            return;\n        }\n        const newPresence = merge(oldPresence, patch);\n        if (oldPresence !== newPresence) {\n            this._presences.set(connectionId, freeze(newPresence));\n            this._invalidateUser(connectionId);\n        }\n    }\n};\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n    constructor(data){\n        super();\n        this._data = freeze(compactObject(data));\n    }\n    /** @internal */ _toImmutable() {\n        return this._data;\n    }\n    /**\n   * Patches the current object.\n   */ patch(patch) {\n        const oldData = this._data;\n        const newData = merge(oldData, patch);\n        if (oldData !== newData) {\n            this._data = freeze(newData);\n            this.invalidate();\n        }\n    }\n};\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n    constructor(initialValue){\n        super();\n        this._value = freeze(initialValue);\n    }\n    /** @internal */ _toImmutable() {\n        return this._value;\n    }\n    set(newValue) {\n        this._value = freeze(newValue);\n        this.invalidate();\n    }\n};\nvar DerivedRef = class extends ImmutableRef {\n    constructor(...args){\n        super();\n        const transformFn = args.pop();\n        const otherRefs = args;\n        this._refs = otherRefs;\n        this._refs.forEach((ref)=>{\n            ref.didInvalidate.subscribe(()=>this.invalidate());\n        });\n        this._transform = transformFn;\n    }\n    /** @internal */ _toImmutable() {\n        return this._transform(...this._refs.map((ref)=>ref.current));\n    }\n};\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n    let count = 0;\n    return ()=>`${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n    return {\n        type: \"User\",\n        id: `${user.connectionId}`,\n        key,\n        payload: user\n    };\n}\nfunction installBackgroundTabSpy() {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const inBackgroundSince = {\n        current: null\n    };\n    function onVisibilityChange() {\n        if (doc?.visibilityState === \"hidden\") {\n            inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n        } else {\n            inBackgroundSince.current = null;\n        }\n    }\n    doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n    const unsub = ()=>{\n        doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n    };\n    return [\n        inBackgroundSince,\n        unsub\n    ];\n}\nfunction createRoom(options, config) {\n    const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n    const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n    const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n    const delegates = {\n        ...config.delegates,\n        // A connection is allowed to go into \"zombie state\" only if all of the\n        // following conditions apply:\n        //\n        // - The `backgroundKeepAliveTimeout` client option is configured\n        // - The browser window has been in the background for at least\n        //   `backgroundKeepAliveTimeout` milliseconds\n        // - There are no pending changes\n        //\n        canZombie () {\n            return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n        }\n    };\n    const managedSocket = new ManagedSocket(delegates, config.enableDebugLogging);\n    const context = {\n        buffer: {\n            flushTimerID: void 0,\n            lastFlushedAt: 0,\n            presenceUpdates: // Queue up the initial presence message as a Full Presenceâ„¢ update\n            {\n                type: \"full\",\n                data: initialPresence\n            },\n            messages: [],\n            storageOperations: []\n        },\n        staticSessionInfo: new ValueRef(null),\n        dynamicSessionInfo: new ValueRef(null),\n        myPresence: new PatchableRef(initialPresence),\n        others: new OthersRef(),\n        initialStorage,\n        idFactory: null,\n        // Storage\n        clock: 0,\n        opClock: 0,\n        nodes: /* @__PURE__ */ new Map(),\n        root: void 0,\n        undoStack: [],\n        redoStack: [],\n        pausedHistory: null,\n        activeBatch: null,\n        unacknowledgedOps: /* @__PURE__ */ new Map(),\n        // Debug\n        opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n    };\n    const doNotBatchUpdates = (cb)=>cb();\n    const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n    let lastTokenKey;\n    function onStatusDidChange(newStatus) {\n        const authValue = managedSocket.authValue;\n        if (authValue !== null) {\n            const tokenKey = authValue.type === \"secret\" ? authValue.token.raw : authValue.publicApiKey;\n            if (tokenKey !== lastTokenKey) {\n                lastTokenKey = tokenKey;\n                if (authValue.type === \"secret\") {\n                    const token = authValue.token.parsed;\n                    context.staticSessionInfo.set({\n                        userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.id : token.uid,\n                        userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */  ? token.info : token.ui\n                    });\n                } else {\n                    context.staticSessionInfo.set({\n                        userId: void 0,\n                        userInfo: void 0\n                    });\n                }\n            }\n        }\n        batchUpdates(()=>{\n            eventHub.status.notify(newStatus);\n            notifySelfChanged(doNotBatchUpdates);\n        });\n    }\n    let _connectionLossTimerId;\n    let _hasLostConnection = false;\n    function handleConnectionLossEvent(newStatus) {\n        if (newStatus === \"reconnecting\") {\n            _connectionLossTimerId = setTimeout(()=>{\n                batchUpdates(()=>{\n                    eventHub.lostConnection.notify(\"lost\");\n                    _hasLostConnection = true;\n                    context.others.clearOthers();\n                    notify({\n                        others: [\n                            {\n                                type: \"reset\"\n                            }\n                        ]\n                    }, doNotBatchUpdates);\n                });\n            }, config.lostConnectionTimeout);\n        } else {\n            clearTimeout(_connectionLossTimerId);\n            if (_hasLostConnection) {\n                if (newStatus === \"disconnected\") {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"failed\");\n                    });\n                } else {\n                    batchUpdates(()=>{\n                        eventHub.lostConnection.notify(\"restored\");\n                    });\n                }\n                _hasLostConnection = false;\n            }\n        }\n    }\n    function onDidConnect() {\n        context.buffer.presenceUpdates = {\n            type: \"full\",\n            data: // Because context.me.current is a readonly object, we'll have to\n            // make a copy here. Otherwise, type errors happen later when\n            // \"patching\" my presence.\n            {\n                ...context.myPresence.current\n            }\n        };\n        if (_getStorage$ !== null) {\n            refreshStorage({\n                flush: false\n            });\n        }\n        flushNowOrSoon();\n    }\n    function onDidDisconnect() {\n        clearTimeout(context.buffer.flushTimerID);\n    }\n    managedSocket.events.onMessage.subscribe(handleServerMessage);\n    managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n    managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n    managedSocket.events.didConnect.subscribe(onDidConnect);\n    managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n    managedSocket.events.onLiveblocksError.subscribe((err)=>{\n        batchUpdates(()=>{\n            if (true) {\n                error2(`Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`);\n            }\n            eventHub.error.notify(err);\n        });\n    });\n    const pool = {\n        roomId: config.roomId,\n        getNode: (id)=>context.nodes.get(id),\n        addNode: (id, node)=>void context.nodes.set(id, node),\n        deleteNode: (id)=>void context.nodes.delete(id),\n        generateId: ()=>`${getConnectionId()}:${context.clock++}`,\n        generateOpId: ()=>`${getConnectionId()}:${context.opClock++}`,\n        dispatch (ops, reverse, storageUpdates) {\n            const activeBatch = context.activeBatch;\n            if (true) {\n                const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n                if (stackTrace) {\n                    for (const op of ops){\n                        if (op.opId) {\n                            nn(context.opStackTraces).set(op.opId, stackTrace);\n                        }\n                    }\n                }\n            }\n            if (activeBatch) {\n                activeBatch.ops.push(...ops);\n                for (const [key, value] of storageUpdates){\n                    activeBatch.updates.storageUpdates.set(key, mergeStorageUpdates(activeBatch.updates.storageUpdates.get(key), value));\n                }\n                activeBatch.reverseOps.unshift(...reverse);\n            } else {\n                batchUpdates(()=>{\n                    addToUndoStack(reverse, doNotBatchUpdates);\n                    context.redoStack.length = 0;\n                    dispatchOps(ops);\n                    notify({\n                        storageUpdates\n                    }, doNotBatchUpdates);\n                });\n            }\n        },\n        assertStorageIsWritable: ()=>{\n            const scopes = context.dynamicSessionInfo.current?.scopes;\n            if (scopes === void 0) {\n                return;\n            }\n            const canWrite = canWriteStorage(scopes);\n            if (!canWrite) {\n                throw new Error(\"Cannot write to storage with a read only user, please ensure the user has write permissions\");\n            }\n        }\n    };\n    const eventHub = {\n        connection: makeEventSource(),\n        // Old/deprecated API\n        status: makeEventSource(),\n        // New/recommended API\n        lostConnection: makeEventSource(),\n        customEvent: makeEventSource(),\n        self: makeEventSource(),\n        myPresence: makeEventSource(),\n        others: makeEventSource(),\n        error: makeEventSource(),\n        storage: makeEventSource(),\n        history: makeEventSource(),\n        storageDidLoad: makeEventSource(),\n        storageStatus: makeEventSource(),\n        ydoc: makeEventSource(),\n        comments: makeEventSource()\n    };\n    async function streamFetch(authTokenOrPublicApiKey, roomId) {\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(roomId)}/storage`, config.baseUrl).toString();\n        const fetcher = config.polyfills?.fetch || /* istanbul ignore next */ fetch;\n        return fetcher(url.toString(), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${authTokenOrPublicApiKey}`\n            }\n        });\n    }\n    async function httpPostToRoom(endpoint, body) {\n        if (!managedSocket.authValue) {\n            throw new Error(\"Not authorized\");\n        }\n        const authTokenOrPublicApiKey = managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw;\n        const url = new URL(`/v2/c/rooms/${encodeURIComponent(config.roomId)}${endpoint}`, config.baseUrl).toString();\n        const fetcher = config.polyfills?.fetch || /* istanbul ignore next */ fetch;\n        return fetcher(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${authTokenOrPublicApiKey}`\n            },\n            body: JSON.stringify(body)\n        });\n    }\n    function sendMessages(messages) {\n        const serializedPayload = JSON.stringify(messages);\n        const nonce = context.dynamicSessionInfo.current?.nonce;\n        if (config.unstable_fallbackToHTTP && nonce) {\n            const size = new TextEncoder().encode(serializedPayload).length;\n            if (size > MAX_SOCKET_MESSAGE_SIZE) {\n                void httpPostToRoom(\"/send-message\", {\n                    nonce,\n                    messages\n                }).then((resp)=>{\n                    if (!resp.ok && resp.status === 403) {\n                        managedSocket.reconnect();\n                    }\n                });\n                warn(\"Message was too large for websockets and sent over HTTP instead\");\n                return;\n            }\n        }\n        managedSocket.send(serializedPayload);\n    }\n    const self = new DerivedRef(context.staticSessionInfo, context.dynamicSessionInfo, context.myPresence, (staticSession, dynamicSession, myPresence)=>{\n        if (staticSession === null || dynamicSession === null) {\n            return null;\n        } else {\n            const canWrite = canWriteStorage(dynamicSession.scopes);\n            return {\n                connectionId: dynamicSession.actor,\n                id: staticSession.userId,\n                info: staticSession.userInfo,\n                presence: myPresence,\n                canWrite,\n                canComment: canComment(dynamicSession.scopes),\n                isReadOnly: !canWrite\n            };\n        }\n    });\n    let _lastSelf;\n    function notifySelfChanged(batchedUpdatesWrapper) {\n        const currSelf = self.current;\n        if (currSelf !== null && currSelf !== _lastSelf) {\n            batchedUpdatesWrapper(()=>{\n                eventHub.self.notify(currSelf);\n            });\n            _lastSelf = currSelf;\n        }\n    }\n    const selfAsTreeNode = new DerivedRef(self, (me)=>me !== null ? userToTreeNode(\"Me\", me) : null);\n    function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n        if (message.items.length === 0) {\n            throw new Error(\"Internal error: cannot load storage without items\");\n        }\n        if (context.root !== void 0) {\n            updateRoot(message.items, batchedUpdatesWrapper);\n        } else {\n            context.root = LiveObject._fromItems(message.items, pool);\n        }\n        const stackSizeBefore = context.undoStack.length;\n        for(const key in context.initialStorage){\n            if (context.root.get(key) === void 0) {\n                context.root.set(key, cloneLson(context.initialStorage[key]));\n            }\n        }\n        context.undoStack.length = stackSizeBefore;\n    }\n    function updateRoot(items, batchedUpdatesWrapper) {\n        if (context.root === void 0) {\n            return;\n        }\n        const currentItems = /* @__PURE__ */ new Map();\n        for (const [id, node] of context.nodes){\n            currentItems.set(id, node._serialize());\n        }\n        const ops = getTreesDiffOperations(currentItems, new Map(items));\n        const result = applyOps(ops, false);\n        notify(result.updates, batchedUpdatesWrapper);\n    }\n    function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.undoStack.length >= 50) {\n            context.undoStack.shift();\n        }\n        context.undoStack.push(historyOps);\n        onHistoryChange(batchedUpdatesWrapper);\n    }\n    function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n        if (context.pausedHistory !== null) {\n            context.pausedHistory.unshift(...historyOps);\n        } else {\n            _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n        }\n    }\n    function notify(updates, batchedUpdatesWrapper) {\n        const storageUpdates = updates.storageUpdates;\n        const othersUpdates = updates.others;\n        batchedUpdatesWrapper(()=>{\n            if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n                const others = context.others.current;\n                for (const event of othersUpdates){\n                    eventHub.others.notify({\n                        ...event,\n                        others\n                    });\n                }\n            }\n            if (updates.presence ?? false) {\n                notifySelfChanged(doNotBatchUpdates);\n                eventHub.myPresence.notify(context.myPresence.current);\n            }\n            if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n                const updates2 = Array.from(storageUpdates.values());\n                eventHub.storage.notify(updates2);\n            }\n            notifyStorageStatus();\n        });\n    }\n    function getConnectionId() {\n        const info = context.dynamicSessionInfo.current;\n        if (info) {\n            return info.actor;\n        }\n        throw new Error(\"Internal. Tried to get connection id but connection was never open\");\n    }\n    function applyOps(rawOps, isLocal) {\n        const output = {\n            reverse: [],\n            storageUpdates: /* @__PURE__ */ new Map(),\n            presence: false\n        };\n        const createdNodeIds = /* @__PURE__ */ new Set();\n        const ops = rawOps.map((op)=>{\n            if (op.type !== \"presence\" && !op.opId) {\n                return {\n                    ...op,\n                    opId: pool.generateOpId()\n                };\n            } else {\n                return op;\n            }\n        });\n        for (const op of ops){\n            if (op.type === \"presence\") {\n                const reverse = {\n                    type: \"presence\",\n                    data: {}\n                };\n                for(const key in op.data){\n                    reverse.data[key] = context.myPresence.current[key];\n                }\n                context.myPresence.patch(op.data);\n                if (context.buffer.presenceUpdates === null) {\n                    context.buffer.presenceUpdates = {\n                        type: \"partial\",\n                        data: op.data\n                    };\n                } else {\n                    for(const key in op.data){\n                        context.buffer.presenceUpdates.data[key] = op.data[key];\n                    }\n                }\n                output.reverse.unshift(reverse);\n                output.presence = true;\n            } else {\n                let source;\n                if (isLocal) {\n                    source = 0 /* UNDOREDO_RECONNECT */ ;\n                } else {\n                    const opId = nn(op.opId);\n                    if (true) {\n                        nn(context.opStackTraces).delete(opId);\n                    }\n                    const deleted = context.unacknowledgedOps.delete(opId);\n                    source = deleted ? 2 /* ACK */  : 1 /* REMOTE */ ;\n                }\n                const applyOpResult = applyOp(op, source);\n                if (applyOpResult.modified) {\n                    const nodeId = applyOpResult.modified.node._id;\n                    if (!(nodeId && createdNodeIds.has(nodeId))) {\n                        output.storageUpdates.set(nn(applyOpResult.modified.node._id), mergeStorageUpdates(output.storageUpdates.get(nn(applyOpResult.modified.node._id)), applyOpResult.modified));\n                        output.reverse.unshift(...applyOpResult.reverse);\n                    }\n                    if (op.type === 2 /* CREATE_LIST */  || op.type === 7 /* CREATE_MAP */  || op.type === 4 /* CREATE_OBJECT */ ) {\n                        createdNodeIds.add(nn(op.id));\n                    }\n                }\n            }\n        }\n        return {\n            ops,\n            reverse: output.reverse,\n            updates: {\n                storageUpdates: output.storageUpdates,\n                presence: output.presence\n            }\n        };\n    }\n    function applyOp(op, source) {\n        if (isAckOp(op)) {\n            return {\n                modified: false\n            };\n        }\n        switch(op.type){\n            case 6 /* DELETE_OBJECT_KEY */ :\n            case 3 /* UPDATE_OBJECT */ :\n            case 5 /* DELETE_CRDT */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */ );\n                }\n            case 1 /* SET_PARENT_KEY */ :\n                {\n                    const node = context.nodes.get(op.id);\n                    if (node === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n                        return node.parent.node._setChildKey(asPos(op.parentKey), node, source);\n                    }\n                    return {\n                        modified: false\n                    };\n                }\n            case 4 /* CREATE_OBJECT */ :\n            case 2 /* CREATE_LIST */ :\n            case 7 /* CREATE_MAP */ :\n            case 8 /* CREATE_REGISTER */ :\n                {\n                    if (op.parentId === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    const parentNode = context.nodes.get(op.parentId);\n                    if (parentNode === void 0) {\n                        return {\n                            modified: false\n                        };\n                    }\n                    return parentNode._attachChild(op, source);\n                }\n        }\n    }\n    function updatePresence(patch, options2) {\n        const oldValues = {};\n        if (context.buffer.presenceUpdates === null) {\n            context.buffer.presenceUpdates = {\n                type: \"partial\",\n                data: {}\n            };\n        }\n        for(const key in patch){\n            const overrideValue = patch[key];\n            if (overrideValue === void 0) {\n                continue;\n            }\n            context.buffer.presenceUpdates.data[key] = overrideValue;\n            oldValues[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(patch);\n        if (context.activeBatch) {\n            if (options2?.addToHistory) {\n                context.activeBatch.reverseOps.unshift({\n                    type: \"presence\",\n                    data: oldValues\n                });\n            }\n            context.activeBatch.updates.presence = true;\n        } else {\n            flushNowOrSoon();\n            batchUpdates(()=>{\n                if (options2?.addToHistory) {\n                    addToUndoStack([\n                        {\n                            type: \"presence\",\n                            data: oldValues\n                        }\n                    ], doNotBatchUpdates);\n                }\n                notify({\n                    presence: true\n                }, doNotBatchUpdates);\n            });\n        }\n    }\n    function onUpdatePresenceMessage(message) {\n        if (message.targetActor !== void 0) {\n            const oldUser = context.others.getUser(message.actor);\n            context.others.setOther(message.actor, message.data);\n            const newUser = context.others.getUser(message.actor);\n            if (oldUser === void 0 && newUser !== void 0) {\n                return {\n                    type: \"enter\",\n                    user: newUser\n                };\n            }\n        } else {\n            context.others.patchOther(message.actor, message.data), message;\n        }\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            return {\n                type: \"update\",\n                updates: message.data,\n                user\n            };\n        } else {\n            return void 0;\n        }\n    }\n    function onUserLeftMessage(message) {\n        const user = context.others.getUser(message.actor);\n        if (user) {\n            context.others.removeConnection(message.actor);\n            return {\n                type: \"leave\",\n                user\n            };\n        }\n        return null;\n    }\n    function onRoomStateMessage(message, batchedUpdatesWrapper) {\n        context.dynamicSessionInfo.set({\n            actor: message.actor,\n            nonce: message.nonce,\n            scopes: message.scopes\n        });\n        context.idFactory = makeIdFactory(message.actor);\n        notifySelfChanged(batchedUpdatesWrapper);\n        for (const connectionId of context.others.connectionIds()){\n            const user = message.users[connectionId];\n            if (user === void 0) {\n                context.others.removeConnection(connectionId);\n            }\n        }\n        for(const key in message.users){\n            const user = message.users[key];\n            const connectionId = Number(key);\n            context.others.setConnection(connectionId, user.id, user.info, user.scopes);\n        }\n        return {\n            type: \"reset\"\n        };\n    }\n    function canUndo() {\n        return context.undoStack.length > 0;\n    }\n    function canRedo() {\n        return context.redoStack.length > 0;\n    }\n    function onHistoryChange(batchedUpdatesWrapper) {\n        batchedUpdatesWrapper(()=>{\n            eventHub.history.notify({\n                canUndo: canUndo(),\n                canRedo: canRedo()\n            });\n        });\n    }\n    function onUserJoinedMessage(message) {\n        context.others.setConnection(message.actor, message.id, message.info, message.scopes);\n        context.buffer.messages.push({\n            type: 100 /* UPDATE_PRESENCE */ ,\n            data: context.myPresence.current,\n            targetActor: message.actor\n        });\n        flushNowOrSoon();\n        const user = context.others.getUser(message.actor);\n        return user ? {\n            type: \"enter\",\n            user\n        } : void 0;\n    }\n    function parseServerMessage(data) {\n        if (!isJsonObject(data)) {\n            return null;\n        }\n        return data;\n    }\n    function parseServerMessages(text) {\n        const data = tryParseJson(text);\n        if (data === void 0) {\n            return null;\n        } else if (isJsonArray(data)) {\n            return compact(data.map((item)=>parseServerMessage(item)));\n        } else {\n            return compact([\n                parseServerMessage(data)\n            ]);\n        }\n    }\n    function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n        if (offlineOps.size === 0) {\n            return;\n        }\n        const messages = [];\n        const ops = Array.from(offlineOps.values());\n        const result = applyOps(ops, true);\n        messages.push({\n            type: 201 /* UPDATE_STORAGE */ ,\n            ops: result.ops\n        });\n        notify(result.updates, batchedUpdatesWrapper);\n        sendMessages(messages);\n    }\n    function handleServerMessage(event) {\n        if (typeof event.data !== \"string\") {\n            return;\n        }\n        const messages = parseServerMessages(event.data);\n        if (messages === null || messages.length === 0) {\n            return;\n        }\n        const updates = {\n            storageUpdates: /* @__PURE__ */ new Map(),\n            others: []\n        };\n        batchUpdates(()=>{\n            for (const message of messages){\n                switch(message.type){\n                    case 101 /* USER_JOINED */ :\n                        {\n                            const userJoinedUpdate = onUserJoinedMessage(message);\n                            if (userJoinedUpdate) {\n                                updates.others.push(userJoinedUpdate);\n                            }\n                            break;\n                        }\n                    case 100 /* UPDATE_PRESENCE */ :\n                        {\n                            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n                            if (othersPresenceUpdate) {\n                                updates.others.push(othersPresenceUpdate);\n                            }\n                            break;\n                        }\n                    case 103 /* BROADCASTED_EVENT */ :\n                        {\n                            const others = context.others.current;\n                            eventHub.customEvent.notify({\n                                connectionId: message.actor,\n                                user: message.actor < 0 ? null : others.find((u)=>u.connectionId === message.actor) ?? null,\n                                event: message.event\n                            });\n                            break;\n                        }\n                    case 102 /* USER_LEFT */ :\n                        {\n                            const event2 = onUserLeftMessage(message);\n                            if (event2) {\n                                updates.others.push(event2);\n                            }\n                            break;\n                        }\n                    case 300 /* UPDATE_YDOC */ :\n                        {\n                            eventHub.ydoc.notify(message);\n                            break;\n                        }\n                    case 104 /* ROOM_STATE */ :\n                        {\n                            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n                            break;\n                        }\n                    case 200 /* INITIAL_STORAGE_STATE */ :\n                        {\n                            processInitialStorage(message);\n                            break;\n                        }\n                    case 201 /* UPDATE_STORAGE */ :\n                        {\n                            const applyResult = applyOps(message.ops, false);\n                            for (const [key, value] of applyResult.updates.storageUpdates){\n                                updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));\n                            }\n                            break;\n                        }\n                    case 299 /* REJECT_STORAGE_OP */ :\n                        {\n                            errorWithTitle(\"Storage mutation rejection error\", message.reason);\n                            if (true) {\n                                const traces = /* @__PURE__ */ new Set();\n                                for (const opId of message.opIds){\n                                    const trace = context.opStackTraces?.get(opId);\n                                    if (trace) {\n                                        traces.add(trace);\n                                    }\n                                }\n                                if (traces.size > 0) {\n                                    warnWithTitle(\"The following function calls caused the rejected storage mutations:\", `\n\n${Array.from(traces).join(\"\\n\\n\")}`);\n                                }\n                                throw new Error(`Storage mutations rejected by server: ${message.reason}`);\n                            }\n                            break;\n                        }\n                    case 400 /* THREAD_CREATED */ :\n                    case 401 /* THREAD_METADATA_UPDATED */ :\n                    case 405 /* COMMENT_REACTION_ADDED */ :\n                    case 406 /* COMMENT_REACTION_REMOVED */ :\n                    case 402 /* COMMENT_CREATED */ :\n                    case 403 /* COMMENT_EDITED */ :\n                    case 404 /* COMMENT_DELETED */ :\n                        {\n                            eventHub.comments.notify(message);\n                            break;\n                        }\n                }\n            }\n            notify(updates, doNotBatchUpdates);\n        });\n    }\n    function flushNowOrSoon() {\n        const storageOps = context.buffer.storageOperations;\n        if (storageOps.length > 0) {\n            for (const op of storageOps){\n                context.unacknowledgedOps.set(nn(op.opId), op);\n            }\n            notifyStorageStatus();\n        }\n        if (managedSocket.getStatus() !== \"connected\") {\n            context.buffer.storageOperations = [];\n            return;\n        }\n        const now = Date.now();\n        const elapsedMillis = now - context.buffer.lastFlushedAt;\n        if (elapsedMillis >= config.throttleDelay) {\n            const messagesToFlush = serializeBuffer();\n            if (messagesToFlush.length === 0) {\n                return;\n            }\n            sendMessages(messagesToFlush);\n            context.buffer = {\n                flushTimerID: void 0,\n                lastFlushedAt: now,\n                messages: [],\n                storageOperations: [],\n                presenceUpdates: null\n            };\n        } else {\n            clearTimeout(context.buffer.flushTimerID);\n            context.buffer.flushTimerID = setTimeout(flushNowOrSoon, config.throttleDelay - elapsedMillis);\n        }\n    }\n    function serializeBuffer() {\n        const messages = [];\n        if (context.buffer.presenceUpdates) {\n            messages.push(context.buffer.presenceUpdates.type === \"full\" ? {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                // Populating the `targetActor` field turns this message into\n                // a Full Presenceâ„¢ update message (not a patch), which will get\n                // interpreted by other clients as such.\n                targetActor: -1,\n                data: context.buffer.presenceUpdates.data\n            } : {\n                type: 100 /* UPDATE_PRESENCE */ ,\n                data: context.buffer.presenceUpdates.data\n            });\n        }\n        for (const event of context.buffer.messages){\n            messages.push(event);\n        }\n        if (context.buffer.storageOperations.length > 0) {\n            messages.push({\n                type: 201 /* UPDATE_STORAGE */ ,\n                ops: context.buffer.storageOperations\n            });\n        }\n        return messages;\n    }\n    function updateYDoc(update, guid) {\n        const clientMsg = {\n            type: 301 /* UPDATE_YDOC */ ,\n            update,\n            guid\n        };\n        context.buffer.messages.push(clientMsg);\n        eventHub.ydoc.notify(clientMsg);\n        flushNowOrSoon();\n    }\n    function broadcastEvent(event, options2 = {\n        shouldQueueEventIfNotReady: false\n    }) {\n        if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n            return;\n        }\n        context.buffer.messages.push({\n            type: 103 /* BROADCAST_EVENT */ ,\n            event\n        });\n        flushNowOrSoon();\n    }\n    function dispatchOps(ops) {\n        context.buffer.storageOperations.push(...ops);\n        flushNowOrSoon();\n    }\n    let _getStorage$ = null;\n    let _resolveStoragePromise = null;\n    function processInitialStorage(message) {\n        const unacknowledgedOps = new Map(context.unacknowledgedOps);\n        createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n        applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n        _resolveStoragePromise?.();\n        notifyStorageStatus();\n        eventHub.storageDidLoad.notify();\n    }\n    async function streamStorage() {\n        if (!managedSocket.authValue) {\n            return;\n        }\n        const result = await streamFetch(managedSocket.authValue.type === \"public\" ? managedSocket.authValue.publicApiKey : managedSocket.authValue.token.raw, config.roomId);\n        const items = await result.json();\n        processInitialStorage({\n            type: 200 /* INITIAL_STORAGE_STATE */ ,\n            items\n        });\n    }\n    function refreshStorage(options2) {\n        const messages = context.buffer.messages;\n        if (config.unstable_streamData) {\n            void streamStorage();\n        } else if (!messages.some((msg)=>msg.type === 200 /* FETCH_STORAGE */ )) {\n            messages.push({\n                type: 200 /* FETCH_STORAGE */ \n            });\n        }\n        if (options2.flush) {\n            flushNowOrSoon();\n        }\n    }\n    function startLoadingStorage() {\n        if (_getStorage$ === null) {\n            refreshStorage({\n                flush: true\n            });\n            _getStorage$ = new Promise((resolve)=>{\n                _resolveStoragePromise = resolve;\n            });\n            notifyStorageStatus();\n        }\n        return _getStorage$;\n    }\n    function getStorageSnapshot() {\n        const root = context.root;\n        if (root !== void 0) {\n            return root;\n        } else {\n            void startLoadingStorage();\n            return null;\n        }\n    }\n    async function getStorage() {\n        if (context.root !== void 0) {\n            return Promise.resolve({\n                root: context.root\n            });\n        }\n        await startLoadingStorage();\n        return {\n            root: nn(context.root)\n        };\n    }\n    function fetchYDoc(vector, guid) {\n        if (!context.buffer.messages.find((m)=>{\n            return m.type === 300 /* FETCH_YDOC */  && m.vector === vector && m.guid === guid;\n        })) {\n            context.buffer.messages.push({\n                type: 300 /* FETCH_YDOC */ ,\n                vector,\n                guid\n            });\n        }\n        flushNowOrSoon();\n    }\n    function undo() {\n        if (context.activeBatch) {\n            throw new Error(\"undo is not allowed during a batch\");\n        }\n        const historyOps = context.undoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.redoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function redo() {\n        if (context.activeBatch) {\n            throw new Error(\"redo is not allowed during a batch\");\n        }\n        const historyOps = context.redoStack.pop();\n        if (historyOps === void 0) {\n            return;\n        }\n        context.pausedHistory = null;\n        const result = applyOps(historyOps, true);\n        batchUpdates(()=>{\n            notify(result.updates, doNotBatchUpdates);\n            context.undoStack.push(result.reverse);\n            onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops){\n            if (op.type !== \"presence\") {\n                context.buffer.storageOperations.push(op);\n            }\n        }\n        flushNowOrSoon();\n    }\n    function clear() {\n        context.undoStack.length = 0;\n        context.redoStack.length = 0;\n    }\n    function batch(callback) {\n        if (context.activeBatch) {\n            return callback();\n        }\n        let returnValue = void 0;\n        batchUpdates(()=>{\n            context.activeBatch = {\n                ops: [],\n                updates: {\n                    storageUpdates: /* @__PURE__ */ new Map(),\n                    presence: false,\n                    others: []\n                },\n                reverseOps: []\n            };\n            try {\n                returnValue = callback();\n            } finally{\n                const currentBatch = context.activeBatch;\n                context.activeBatch = null;\n                if (currentBatch.reverseOps.length > 0) {\n                    addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n                }\n                if (currentBatch.ops.length > 0) {\n                    context.redoStack.length = 0;\n                }\n                if (currentBatch.ops.length > 0) {\n                    dispatchOps(currentBatch.ops);\n                }\n                notify(currentBatch.updates, doNotBatchUpdates);\n                flushNowOrSoon();\n            }\n        });\n        return returnValue;\n    }\n    function pauseHistory() {\n        if (context.pausedHistory === null) {\n            context.pausedHistory = [];\n        }\n    }\n    function resumeHistory() {\n        const historyOps = context.pausedHistory;\n        context.pausedHistory = null;\n        if (historyOps !== null && historyOps.length > 0) {\n            _addToRealUndoStack(historyOps, batchUpdates);\n        }\n    }\n    function getStorageStatus() {\n        if (context.root === void 0) {\n            return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n        } else {\n            return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n        }\n    }\n    let _lastStorageStatus = getStorageStatus();\n    function notifyStorageStatus() {\n        const storageStatus = getStorageStatus();\n        if (_lastStorageStatus !== storageStatus) {\n            _lastStorageStatus = storageStatus;\n            eventHub.storageStatus.notify(storageStatus);\n        }\n    }\n    const others_forDevTools = new DerivedRef(context.others, (others)=>others.map((other, index)=>userToTreeNode(`Other ${index}`, other)));\n    const events = {\n        status: eventHub.status.observable,\n        lostConnection: eventHub.lostConnection.observable,\n        customEvent: eventHub.customEvent.observable,\n        others: eventHub.others.observable,\n        self: eventHub.self.observable,\n        myPresence: eventHub.myPresence.observable,\n        error: eventHub.error.observable,\n        storage: eventHub.storage.observable,\n        history: eventHub.history.observable,\n        storageDidLoad: eventHub.storageDidLoad.observable,\n        storageStatus: eventHub.storageStatus.observable,\n        ydoc: eventHub.ydoc.observable,\n        comments: eventHub.comments.observable\n    };\n    const commentsApi = createCommentsApi(config.roomId, delegates.authenticate, {\n        baseUrl: config.baseUrl\n    });\n    return Object.defineProperty({\n        /* NOTE: Exposing __internal here only to allow testing implementation details in unit tests */ __internal: {\n            get presenceBuffer () {\n                return deepClone(context.buffer.presenceUpdates?.data ?? null);\n            },\n            // prettier-ignore\n            get undoStack () {\n                return deepClone(context.undoStack);\n            },\n            // prettier-ignore\n            get nodeCount () {\n                return context.nodes.size;\n            },\n            // prettier-ignore\n            // Support for the Liveblocks browser extension\n            getSelf_forDevTools: ()=>selfAsTreeNode.current,\n            getOthers_forDevTools: ()=>others_forDevTools.current,\n            // prettier-ignore\n            simulate: {\n                // These exist only for our E2E testing app\n                explicitClose: (event)=>managedSocket._privateSendMachineEvent({\n                        type: \"EXPLICIT_SOCKET_CLOSE\",\n                        event\n                    }),\n                rawSend: (data)=>managedSocket.send(data)\n            }\n        },\n        id: config.roomId,\n        subscribe: makeClassicSubscribeFn(events),\n        connect: ()=>managedSocket.connect(),\n        reconnect: ()=>managedSocket.reconnect(),\n        disconnect: ()=>managedSocket.disconnect(),\n        destroy: ()=>{\n            uninstallBgTabSpy();\n            managedSocket.destroy();\n        },\n        // Presence\n        updatePresence,\n        updateYDoc,\n        broadcastEvent,\n        // Storage\n        batch,\n        history: {\n            undo,\n            redo,\n            canUndo,\n            canRedo,\n            clear,\n            pause: pauseHistory,\n            resume: resumeHistory\n        },\n        fetchYDoc,\n        getStorage,\n        getStorageSnapshot,\n        getStorageStatus,\n        events,\n        // Core\n        getStatus: ()=>managedSocket.getStatus(),\n        getConnectionState: ()=>managedSocket.getLegacyStatus(),\n        getSelf: ()=>self.current,\n        // Presence\n        getPresence: ()=>context.myPresence.current,\n        getOthers: ()=>context.others.current,\n        ...commentsApi\n    }, // Explictly make the __internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    \"__internal\", {\n        enumerable: false\n    });\n}\nfunction makeClassicSubscribeFn(events) {\n    function subscribeToLiveStructureDeeply(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            const relatedUpdates = updates.filter((update)=>isSameNodeOrChildOf(update.node, node));\n            if (relatedUpdates.length > 0) {\n                callback(relatedUpdates);\n            }\n        });\n    }\n    function subscribeToLiveStructureShallowly(node, callback) {\n        return events.storage.subscribe((updates)=>{\n            for (const update of updates){\n                if (update.node._id === node._id) {\n                    callback(update.node);\n                }\n            }\n        });\n    }\n    function subscribe(first, second, options) {\n        if (typeof first === \"string\" && isRoomEventName(first)) {\n            if (typeof second !== \"function\") {\n                throw new Error(\"Second argument must be a callback function\");\n            }\n            const callback = second;\n            switch(first){\n                case \"event\":\n                    return events.customEvent.subscribe(callback);\n                case \"my-presence\":\n                    return events.myPresence.subscribe(callback);\n                case \"others\":\n                    {\n                        const cb = callback;\n                        return events.others.subscribe((event)=>{\n                            const { others, ...internalEvent } = event;\n                            return cb(others, internalEvent);\n                        });\n                    }\n                case \"error\":\n                    return events.error.subscribe(callback);\n                case \"connection\":\n                    {\n                        const cb = callback;\n                        return events.status.subscribe((status)=>cb(newToLegacyStatus(status)));\n                    }\n                case \"status\":\n                    return events.status.subscribe(callback);\n                case \"lost-connection\":\n                    return events.lostConnection.subscribe(callback);\n                case \"history\":\n                    return events.history.subscribe(callback);\n                case \"storage-status\":\n                    return events.storageStatus.subscribe(callback);\n                default:\n                    return assertNever(first, `\"${String(first)}\" is not a valid event name`);\n            }\n        }\n        if (second === void 0 || typeof first === \"function\") {\n            if (typeof first === \"function\") {\n                const storageCallback = first;\n                return events.storage.subscribe(storageCallback);\n            } else {\n                throw new Error(\"Please specify a listener callback\");\n            }\n        }\n        if (isLiveNode(first)) {\n            const node = first;\n            if (options?.isDeep) {\n                const storageCallback = second;\n                return subscribeToLiveStructureDeeply(node, storageCallback);\n            } else {\n                const nodeCallback = second;\n                return subscribeToLiveStructureShallowly(node, nodeCallback);\n            }\n        }\n        throw new Error(`${String(first)} is not a value that can be subscribed to.`);\n    }\n    return subscribe;\n}\nfunction isRoomEventName(value) {\n    return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n    return async ()=>{\n        return authManager.getAuthValue(\"room:read\", roomId);\n    };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n    return (authValue)=>{\n        const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n        if (ws === void 0) {\n            throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\");\n        }\n        const url = new URL(baseUrl);\n        url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n        url.pathname = \"/v7\";\n        url.searchParams.set(\"roomId\", roomId);\n        if (authValue.type === \"secret\") {\n            url.searchParams.set(\"tok\", authValue.token.raw);\n        } else if (authValue.type === \"public\") {\n            url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n        } else {\n            return assertNever(authValue, \"Unhandled case\");\n        }\n        url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n        return new ws(url.toString());\n    };\n}\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nfunction getBaseUrlFromClientOptions(clientOptions) {\n    if (\"liveblocksServer\" in clientOptions) {\n        throw new Error(\"Client option no longer supported\");\n    }\n    if (typeof clientOptions.baseUrl === \"string\" && clientOptions.baseUrl.startsWith(\"http\")) {\n        return clientOptions.baseUrl;\n    } else {\n        return DEFAULT_BASE_URL;\n    }\n}\nfunction createClient(options) {\n    const clientOptions = options;\n    const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n    const lostConnectionTimeout = getLostConnectionTimeout(clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT);\n    const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(clientOptions.backgroundKeepAliveTimeout);\n    const authManager = createAuthManager(options);\n    const roomsById = /* @__PURE__ */ new Map();\n    function teardownRoom(room) {\n        unlinkDevTools(room.id);\n        roomsById.delete(room.id);\n        room.destroy();\n    }\n    function leaseRoom(info) {\n        const leave = ()=>{\n            const self = leave;\n            if (!info.unsubs.delete(self)) {\n                warn(\"This leave function was already called. Calling it more than once has no effect.\");\n            } else {\n                if (info.unsubs.size === 0) {\n                    teardownRoom(info.room);\n                }\n            }\n        };\n        info.unsubs.add(leave);\n        return {\n            room: info.room,\n            leave\n        };\n    }\n    function enterRoom(roomId, options2) {\n        const existing = roomsById.get(roomId);\n        if (existing !== void 0) {\n            return leaseRoom(existing);\n        }\n        deprecateIf(options2.initialPresence === null || options2.initialPresence === void 0, \"Please provide an initial presence value for the current user when entering the room.\");\n        const baseUrl = getBaseUrlFromClientOptions(clientOptions);\n        const newRoom = createRoom({\n            initialPresence: options2.initialPresence ?? {},\n            initialStorage: options2.initialStorage\n        }, {\n            roomId,\n            throttleDelay,\n            lostConnectionTimeout,\n            backgroundKeepAliveTimeout,\n            polyfills: clientOptions.polyfills,\n            delegates: clientOptions.mockedDelegates ?? {\n                createSocket: makeCreateSocketDelegateForRoom(roomId, baseUrl, clientOptions.polyfills?.WebSocket),\n                authenticate: makeAuthDelegateForRoom(roomId, authManager)\n            },\n            enableDebugLogging: clientOptions.enableDebugLogging,\n            unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n            baseUrl,\n            unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n            unstable_streamData: !!clientOptions.unstable_streamData\n        });\n        const newRoomInfo = {\n            room: newRoom,\n            unsubs: /* @__PURE__ */ new Set()\n        };\n        roomsById.set(roomId, newRoomInfo);\n        setupDevTools(()=>Array.from(roomsById.keys()));\n        linkDevTools(roomId, newRoom);\n        const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n        if (shouldConnect) {\n            if (typeof atob === \"undefined\") {\n                if (clientOptions.polyfills?.atob === void 0) {\n                    throw new Error(\"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\");\n                }\n                global.atob = clientOptions.polyfills.atob;\n            }\n            newRoom.connect();\n        }\n        return leaseRoom(newRoomInfo);\n    }\n    function enter(roomId, options2) {\n        const { room, leave: _ } = enterRoom(roomId, options2);\n        return room;\n    }\n    function getRoom(roomId) {\n        const room = roomsById.get(roomId)?.room;\n        return room ? room : null;\n    }\n    function forceLeave(roomId) {\n        const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n        for (const unsub of unsubs){\n            unsub();\n        }\n    }\n    function logout() {\n        authManager.reset();\n        for (const { room } of roomsById.values()){\n            if (!isIdle(room.getStatus())) {\n                room.reconnect();\n            }\n        }\n    }\n    return {\n        logout,\n        // Old, deprecated APIs\n        enter,\n        getRoom,\n        leave: forceLeave,\n        // New, preferred API\n        enterRoom\n    };\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n    if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n        throw new Error(max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`);\n    }\n    return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n    if (value === void 0) return void 0;\n    return checkBounds(\"backgroundKeepAliveTimeout\", value, MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT);\n}\nfunction getThrottle(value) {\n    return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n    return checkBounds(\"lostConnectionTimeout\", value, MIN_LOST_CONNECTION_TIMEOUT, MAX_LOST_CONNECTION_TIMEOUT, RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT);\n}\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n    if (lson instanceof LiveObject) {\n        return {\n            liveblocksType: \"LiveObject\",\n            data: Object.fromEntries(Object.entries(lson.toObject()).flatMap(([key, value])=>value !== void 0 ? [\n                    [\n                        key,\n                        toPlainLson(value)\n                    ]\n                ] : []))\n        };\n    } else if (lson instanceof LiveMap) {\n        return {\n            liveblocksType: \"LiveMap\",\n            data: Object.fromEntries([\n                ...lson\n            ].map(([key, value])=>[\n                    key,\n                    toPlainLson(value)\n                ]))\n        };\n    } else if (lson instanceof LiveList) {\n        return {\n            liveblocksType: \"LiveList\",\n            data: [\n                ...lson\n            ].map((item)=>toPlainLson(item))\n        };\n    } else {\n        return lson;\n    }\n}\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n    const result = {};\n    for(const key in obj){\n        const val = obj[key];\n        if (val !== void 0) {\n            result[key] = lsonToJson(val);\n        }\n    }\n    return result;\n}\nfunction liveObjectToJson(liveObject) {\n    return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n    const result = {};\n    for (const [key, value] of map.entries()){\n        result[key] = lsonToJson(value);\n    }\n    return result;\n}\nfunction lsonListToJson(value) {\n    return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n    return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n    if (value instanceof LiveObject) {\n        return liveObjectToJson(value);\n    } else if (value instanceof LiveList) {\n        return liveListToJson(value);\n    } else if (value instanceof LiveMap) {\n        return liveMapToJson(value);\n    } else if (value instanceof LiveRegister) {\n        return value.data;\n    }\n    if (Array.isArray(value)) {\n        return lsonListToJson(value);\n    } else if (isPlainObject(value)) {\n        return lsonObjectToJson(value);\n    }\n    return value;\n}\nfunction deepLiveify(value) {\n    if (Array.isArray(value)) {\n        return new LiveList(value.map(deepLiveify));\n    } else if (isPlainObject(value)) {\n        const init = {};\n        for(const key in value){\n            const val = value[key];\n            if (val === void 0) {\n                continue;\n            }\n            init[key] = deepLiveify(val);\n        }\n        return new LiveObject(init);\n    } else {\n        return value;\n    }\n}\nfunction patchLiveList(liveList, prev, next) {\n    let i = 0;\n    let prevEnd = prev.length - 1;\n    let nextEnd = next.length - 1;\n    let prevNode = prev[0];\n    let nextNode = next[0];\n    outer: {\n        while(prevNode === nextNode){\n            ++i;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[i];\n            nextNode = next[i];\n        }\n        prevNode = prev[prevEnd];\n        nextNode = next[nextEnd];\n        while(prevNode === nextNode){\n            prevEnd--;\n            nextEnd--;\n            if (i > prevEnd || i > nextEnd) {\n                break outer;\n            }\n            prevNode = prev[prevEnd];\n            nextNode = next[nextEnd];\n        }\n    }\n    if (i > prevEnd) {\n        if (i <= nextEnd) {\n            while(i <= nextEnd){\n                liveList.insert(deepLiveify(next[i]), i);\n                i++;\n            }\n        }\n    } else if (i > nextEnd) {\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    } else {\n        while(i <= prevEnd && i <= nextEnd){\n            prevNode = prev[i];\n            nextNode = next[i];\n            const liveListNode = liveList.get(i);\n            if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n                patchLiveObject(liveListNode, prevNode, nextNode);\n            } else {\n                liveList.set(i, deepLiveify(nextNode));\n            }\n            i++;\n        }\n        while(i <= nextEnd){\n            liveList.insert(deepLiveify(next[i]), i);\n            i++;\n        }\n        let localI = i;\n        while(localI <= prevEnd){\n            liveList.delete(i);\n            localI++;\n        }\n    }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n    if (true) {\n        const nonSerializableValue = findNonSerializableValue(next);\n        if (nonSerializableValue) {\n            error2(`New state path: '${nonSerializableValue.path}' value: '${String(nonSerializableValue.value)}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`);\n            return;\n        }\n    }\n    const value = liveObject.get(key);\n    if (next === void 0) {\n        liveObject.delete(key);\n    } else if (value === void 0) {\n        liveObject.set(key, deepLiveify(next));\n    } else if (prev === next) {\n        return;\n    } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n        patchLiveList(value, prev, next);\n    } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n        patchLiveObject(value, prev, next);\n    } else {\n        liveObject.set(key, deepLiveify(next));\n    }\n}\nfunction patchLiveObject(root, prev, next) {\n    const updates = {};\n    for(const key in next){\n        patchLiveObjectKey(root, key, prev[key], next[key]);\n    }\n    for(const key in prev){\n        if (next[key] === void 0) {\n            root.delete(key);\n        }\n    }\n    if (Object.keys(updates).length > 0) {\n        root.update(updates);\n    }\n}\nfunction getParentsPath(node) {\n    const path = [];\n    while(node.parent.type === \"HasParent\"){\n        if (isLiveList(node.parent.node)) {\n            path.push(node.parent.node._indexOfPosition(node.parent.key));\n        } else {\n            path.push(node.parent.key);\n        }\n        node = node.parent.node;\n    }\n    return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n    return updates.reduce((state2, update)=>legacy_patchImmutableObjectWithUpdate(state2, update), state);\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n    const path = getParentsPath(update.node);\n    return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n    const pathItem = path.pop();\n    if (pathItem === void 0) {\n        switch(update.type){\n            case \"LiveObject\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveObject but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        if (update.updates[key]?.type === \"update\") {\n                            const val = update.node.get(key);\n                            if (val !== void 0) {\n                                newState[key] = lsonToJson(val);\n                            }\n                        } else if (update.updates[key]?.type === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveList\":\n                {\n                    if (!Array.isArray(state)) {\n                        throw new Error(\"Internal: received update on LiveList but state was not an array\");\n                    }\n                    let newState = state.map((x)=>x);\n                    for (const listUpdate of update.updates){\n                        if (listUpdate.type === \"set\") {\n                            newState = newState.map((item, index)=>index === listUpdate.index ? lsonToJson(listUpdate.item) : item);\n                        } else if (listUpdate.type === \"insert\") {\n                            if (listUpdate.index === newState.length) {\n                                newState.push(lsonToJson(listUpdate.item));\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index)\n                                ];\n                            }\n                        } else if (listUpdate.type === \"delete\") {\n                            newState.splice(listUpdate.index, 1);\n                        } else if (listUpdate.type === \"move\") {\n                            if (listUpdate.previousIndex > listUpdate.index) {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.index),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1)\n                                ];\n                            } else {\n                                newState = [\n                                    ...newState.slice(0, listUpdate.previousIndex),\n                                    ...newState.slice(listUpdate.previousIndex + 1, listUpdate.index + 1),\n                                    lsonToJson(listUpdate.item),\n                                    ...newState.slice(listUpdate.index + 1)\n                                ];\n                            }\n                        }\n                    }\n                    return newState;\n                }\n            case \"LiveMap\":\n                {\n                    if (!isJsonObject(state)) {\n                        throw new Error(\"Internal: received update on LiveMap but state was not an object\");\n                    }\n                    const newState = Object.assign({}, state);\n                    for(const key in update.updates){\n                        if (update.updates[key]?.type === \"update\") {\n                            const value = update.node.get(key);\n                            if (value !== void 0) {\n                                newState[key] = lsonToJson(value);\n                            }\n                        } else if (update.updates[key]?.type === \"delete\") {\n                            delete newState[key];\n                        }\n                    }\n                    return newState;\n                }\n        }\n    }\n    if (Array.isArray(state)) {\n        const newArray = [\n            ...state\n        ];\n        newArray[pathItem] = legacy_patchImmutableNode(state[pathItem], path, update);\n        return newArray;\n    } else if (isJsonObject(state)) {\n        const node = state[pathItem];\n        if (node === void 0) {\n            return state;\n        } else {\n            const stateAsObj = state;\n            return {\n                ...stateAsObj,\n                [pathItem]: legacy_patchImmutableNode(node, path, update)\n            };\n        }\n    } else {\n        return state;\n    }\n}\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n    if (xs.length !== ys.length) {\n        return false;\n    }\n    for(let i = 0; i < xs.length; i++){\n        if (!Object.is(xs[i], ys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction shallowObj(objA, objB) {\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    if (keysA.length !== Object.keys(objB).length) {\n        return false;\n    }\n    return keysA.every((key)=>Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key]));\n}\nfunction shallow(a, b) {\n    if (Object.is(a, b)) {\n        return true;\n    }\n    const isArrayA = Array.isArray(a);\n    const isArrayB = Array.isArray(b);\n    if (isArrayA || isArrayB) {\n        if (!isArrayA || !isArrayB) {\n            return false;\n        }\n        return shallowArray(a, b);\n    }\n    return shallowObj(a, b);\n}\n// src/lib/AsyncCache.ts\nvar noop = ()=>{};\nfunction isShallowEqual(a, b) {\n    if (a.isLoading !== b.isLoading || a.data === void 0 !== (b.data === void 0) || a.error === void 0 !== (b.error === void 0)) {\n        return false;\n    } else {\n        return shallow(a.data, b.data) && shallow(a.error, b.error);\n    }\n}\nfunction createCacheItem(key, asyncFunction, options) {\n    const $asyncFunction = async ()=>asyncFunction(key);\n    const context = {\n        isInvalid: true\n    };\n    let state = {\n        isLoading: false\n    };\n    let previousState = {\n        isLoading: false\n    };\n    const eventSource2 = makeEventSource();\n    function notify() {\n        const isEqual = options?.isStateEqual ?? isShallowEqual;\n        if (!isEqual(previousState, state)) {\n            previousState = state;\n            eventSource2.notify(state);\n        }\n    }\n    async function resolve() {\n        if (!context.promise) {\n            return;\n        }\n        try {\n            const data = await context.promise;\n            context.isInvalid = false;\n            state = {\n                isLoading: false,\n                data\n            };\n        } catch (error3) {\n            state = {\n                isLoading: false,\n                data: state.data,\n                error: error3\n            };\n        }\n        context.promise = void 0;\n        notify();\n    }\n    async function revalidate() {\n        context.isInvalid = true;\n        return get();\n    }\n    async function get() {\n        if (context.isInvalid) {\n            if (!context.promise) {\n                context.isInvalid = true;\n                context.promise = $asyncFunction();\n                state = {\n                    isLoading: true,\n                    data: state.data\n                };\n                notify();\n            }\n            await resolve();\n        }\n        return getState();\n    }\n    function getState() {\n        return state;\n    }\n    return {\n        ...eventSource2.observable,\n        get,\n        getState,\n        revalidate\n    };\n}\nfunction createAsyncCache(asyncFunction, options) {\n    const cache = /* @__PURE__ */ new Map();\n    function create(key) {\n        let cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem;\n        }\n        cacheItem = createCacheItem(key, asyncFunction, options);\n        cache.set(key, cacheItem);\n        return cacheItem;\n    }\n    function get(key) {\n        return create(key).get();\n    }\n    function getState(key) {\n        return cache.get(key)?.getState();\n    }\n    function revalidate(key) {\n        return create(key).revalidate();\n    }\n    function subscribe(key, callback) {\n        return create(key).subscribe(callback) ?? noop;\n    }\n    function subscribeOnce(key, callback) {\n        return create(key).subscribeOnce(callback) ?? noop;\n    }\n    function has(key) {\n        return cache.has(key);\n    }\n    function clear() {\n        cache.clear();\n    }\n    return {\n        create,\n        get,\n        getState,\n        revalidate,\n        subscribe,\n        subscribeOnce,\n        has,\n        clear\n    };\n}\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n    let context = {\n        state: \"stopped\",\n        timeoutHandle: null,\n        interval: null,\n        lastScheduledAt: null,\n        remainingInterval: null\n    };\n    function poll() {\n        if (context.state === \"running\") {\n            schedule(context.interval);\n        }\n        void callback();\n    }\n    function schedule(interval) {\n        context = {\n            state: \"running\",\n            interval: context.state !== \"stopped\" ? context.interval : interval,\n            lastScheduledAt: performance.now(),\n            timeoutHandle: setTimeout(poll, interval),\n            remainingInterval: null\n        };\n    }\n    function scheduleRemaining(remaining) {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        context = {\n            state: \"running\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: setTimeout(poll, remaining),\n            remainingInterval: null\n        };\n    }\n    function start(interval) {\n        if (context.state === \"running\") {\n            return;\n        }\n        schedule(interval);\n    }\n    function restart(interval) {\n        stop();\n        start(interval);\n    }\n    function pause() {\n        if (context.state !== \"running\") {\n            return;\n        }\n        clearTimeout(context.timeoutHandle);\n        context = {\n            state: \"paused\",\n            interval: context.interval,\n            lastScheduledAt: context.lastScheduledAt,\n            timeoutHandle: null,\n            remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n        };\n    }\n    function resume() {\n        if (context.state !== \"paused\") {\n            return;\n        }\n        scheduleRemaining(context.remainingInterval);\n    }\n    function stop() {\n        if (context.state === \"stopped\") {\n            return;\n        }\n        if (context.timeoutHandle) {\n            clearTimeout(context.timeoutHandle);\n        }\n        context = {\n            state: \"stopped\",\n            interval: null,\n            lastScheduledAt: null,\n            timeoutHandle: null,\n            remainingInterval: null\n        };\n    }\n    return {\n        start,\n        restart,\n        pause,\n        resume,\n        stop\n    };\n}\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n    if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n        return JSON.stringify(object, ...args);\n    }\n    const sortedObject = Object.keys(object).sort().reduce((sortedObject2, key)=>{\n        sortedObject2[key] = object[key];\n        return sortedObject2;\n    }, {});\n    return JSON.stringify(sortedObject, ...args);\n}\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUVBLGlCQUFpQjtBQUNqQixJQUFJQyxXQUFXO0FBQ2YsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxhQUFhO0FBRWpCLHdCQUF3QjtBQUN4QixJQUFJQyxJQUFJLE9BQU9DLGVBQWUsY0FBY0EsYUFBYSxNQUE2QixHQUFHQyxDQUFNQSxHQUFHLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxDQUFDO0FBQzVJLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLFFBQVE7QUFDWixTQUFTQyxNQUFNQyxHQUFHO0lBQ2hCLElBQUlDLEtBQXFDLEVBQUUsRUFFMUMsTUFBTTtRQUNMLE1BQU0sSUFBSUUsTUFBTUg7SUFDbEI7QUFDRjtBQUNBLFNBQVNJLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ2pELE1BQU1DLFFBQVFDLE9BQU9DLEdBQUcsQ0FBQ0w7SUFDekIsTUFBTU0sZUFBZUosWUFBWSxDQUFDLEVBQUVELGNBQWMsTUFBTSxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEdBQUdELGNBQWM7SUFDekYsSUFBSSxDQUFDZCxDQUFDLENBQUNnQixNQUFNLEVBQUU7UUFDYmhCLENBQUMsQ0FBQ2dCLE1BQU0sR0FBR0c7SUFDYixPQUFPLElBQUluQixDQUFDLENBQUNnQixNQUFNLEtBQUtHLGNBQWMsQ0FDdEMsT0FBTztRQUNMLE1BQU1YLE1BQU07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LGlCQUFpQjtZQUNqQkYsZUFBZTtZQUNmRyxtQkFBbUI7UUFDckI7SUFDRjtJQUNBLE9BQU87UUFDTDdoQztRQUNBbWlDO1FBQ0FqbkM7UUFDQSsrQjtRQUNBLzVCO0lBQ0Y7QUFDRjtBQUVBLHVCQUF1QjtBQUN2QixTQUFTd0MsVUFBVTAvQixNQUFNLEVBQUUsR0FBR3BsQyxJQUFJO0lBQ2hDLElBQUksT0FBT29sQyxXQUFXLFlBQVlBLFdBQVcsUUFBUWorQixNQUFNQyxPQUFPLENBQUNnK0IsU0FBUztRQUMxRSxPQUFPMy9CLEtBQUtDLFNBQVMsQ0FBQzAvQixXQUFXcGxDO0lBQ25DO0lBQ0EsTUFBTXFsQyxlQUFlcnFDLE9BQU9vTyxJQUFJLENBQUNnOEIsUUFBUXJlLElBQUksR0FBR25NLE1BQU0sQ0FDcEQsQ0FBQzBxQixlQUFlbGpDO1FBQ2RrakMsYUFBYSxDQUFDbGpDLElBQUksR0FBR2dqQyxNQUFNLENBQUNoakMsSUFBSTtRQUNoQyxPQUFPa2pDO0lBQ1QsR0FDQSxDQUFDO0lBRUgsT0FBTzcvQixLQUFLQyxTQUFTLENBQUMyL0IsaUJBQWlCcmxDO0FBQ3pDO0FBRUEsZUFBZTtBQUNmekQsWUFBWWYsVUFBVUMsYUFBYUM7QUFvRGpDLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5tanM/ODcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjEuOS43XCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnROZXZlcihfdmFsdWUsIGVycm1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIGVycm1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgZXJyLm5hbWUgPSBcIkFzc2VydGlvbiBmYWlsdXJlXCI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBubih2YWx1ZSwgZXJybXNnID0gXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBub24tbnVsbGFibGVcIikge1xuICBhc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCwgZXJybXNnKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvbGliL2NvbnRyb2xsZWRQcm9taXNlLnRzXG5mdW5jdGlvbiBjb250cm9sbGVkUHJvbWlzZSgpIHtcbiAgbGV0IGZsYWdnZXI7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgZmxhZ2dlciA9IHJlcztcbiAgfSk7XG4gIGlmICghZmxhZ2dlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtwcm9taXNlLCBmbGFnZ2VyXTtcbn1cblxuLy8gc3JjL2xpYi9FdmVudFNvdXJjZS50c1xuZnVuY3Rpb24gbWFrZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBfb25ldGltZU9ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IF9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgX2J1ZmZlciA9IG51bGw7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIF9idWZmZXIgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmIChfYnVmZmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgX2J1ZmZlcikge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gICAgX2J1ZmZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgX29ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vbmV0aW1lT2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZSkge1xuICAgIGxldCB1bnN1YjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgPT09IHZvaWQgMCB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgcmVzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB1bnN1Yj8uKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU9yQnVmZmVyKGV2ZW50KSB7XG4gICAgaWYgKF9idWZmZXIgIT09IG51bGwpIHtcbiAgICAgIF9idWZmZXIucHVzaChldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gX29uZXRpbWVPYnNlcnZlcnMuc2l6ZSArIF9vYnNlcnZlcnMuc2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFByaXZhdGUvaW50ZXJuYWwgY29udHJvbCBvdmVyIGV2ZW50IGVtaXNzaW9uXG4gICAgbm90aWZ5OiBub3RpZnlPckJ1ZmZlcixcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBjbGVhcixcbiAgICBjb3VudCxcbiAgICB3YWl0VW50aWwsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5jdXJyID0gaW5pdGlhbENvbnRleHQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuY3VycixcbiAgICAgIHBhdGNoKHBhdGNoKSB7XG4gICAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgICAgc2VsZi5jdXJyID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi5jdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzdGF0ZSwgd2hpY2ggaXMgZGVmaW5lZCBieSB0aGUgZmlyc3QgY2FsbCBtYWRlIHRvXG4gICAqIC5hZGRTdGF0ZSgpLlxuICAgKi9cbiAgZ2V0IGluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgbWFjaGluZSBoYXMgYWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDEgLyogU1RBUlRFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuZW50ZXIobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzdGF0ZSBtYWNoaW5lLiBTdG9wcGluZyB0aGUgc3RhdGUgbWFjaGluZSB3aWxsIGNhbGwgZXhpdFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIGJ1dCBub3QgZW50ZXIgYSBuZXcgc3RhdGUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuZXhpdChudWxsKTtcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDIgLyogU1RPUFBFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZW50ZXJGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2xlYW51cFN0YWNrID0gW107XG4gICAgdGhpcy5rbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbmV3IFNhZmVDb250ZXh0KGluaXRpYWxDb250ZXh0KTtcbiAgICB0aGlzLmV2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbFRyYW5zaXRpb246IHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ub2JzZXJ2YWJsZSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLmV2ZW50SHViLndpbGxFeGl0U3RhdGUub2JzZXJ2YWJsZSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5vYnNlcnZhYmxlXG4gICAgfTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVzLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlcihuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lbnRlckZucy5oYXMobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVE9ETyBXZSBfY3VycmVudGx5XyBkb24ndCBzdXBwb3J0IG11bHRpcGxlIC5vbkVudGVycygpIGZvciB0aGUgc2FtZVxuICAgICAgICAvLyBzdGF0ZSwgYnV0IHRoaXMgaXMgbm90IGEgZnVuZGFtZW50YWwgbGltaXRhdGlvbi4gSnVzdCBub3RcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgeWV0LiBJZiB3ZSB3YW50ZWQgdG8sIHdlIGNvdWxkIG1ha2UgdGhpcyBhbiBhcnJheS5cbiAgICAgICAgYGVudGVyL2V4aXQgZnVuY3Rpb24gZm9yICR7bmFtZU9yUGF0dGVybn0gYWxyZWFkeSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVudGVyRm5zLnNldChuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyQXN5bmMobmFtZU9yUGF0dGVybiwgcHJvbWlzZUZuLCBvbk9LLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIHRoaXMub25FbnRlcihuYW1lT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAobmFtZU9yUGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWVPclBhdHRlcm4uZW5kc1dpdGgoXCIuKlwiKSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gbmFtZU9yUGF0dGVybi5zbGljZSgwLCAtMSk7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lT3JQYXR0ZXJuO1xuICAgICAgaWYgKHRoaXMuc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZXMgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeShuYW1lT3JQYXR0ZXJuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbGwgYWxsb3dlZCBvdXRnb2luZyB0cmFuc2l0aW9ucyBmb3IgYSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHRhcmdldHMgZm9yIGVhY2ggZXZlbnQgY2FuIGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgKiBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uIFRoZXNlIGZ1bmN0aW9ucyBjYW4gbG9vayBhdCB0aGUgYGV2ZW50YCBvclxuICAgKiBgY29udGV4dGAgcGFyYW1zIHRvIGNvbmRpdGlvbmFsbHkgZGVjaWRlIHdoaWNoIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvblxuICAgKiB0by5cbiAgICpcbiAgICogSWYgeW91IHNldCBpdCB0byBgbnVsbGAsIHRoZW4gdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBleHBsaWNpdGx5IGZvcmJpZGRlblxuICAgKiBhbmQgdGhyb3cgYW4gZXJyb3IuIElmIHlvdSBkb24ndCBkZWZpbmUgYSB0YXJnZXQgZm9yIGEgdHJhbnNpdGlvbiwgdGhlblxuICAgKiBzdWNoIGV2ZW50cyB3aWxsIGdldCBpZ25vcmVkLlxuICAgKi9cbiAgYWRkVHJhbnNpdGlvbnMobmFtZU9yUGF0dGVybiwgbWFwcGluZykge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzcmNTdGF0ZSBvZiB0aGlzLmdldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlKTtcbiAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5zZXQoc3JjU3RhdGUsIG1hcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFt0eXBlLCB0YXJnZXRfXSBvZiBPYmplY3QuZW50cmllcyhtYXBwaW5nKSkge1xuICAgICAgICBpZiAobWFwLmhhcyh0eXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUcnlpbmcgdG8gc2V0IHRyYW5zaXRpb24gXCIke3R5cGV9XCIgb24gXCIke3NyY1N0YXRlfVwiICh2aWEgXCIke25hbWVPclBhdHRlcm59XCIpLCBidXQgYSB0cmFuc2l0aW9uIGFscmVhZHkgZXhpc3RzIHRoZXJlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldF87XG4gICAgICAgIHRoaXMua25vd25FdmVudFR5cGVzLmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgICAgICAgbWFwLnNldCh0eXBlLCB0YXJnZXRGbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYC5hZGRUcmFuc2l0aW9uKClgLCBidXQgdGFrZXMgYW4gKGFub255bW91cykgdHJhbnNpdGlvbiB3aGVuZXZlciB0aGVcbiAgICogdGltZXIgZmlyZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0byB0YWtlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi4gSWYgaW4gdGhlIG1lYW4gdGltZSwgYW5vdGhlciB0cmFuc2l0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgVGhlIHRhcmdldCBzdGF0ZSB0byBnbyB0by5cbiAgICovXG4gIGFkZFRpbWVkVHJhbnNpdGlvbihzdGF0ZU9yUGF0dGVybiwgYWZ0ZXIyLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKHN0YXRlT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBjb25zdCBtcyA9IHR5cGVvZiBhZnRlcjIgPT09IFwiZnVuY3Rpb25cIiA/IGFmdGVyMih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQpIDogYWZ0ZXIyO1xuICAgICAgY29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiVElNRVJcIiB9LCB0YXJnZXQpO1xuICAgICAgfSwgbXMpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldFRhcmdldEZuKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQodGhpcy5jdXJyZW50U3RhdGUpPy5nZXQoZXZlbnROYW1lKTtcbiAgfVxuICAvKipcbiAgICogRXhpdHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLlxuICAgKiBDYWxsIHRoaXMgYmVmb3JlIGNoYW5naW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWxzIERlZmluZXMgaG93IG1hbnkgXCJsZXZlbHNcIiBvZiBuZXN0aW5nIHdpbGwgYmVcbiAgICogZXhpdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IHRyYW5zaXRpb24gZnJvbSBgZm9vLmJhci5xdXhgIHRvXG4gICAqIGBmb28uYmFyLmJhemAsIHRoZW4gdGhlIGxldmVsIGlzIDEuIEJ1dCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGBmb28uYmFyLnF1eGAgdG8gYGJsYS5ibGFgLCB0aGVuIHRoZSBsZXZlbCBpcyAzLlxuICAgKiBJZiBgbnVsbGAsIGl0IHdpbGwgZXhpdCBhbGwgbGV2ZWxzLlxuICAgKi9cbiAgZXhpdChsZXZlbHMpIHtcbiAgICB0aGlzLmV2ZW50SHViLndpbGxFeGl0U3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGxldmVscyA9IGxldmVscyA/PyB0aGlzLmNsZWFudXBTdGFjay5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnBvcCgpPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3Nhcnkgb25FbnRlciBoYW5kbGVycy5cbiAgICogQ2FsbCB0aGlzIGRpcmVjdGx5IF9hZnRlcl8gc2V0dGluZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICovXG4gIGVudGVyKGxldmVscykge1xuICAgIGNvbnN0IGVudGVyUGF0dGVybnMgPSBwYXR0ZXJucyhcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLFxuICAgICAgbGV2ZWxzID8/IHRoaXMuY3VycmVudFN0YXRlLnNwbGl0KFwiLlwiKS5sZW5ndGggKyAxXG4gICAgKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBlbnRlclBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRm4gPSB0aGlzLmVudGVyRm5zLmdldChwYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuID0gZW50ZXJGbj8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXBGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChjbGVhbnVwRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50SHViLmRpZEVudGVyU3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIG1hY2hpbmUsIHdoaWNoIG1heSBjYXVzZSBhbiBpbnRlcm5hbCBzdGF0ZVxuICAgKiB0cmFuc2l0aW9uIHRvIGhhcHBlbi4gV2hlbiB0aGF0IGhhcHBlbnMsIHdpbGwgdHJpZ2dlciBzaWRlIGVmZmVjdHMuXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmtub3duRXZlbnRUeXBlcy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50LnR5cGUpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDIgLyogU1RPUFBFRCAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRGbiA9IHRoaXMuZ2V0VGFyZ2V0Rm4oZXZlbnQudHlwZSk7XG4gICAgaWYgKHRhcmdldEZuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24oZXZlbnQsIHRhcmdldEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICB0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLmV2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldEZuKGV2ZW50LCB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQpO1xuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgbGV0IGVmZmVjdHMgPSB2b2lkIDA7XG4gICAgaWYgKG5leHRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXh0VGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0LnRhcmdldDtcbiAgICAgIGVmZmVjdHMgPSBBcnJheS5pc0FycmF5KG5leHRUYXJnZXQuZWZmZWN0KSA/IG5leHRUYXJnZXQuZWZmZWN0IDogW25leHRUYXJnZXQuZWZmZWN0XTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlcy5oYXMobmV4dFN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5leHQgc3RhdGUgbmFtZTogJHtKU09OLnN0cmluZ2lmeShuZXh0U3RhdGUpfWApO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50SHViLndpbGxUcmFuc2l0aW9uLm5vdGlmeSh7IGZyb206IG9sZFN0YXRlLCB0bzogbmV4dFN0YXRlIH0pO1xuICAgIGNvbnN0IFt1cCwgZG93bl0gPSBkaXN0YW5jZSh0aGlzLmN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICBpZiAodXAgPiAwKSB7XG4gICAgICB0aGlzLmV4aXQodXApO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoZWZmZWN0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBlZmZlY3RzO1xuICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHNUb1J1bikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGVmZmVjdChwYXRjaGFibGVDb250ZXh0LCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoYWJsZUNvbnRleHQucGF0Y2goZWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZG93biA+IDApIHtcbiAgICAgIHRoaXMuZW50ZXIoZG93bik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG5mdW5jdGlvbiByYWlzZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IgIT09IG51bGwgJiYgdHlwZW9mIGJsb2IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJsb2IpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gZW50cmllcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iaik7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbWlsbGlzLCBlcnJtc2cpIHtcbiAgbGV0IHRpbWVySUQ7XG4gIGNvbnN0IHRpbWVyJCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lcklEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGVycm1zZykpO1xuICAgIH0sIG1pbGxpcyk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lciRdKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lcklEKSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJFSkVDVF9TVE9SQUdFX09QXCJdID0gMjk5XSA9IFwiUkVKRUNUX1NUT1JBR0VfT1BcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMF0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0NSRUFURURcIl0gPSA0MDBdID0gXCJUSFJFQURfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRPS0VOX0VYUElSRURcIl0gPSA0MTA5XSA9IFwiVE9LRU5fRVhQSVJFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX1dJVEhPVVRfUkVUUllcIl0gPSA0OTk5XSA9IFwiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiO1xuICByZXR1cm4gV2Vic29ja2V0Q2xvc2VDb2RlczI7XG59KShXZWJzb2NrZXRDbG9zZUNvZGVzIHx8IHt9KTtcbmZ1bmN0aW9uIHNob3VsZERpc2Nvbm5lY3QoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gNDk5OSAvKiBDTE9TRV9XSVRIT1VUX1JFVFJZICovIHx8IGNvZGUgPj0gNGUzICYmIGNvZGUgPCA0MTAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDEwMCAmJiBjb2RlIDwgNDIwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDEzIC8qIFRSWV9BR0FJTl9MQVRFUiAqLyB8fCBjb2RlID49IDQyMDAgJiYgY29kZSA8IDQzMDA7XG59XG5cbi8vIHNyYy9jb25uZWN0aW9uLnRzXG5mdW5jdGlvbiBpc0lkbGUoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIG5ld1RvTGVnYWN5U3RhdHVzKHN0YXR1cykge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgcmV0dXJuIFwib3BlblwiO1xuICAgIGNhc2UgXCJyZWNvbm5lY3RpbmdcIjpcbiAgICAgIHJldHVybiBcInVuYXZhaWxhYmxlXCI7XG4gICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgcmV0dXJuIFwiZmFpbGVkXCI7XG4gICAgY2FzZSBcImluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJjbG9zZWRcIjtcbiAgfVxufVxuZnVuY3Rpb24gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdGUgPSBtYWNoaW5lLmN1cnJlbnRTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJAb2suY29ubmVjdGVkXCI6XG4gICAgY2FzZSBcIkBvay5hd2FpdGluZy1wb25nXCI6XG4gICAgICByZXR1cm4gXCJjb25uZWN0ZWRcIjtcbiAgICBjYXNlIFwiQGlkbGUuaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIGNhc2UgXCJAYXV0aC5idXN5XCI6XG4gICAgY2FzZSBcIkBhdXRoLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYnVzeVwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBpZGxlLnpvbWJpZVwiOlxuICAgICAgcmV0dXJuIG1hY2hpbmUuY29udGV4dC5zdWNjZXNzQ291bnQgPiAwID8gXCJyZWNvbm5lY3RpbmdcIiA6IFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJAaWRsZS5mYWlsZWRcIjpcbiAgICAgIHJldHVybiBcImRpc2Nvbm5lY3RlZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoc3RhdGUsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgfVxufVxudmFyIEJBQ0tPRkZfREVMQVlTID0gWzI1MCwgNTAwLCAxZTMsIDJlMywgNGUzLCA4ZTMsIDFlNF07XG52YXIgUkVTRVRfREVMQVkgPSBCQUNLT0ZGX0RFTEFZU1swXSAtIDE7XG52YXIgQkFDS09GRl9ERUxBWVNfU0xPVyA9IFsyZTMsIDNlNCwgNmU0LCAzZTVdO1xudmFyIEhFQVJUQkVBVF9JTlRFUlZBTCA9IDNlNDtcbnZhciBQT05HX1RJTUVPVVQgPSAyZTM7XG52YXIgQVVUSF9USU1FT1VUID0gMWU0O1xudmFyIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQgPSAxZTQ7XG52YXIgU3RvcFJldHJ5aW5nID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKHJlYXNvbik7XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cyA9IEJBQ0tPRkZfREVMQVlTKSB7XG4gIHJldHVybiBkZWxheXMuZmluZCgoZGVsYXkpID0+IGRlbGF5ID4gY3VycmVudERlbGF5KSA/PyBkZWxheXNbZGVsYXlzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5KSB9KTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZU19TTE9XKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U3VjY2Vzc0NvdW50KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7IHN1Y2Nlc3NDb3VudDogMCB9KTtcbn1cbmZ1bmN0aW9uIGxvZyhsZXZlbCwgbWVzc2FnZSkge1xuICBjb25zdCBsb2dnZXIgPSBsZXZlbCA9PT0gMiAvKiBFUlJPUiAqLyA/IGVycm9yMiA6IGxldmVsID09PSAxIC8qIFdBUk4gKi8gPyB3YXJuIDogKFxuICAgIC8qIGJsYWNrIGhvbGUgKi9cbiAgICAoKSA9PiB7XG4gICAgfVxuICApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxvZ2dlcihtZXNzYWdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGUpIHtcbiAgY29uc3QgY29ubiA9IFwiQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXJcIjtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB3YXJuKGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC4gJHtTdHJpbmcoZSl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGlzQ2xvc2VFdmVudChlKSA/IGAke2Nvbm59IGNsb3NlZCBwcmVtYXR1cmVseSAoY29kZTogJHtlLmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmAgOiBgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBsb2dDbG9zZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlciBjbG9zZWQgKGNvZGU6ICR7ZXZlbnQuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgb25NZXNzYWdlLnBhdXNlKCk7XG4gIGNvbnN0IG9uTGl2ZWJsb2Nrc0Vycm9yID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGZpcmVFcnJvckV2ZW50KGVycm1zZywgZXJyY29kZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKGVycm1zZywgZXJyY29kZSk7XG4gICAgICBvbkxpdmVibG9ja3NFcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0ge1xuICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICBhdXRoVmFsdWU6IG51bGwsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgfTtcbiAgY29uc3QgbWFjaGluZSA9IG5ldyBGU00oaW5pdGlhbENvbnRleHQpLmFkZFN0YXRlKFwiQGlkbGUuaW5pdGlhbFwiKS5hZGRTdGF0ZShcIkBpZGxlLmZhaWxlZFwiKS5hZGRTdGF0ZShcIkBpZGxlLnpvbWJpZVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJ1c3lcIikuYWRkU3RhdGUoXCJAYXV0aC5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYnVzeVwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAb2suY29ubmVjdGVkXCIpLmFkZFN0YXRlKFwiQG9rLmF3YWl0aW5nLXBvbmdcIik7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCIqXCIsIHtcbiAgICBSRUNPTk5FQ1Q6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgcmVzZXRTdWNjZXNzQ291bnRdXG4gICAgfSxcbiAgICBESVNDT05ORUNUOiBcIkBpZGxlLmluaXRpYWxcIlxuICB9KTtcbiAgbWFjaGluZS5vbkVudGVyKFwiQGlkbGUuKlwiLCByZXNldFN1Y2Nlc3NDb3VudCkuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS4qXCIsIHtcbiAgICBDT05ORUNUOiAoXywgY3R4KSA9PiAoXG4gICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlIGEga25vd24gYXV0aFZhbHVlLCB0cnkgdG8gcmVjb25uZWN0IHRvIHRoZSBzb2NrZXQgZGlyZWN0bHksXG4gICAgICAvLyBvdGhlcndpc2UsIHRyeSB0byBvYnRhaW4gYSBuZXcgYXV0aFZhbHVlXG4gICAgICBjdHguYXV0aFZhbHVlICE9PSBudWxsID8gXCJAY29ubmVjdGluZy5idXN5XCIgOiBcIkBhdXRoLmJ1c3lcIlxuICAgIClcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAYXV0aC5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBhdXRoLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBhdXRoLmJ1c3lcIixcbiAgICAoKSA9PiB3aXRoVGltZW91dChcbiAgICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUoKSxcbiAgICAgIEFVVEhfVElNRU9VVCxcbiAgICAgIFwiVGltZWQgb3V0IGR1cmluZyBhdXRoXCJcbiAgICApLFxuICAgIC8vIE9uIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIGF1dGhWYWx1ZTogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIEF1dGggZmFpbGVkXG4gICAgKGZhaWxlZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheSxcbiAgICAgICAgICBsb2coXG4gICAgICAgICAgICAyIC8qIEVSUk9SICovLFxuICAgICAgICAgICAgYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IGZhaWxlZEV2ZW50LnJlYXNvbi5tZXNzYWdlIDogU3RyaW5nKGZhaWxlZEV2ZW50LnJlYXNvbil9YFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IG9uU29ja2V0RXJyb3IgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0VSUk9SXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldENsb3NlID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRNZXNzYWdlID0gKGV2ZW50KSA9PiBldmVudC5kYXRhID09PSBcInBvbmdcIiA/IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiUE9OR1wiIH0pIDogb25NZXNzYWdlLm5vdGlmeShldmVudCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duU29ja2V0KHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBjb25uZWN0aW5nLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vXG4gICAgLy8gVXNlIHRoZSBcImNyZWF0ZVNvY2tldFwiIGRlbGVnYXRlIGZ1bmN0aW9uIChwcm92aWRlZCB0byB0aGVcbiAgICAvLyBNYW5hZ2VkU29ja2V0KSB0byBjcmVhdGUgdGhlIGFjdHVhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAvLyBUaGVuLCBzZXQgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLCBhbmQgd2FpdCBmb3IgdGhlXG4gICAgLy8gXCJvcGVuXCIgZXZlbnQgdG8gb2NjdXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBcIm9wZW5cIiBldmVudCBoYXBwZW5zLCB3ZSdyZSByZWFkeSB0byB0cmFuc2l0aW9uIHRvIHRoZVxuICAgIC8vIE9LIHN0YXRlLiBUaGlzIGlzIGRvbmUgYnkgcmVzb2x2aW5nIHRoZSBQcm9taXNlLlxuICAgIC8vXG4gICAgYXN5bmMgKGN0eCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdCQgPSBuZXcgUHJvbWlzZShcbiAgICAgICAgKHJlc29sdmUsIHJlaikgPT4ge1xuICAgICAgICAgIGlmIChjdHguYXV0aFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIGF1dGhWYWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gZGVsZWdhdGVzLmNyZWF0ZVNvY2tldChjdHguYXV0aFZhbHVlKTtcbiAgICAgICAgICBmdW5jdGlvbiByZWplY3QoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgW2FjdG9yJCwgZGlkUmVjZWl2ZUFjdG9yXSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gd2FpdEZvckFjdG9ySWQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlck1zZyA9IHRyeVBhcnNlSnNvbihldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJNc2c/LnR5cGUgPT09IDEwNCAvKiBST09NX1NUQVRFICovKSB7XG4gICAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdm9pZCBhY3RvciQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW3NvY2tldCwgdW5zdWJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHdpdGhUaW1lb3V0KFxuICAgICAgICBjb25uZWN0JCxcbiAgICAgICAgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCxcbiAgICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIHdlYnNvY2tldCBjb25uZWN0aW9uXCJcbiAgICAgICkudGhlbihcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUGFydCAzOlxuICAgICAgICAvLyBCeSBub3csIG91ciBcIm9wZW5cIiBldmVudCBoYXMgZmlyZWQsIGFuZCB0aGUgcHJvbWlzZSBoYXMgYmVlblxuICAgICAgICAvLyByZXNvbHZlZC4gVHdvIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gVGhlIGhhcHB5IHBhdGguIE1vc3QgbGlrZWx5LlxuICAgICAgICAvLyAyLiBVaC1vaC4gQSBwcmVtYXR1cmUgY2xvc2UvZXJyb3IgZXZlbnQgaGFzIGJlZW4gb2JzZXJ2ZWQuIExldCdzXG4gICAgICAgIC8vICAgIHJlamVjdCB0aGUgcHJvbWlzZSBhZnRlciBhbGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFueSBjbG9zZS9lcnJvciBldmVudCB0aGF0IHdpbGwgZ2V0IHNjaGVkdWxlZCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIG9ud2FyZHMsIHdpbGwgYmUgY2F1Z2h0IGluIHRoZSBPSyBzdGF0ZSwgYW5kIGRlYWx0IHdpdGhcbiAgICAgICAgLy8gYWNjb3JkaW5nbHkuXG4gICAgICAgIC8vXG4gICAgICAgIChbc29ja2V0LCB1bnN1Yl0pID0+IHtcbiAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25MaXZlYmxvY2tzRXJyb3I6IG9uTGl2ZWJsb2Nrc0Vycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMubWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5jbGVhbnVwcyA9IGNsZWFudXBzO1xuICB9XG4gIGdldExlZ2FjeVN0YXR1cygpIHtcbiAgICByZXR1cm4gbmV3VG9MZWdhY3lTdGF0dXModGhpcy5nZXRTdGF0dXMoKSk7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0ZWRTY29wZSwgcm9vbUlkKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gZXhwaXJ5VGltZXNbaV07XG4gICAgICBpZiAoZXhwaXJlc0F0IDw9IG5vdykge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBleHBpcnlUaW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgICAgZm9yIChjb25zdCBbcmVzb3VyY2UsIHNjb3Blc10gb2YgT2JqZWN0LmVudHJpZXModG9rZW4ucGFyc2VkLnBlcm1zKSkge1xuICAgICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgcm9vbUlkLnN0YXJ0c1dpdGgocmVzb3VyY2UucmVwbGFjZShcIipcIiwgXCJcIikpIHx8IHJvb21JZCA9PT0gcmVzb3VyY2UgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdXRoUmVxdWVzdChyb29tSWQpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiByb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgaWYgKHNlZW5Ub2tlbnMuaGFzKHBhcnNlZC5yYXcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUaGUgc2FtZSBMaXZlYmxvY2tzIGF1dGggdG9rZW4gd2FzIGlzc3VlZCBmcm9tIHRoZSBiYWNrZW5kIGJlZm9yZS4gQ2FjaGluZyBMaXZlYmxvY2tzIHRva2VucyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhyb29tSWQpO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLnRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0ZWRTY29wZSwgcm9vbUlkKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdGVkU2NvcGUsIHJvb21JZCk7XG4gICAgaWYgKGNhY2hlZFRva2VuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuOiBjYWNoZWRUb2tlbiB9O1xuICAgIH1cbiAgICBsZXQgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KHJvb21JZCk7XG4gICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJvb21JZCk7XG4gICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyb29tSWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gyLCBlbmRwb2ludCwgYm9keSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaDIoZW5kcG9pbnQsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICB9KTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICBjb25zdCByZWFzb24gPSBgJHsoYXdhaXQgcmVzLnRleHQoKSkudHJpbSgpIHx8IFwicmVhc29uIG5vdCBwcm92aWRlZCBpbiBhdXRoIHJlc3BvbnNlXCJ9ICgke3Jlcy5zdGF0dXN9IHJldHVybmVkIGJ5IFBPU1QgJHtlbmRwb2ludH0pYDtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxIHx8IHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhgVW5hdXRob3JpemVkOiAke3JlYXNvbn1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXV0aGVudGljYXRlOiAke3JlYXNvbn1gKTtcbiAgICB9XG4gIH1cbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIi4gJHtTdHJpbmcoXG4gICAgICAgIGVyXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSB8fCB0eXBlb2YgZGF0YS50b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugb2YgdGhlIGZvcm0gXFxgeyB0b2tlbjogXCIuLi5cIiB9XFxgIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGRhdGFcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgY29uc3QgeyB0b2tlbiB9ID0gZGF0YTtcbiAgcmV0dXJuIHsgdG9rZW4gfTtcbn1cblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdFwiOiB7XG4gICAgICAgIGFjdGl2YXRlQnJpZGdlKHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvb21JZCBvZiBnZXRBbGxSb29tcygpKSB7XG4gICAgICAgICAgc2VuZFRvUGFuZWwoe1xuICAgICAgICAgICAgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY2xpZW50VmVyc2lvbjogVkVSU0lPTlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcIndha2UtdXAtZGV2dG9vbHNcIiB9LCB7IGZvcmNlOiB0cnVlIH0pO1xufVxudmFyIHVuc3Vic0J5Um9vbUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BTeW5jU3RyZWFtKHJvb21JZCkge1xuICBjb25zdCB1bnN1YnMgPSB1bnN1YnNCeVJvb21JZC5nZXQocm9vbUlkKSA/PyBbXTtcbiAgdW5zdWJzQnlSb29tSWQuZGVsZXRlKHJvb21JZCk7XG4gIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgdW5zdWIoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhcnRTeW5jU3RyZWFtKHJvb20pIHtcbiAgc3RvcFN5bmNTdHJlYW0ocm9vbS5pZCk7XG4gIGZ1bGxTeW5jKHJvb20pO1xuICB1bnN1YnNCeVJvb21JZC5zZXQocm9vbS5pZCwgW1xuICAgIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSksXG4gICAgLy8gV2hlbiBzdG9yYWdlIGluaXRpYWxpemVzLCBzZW5kIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgc3RvcmFnZSB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgc3RvcmFnZSByb290XG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZS5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbS5fX2ludGVybmFsLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbS5fX2ludGVybmFsLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb20uX19pbnRlcm5hbC5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb20uX19pbnRlcm5hbC5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keVRleHQoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHVybC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHJldHVybiBcImh0dHBzOi8vXCIgKyB1cmw7XG4gIH1cbiAgcmV0dXJuO1xufVxudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiBjaGlsZHJlbixcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQsXG4gIGxpbms6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50RGF0YShkYXRhKSB7XG4gIGNvbnN0IGVkaXRlZEF0ID0gZGF0YS5lZGl0ZWRBdCA/IG5ldyBEYXRlKGRhdGEuZWRpdGVkQXQpIDogdm9pZCAwO1xuICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gIGNvbnN0IHJlYWN0aW9ucyA9IGRhdGEucmVhY3Rpb25zLm1hcCgocmVhY3Rpb24pID0+ICh7XG4gICAgLi4ucmVhY3Rpb24sXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShyZWFjdGlvbi5jcmVhdGVkQXQpXG4gIH0pKTtcbiAgaWYgKGRhdGEuYm9keSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0LFxuICAgICAgZGVsZXRlZEF0XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGRhdGEudXBkYXRlZEF0ID8gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpIDogdm9pZCAwO1xuICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5cbi8vIHNyYy9jb21tZW50cy9pbmRleC50c1xuZnVuY3Rpb24gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50c0FwaShyb29tSWQsIGdldEF1dGhWYWx1ZSwgY29uZmlnKSB7XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbihlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBcGkocm9vbUlkLCBlbmRwb2ludCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIGxldCBlcnJvcjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQXBpKHJvb21JZDIsIGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZ2V0QXV0aFZhbHVlKCk7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAvdjIvYy9yb29tcy8ke2VuY29kZVVSSUNvbXBvbmVudChyb29tSWQyKX0ke2VuZHBvaW50fWAsXG4gICAgICBjb25maWcuYmFzZVVybFxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Z2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkcyhvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFwaShyb29tSWQsIFwiL3RocmVhZHMvc2VhcmNoXCIsIHtcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLi4ub3B0aW9ucz8ucXVlcnk/Lm1ldGFkYXRhICYmIHsgbWV0YWRhdGE6IG9wdGlvbnMucXVlcnkubWV0YWRhdGEgfVxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiBqc29uLmRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWRzLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGhyZWFkKHtcbiAgICBtZXRhZGF0YSxcbiAgICBib2R5LFxuICAgIGNvbW1lbnRJZCxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgXCIvdGhyZWFkc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50OiB7XG4gICAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L21ldGFkYXRhYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50c2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5XG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWRcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBjb25zdCByZWFjdGlvbiA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9L3JlYWN0aW9uc2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtb2ppIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24oe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX0vcmVhY3Rpb25zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtb2ppKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VGhyZWFkcyxcbiAgICBjcmVhdGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudCxcbiAgICBhZGRSZWFjdGlvbixcbiAgICByZW1vdmVSZWFjdGlvblxuICB9O1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sID8gdGhpcy5fX3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9faWQgfHwgdGhpcy5fX3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy5fX2lkID0gaWQ7XG4gICAgdGhpcy5fX3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy5fX3Bvb2wgJiYgdGhpcy5fX2lkKSB7XG4gICAgICB0aGlzLl9fcG9vbC5kZWxldGVOb2RlKHRoaXMuX19pZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX19wb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2xpYi9uYW5vaWQudHNcbmZ1bmN0aW9uIG5hbm9pZChsZW5ndGggPSA3KSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSwuLztbXX4hQCMkJSYqKClfKz0tXCI7XG4gIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGggfSxcbiAgICAoKSA9PiBhbHBoYWJldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKSlcbiAgKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5fZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihpdGVtcyA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBwb3NpdGlvbiA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbWFrZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywgbmV3UG9zaXRpb24pO1xuICAgICAgdGhpcy5faXRlbXMucHVzaChub2RlKTtcbiAgICAgIHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGlzdCA9IG5ldyBfTGl2ZUxpc3QoKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy5faXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFJlbW90ZShvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGRlbGV0ZWRJZCA9IG9wLmRlbGV0ZWRJZDtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgY29uc3QgaXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dO1xuICAgICAgaWYgKGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9pZCA9PT0gZGVsZXRlZElkKSB7XG4gICAgICAgIGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKGl0ZW1XaXRoU2FtZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHVwZGF0ZXMucHVzaChpbnNlcnREZWx0YSh0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KSwgY2hpbGQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVzKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbikpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGlmIChuZXdJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSB0aGlzLl9wb29sLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IHJlY3JlYXRlZEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2Yob3JwaGFuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSA6IHNldERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQoXG4gICAgICAgICAgb3AsXG4gICAgICAgICAgb3AucGFyZW50S2V5XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSkgOiBzZXREZWx0YShuZXdJbmRleCwgbmV3SXRlbSksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cGRhdGUgZGVsdGEgb2YgdGhlIGRlbGV0aW9uIG9yIG51bGxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihkZWxldGVkSWQpIHtcbiAgICBpZiAoZGVsZXRlZElkID09PSB2b2lkIDAgfHwgdGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB0aGlzLl9wb29sLmdldE5vZGUoZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZEl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RldGFjaENoaWxkKGRlbGV0ZWRJdGVtKTtcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubW9kaWZpZWQudXBkYXRlc1swXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVJlbW90ZUluc2VydChvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihleGlzdGluZ0l0ZW1JbmRleCwga2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgIHJldmVyc2U6IFtdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydEFjayhvcCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBpdGVtSW5kZXhBdFBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IG9sZFBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShvbGRQb3NpdGlvbkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IG5uKHRoaXMuX3Bvb2wpLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBvcnBoYW4pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XT8uX3BhcmVudFBvcztcbiAgICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3M7XG4gICAgICBuZXdLZXkgPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgfVxuICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldO1xuICAgICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldID0gY2hpbGQ7XG4gICAgICBjb25zdCByZXZlcnNlID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyhubih0aGlzLl9pZCksIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9wLmlkXG4gICAgICApO1xuICAgICAgY29uc3QgZGVsdGEgPSBbc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSwgY2hpbGQpXTtcbiAgICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKG9wLmludGVudCA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRSZW1vdGUob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVJlbW90ZUluc2VydChvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKG5uKHRoaXMuX2lkKSwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IGluZGV4VG9EZWxldGUgPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChpbmRleFRvRGVsZXRlID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXhUb0RlbGV0ZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tpbmRleF0gPyB0aGlzLl9pdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy5faXRlbXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zaGlmdEl0ZW1Qb3NpdGlvbihpbmRleCwga2V5KSB7XG4gICAgY29uc3Qgc2hpZnRlZFBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKFxuICAgICAga2V5LFxuICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5faXRlbXNbaW5kZXggKyAxXT8uX3BhcmVudFBvcyA6IHZvaWQgMFxuICAgICk7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHNoaWZ0ZWRQb3NpdGlvbik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5faXRlbXMubWFwKFxuICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGl0ZW0udG9UcmVlTm9kZShpbmRleC50b1N0cmluZygpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faXRlbXMubWFwKChub2RlKSA9PiBub2RlLnRvSW1tdXRhYmxlKCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZUxpc3QodGhpcy5faXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmNsb25lKCkpKTtcbiAgfVxufTtcbnZhciBMaXZlTGlzdEl0ZXJhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiZGVsZXRlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGluc2VydERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgcHJldmlvdXNJbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihvcHMsIGRlbGV0ZWRJZCkge1xuICByZXR1cm4gb3BzLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBjb25zdCBmaXJzdE9wID0gb3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5maXJzdE9wLFxuICAgICAgICBpbnRlbnQ6IFwic2V0XCIsXG4gICAgICAgIGRlbGV0ZWRJZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvZnJlZXplLnRzXG52YXIgZnJlZXplID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gKFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoeCkgPT4geFxuKSA6IE9iamVjdC5mcmVlemU7XG5cbi8vIHNyYy9jcmR0cy9MaXZlTWFwLnRzXG52YXIgTGl2ZU1hcCA9IGNsYXNzIF9MaXZlTWFwIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoZW50cmllczIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChlbnRyaWVzMikge1xuICAgICAgY29uc3QgbWFwcGVkRW50cmllcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllczIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBtYXBwZWRFbnRyaWVzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcChtYXBwZWRFbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBfaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgX0xpdmVNYXAoKTtcbiAgICBtYXAuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobWFwLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBtYXAuX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIG1hcC5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXksIG9wSWQgfSA9IG9wO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleTtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcElkID0gdGhpcy51bmFja25vd2xlZGdlZFNldC5nZXQoa2V5KTtcbiAgICAgIGlmIChsYXN0VXBkYXRlT3BJZCA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFVwZGF0ZU9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX21hcC52YWx1ZXMoKSkge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgdXBkYXRlczogeyBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVNYXAgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAyIC8qIE1BUCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgTGl2ZU1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBhIHN0cmluZy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgaXRlbS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHMgPSBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuc2V0KGtleSwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvbGRWYWx1ZSA/IG9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSA6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2UuXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgYnkga2V5LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgZXhpc3RlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCwgb3IgZmFsc2UgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmIChpdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIGl0ZW0uX2lkKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpc0lkLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaXRlbS5fdG9PcHModGhpc0lkLCBrZXkpLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIFtrZXksIHZhbHVlXSBwYWlycyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLmVudHJpZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvclZhbHVlLnZhbHVlO1xuICAgICAgICBjb25zdCBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlWzFdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogW2tleSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVudHJpZXMgbWV0aG9kLlxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIHZhbHVlcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLnZhbHVlcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwIG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgbWFwLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2soZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWxdKSA9PiB2YWwudG9UcmVlTm9kZShrZXkyKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b0ltbXV0YWJsZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVNYXAoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCBub2RlXSkgPT4gW2tleSwgbm9kZS5jbG9uZSgpXSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU9iamVjdC50c1xudmFyIExpdmVPYmplY3QgPSBjbGFzcyBfTGl2ZU9iamVjdCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvYmopKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wSWQgPSBwb29sPy5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleSxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGl2ZU9iaiA9IG5ldyBfTGl2ZU9iamVjdChpdGVtLmRhdGEpO1xuICAgIGxpdmVPYmouX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQobm4obGl2ZU9iai5faWQpKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpdmVPYmo7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpdmVPYmosIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGxpdmVPYmouX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIGxpdmVPYmouaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU9iajtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBvcElkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9Mc29uKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKSB7XG4gICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wSWQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzSWQsIGtleSB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZDogdGhpc0lkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IHByZXZpb3VzVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXZlcnNlLFxuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKCFpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgdGhpcy5wYXJlbnQubm9kZS5faWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBwYXJlbnRJZDogdGhpcy5wYXJlbnQubm9kZS5faWQsXG4gICAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5LFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBrZXkgPSBvcC5rZXk7XG4gICAgaWYgKHRoaXMuX21hcC5oYXMoa2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoIWlzTG9jYWwgJiYgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgbGV0IHJldmVyc2UgPSBbXTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHMoaWQsIG9wLmtleSk7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IG9sZFZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogeyBbb3Aua2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIExpdmVPYmplY3QgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX21hcCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhIHByb3BlcnR5IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICB0aGlzLnVwZGF0ZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIHRoZSBMaXZlT2JqZWN0LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgTGl2ZU9iamVjdFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qga2V5QXNTdHJpbmcgPSBrZXk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleUFzU3RyaW5nKTtcbiAgICBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleUFzU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBkYXRhOiB7IFtrZXlBc1N0cmluZ106IG9sZFZhbHVlIH0sXG4gICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5QXNTdHJpbmcpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLyxcbiAgICAgICAgICBrZXk6IGtleUFzU3RyaW5nLFxuICAgICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZXZlcnNlLFxuICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlIHdpdGggYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0gcGF0Y2ggVGhlIG9iamVjdCB1c2VkIHRvIG92ZXJyaWRlcyBwcm9wZXJ0aWVzXG4gICAqL1xuICB1cGRhdGUocGF0Y2gpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDAgfHwgdGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgIGNvbnN0IG9wSWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpO1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGVPcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQ6IHRoaXMuX2lkLCBrZXkgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXZlcnNlVXBkYXRlT3AuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbmV3VmFsdWUuX2F0dGFjaCh0aGlzLl9wb29sLmdlbmVyYXRlSWQoKSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IG5ld0F0dGFjaENoaWxkT3BzID0gbmV3VmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBjcmVhdGVDcmR0T3AgPSBuZXdBdHRhY2hDaGlsZE9wcy5maW5kKFxuICAgICAgICAgIChvcCkgPT4gb3AucGFyZW50SWQgPT09IHRoaXMuX2lkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjcmVhdGVDcmR0T3ApIHtcbiAgICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKGNyZWF0ZUNyZHRPcC5vcElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2goLi4ubmV3QXR0YWNoQ2hpbGRPcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlZFByb3BzW2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBvcElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGVPcC5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2VPcHMudW5zaGlmdChyZXZlcnNlVXBkYXRlT3ApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZFByb3BzKS5sZW5ndGggIT09IDApIHtcbiAgICAgIG9wcy51bnNoaWZ0KHtcbiAgICAgICAgb3BJZCxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgIGRhdGE6IHVwZGF0ZWRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvVHJlZU5vZGUoa2V5KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMuX2lkID8/IG5hbm9pZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGlkOiBub2RlSWQsXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWx1ZV0pID0+IGlzTGl2ZU5vZGUodmFsdWUpID8gdmFsdWUudG9UcmVlTm9kZShrZXkyKSA6IHsgdHlwZTogXCJKc29uXCIsIGlkOiBgJHtub2RlSWR9OiR7a2V5Mn1gLCBrZXk6IGtleTIsIHBheWxvYWQ6IHZhbHVlIH1cbiAgICAgIClcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gaXNMaXZlU3RydWN0dXJlKHZhbCkgPyB2YWwudG9JbW11dGFibGUoKSA6IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlT2JqZWN0KFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL2xpdmVibG9ja3MtaGVscGVycy50c1xuZnVuY3Rpb24gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApIHtcbiAgcmV0dXJuIGxzb25Ub0xpdmVOb2RlKGNyZWF0aW9uT3BUb0xzb24ob3ApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xzb24ob3ApIHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzpcbiAgICAgIHJldHVybiBvcC5kYXRhO1xuICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KG9wLmRhdGEpO1xuICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTWFwKCk7XG4gICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTGlzdCgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL0ltbXV0YWJsZVJlZi50c1xuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEltbXV0YWJsZVJlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXYgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgfVxuICBnZXQgZGlkSW52YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXYub2JzZXJ2YWJsZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2V2Lm5vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUgPz8gKHRoaXMuX2NhY2hlID0gdGhpcy5fdG9JbW11dGFibGUoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL090aGVyc1JlZi50c1xuZnVuY3Rpb24gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpIHtcbiAgY29uc3QgeyBjb25uZWN0aW9uSWQsIGlkLCBpbmZvIH0gPSBjb25uO1xuICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShjb25uLnNjb3Blcyk7XG4gIHJldHVybiBmcmVlemUoXG4gICAgY29tcGFjdE9iamVjdCh7XG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBpZCxcbiAgICAgIGluZm8sXG4gICAgICBjYW5Xcml0ZSxcbiAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoY29ubi5zY29wZXMpLFxuICAgICAgaXNSZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgLy8gRGVwcmVjYXRlZCwga2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuICAgICAgcHJlc2VuY2VcbiAgICB9KVxuICApO1xufVxudmFyIE90aGVyc1JlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgLy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29ubmVjdGlvbklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbnMua2V5cygpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHVzZXJzID0gY29tcGFjdChcbiAgICAgIEFycmF5LmZyb20odGhpcy5fcHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAoY29ubmVjdGlvbklkKSA9PiB0aGlzLmdldFVzZXIoTnVtYmVyKGNvbm5lY3Rpb25JZCkpXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gdXNlcnM7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLl91c2Vycy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY2FjaGVkVXNlcikge1xuICAgICAgcmV0dXJuIGNhY2hlZFVzZXI7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkVXNlciA9IHRoaXMuX2dldFVzZXIoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29tcHV0ZWRVc2VyKSB7XG4gICAgICB0aGlzLl91c2Vycy5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAodGhpcy5fdXNlcnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX3VzZXJzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjb3JkcyBhIGtub3duIGNvbm5lY3Rpb24uIFRoaXMgcmVjb3JkcyB0aGUgY29ubmVjdGlvbiBJRCBhbmQgdGhlXG4gICAqIGFzc29jaWF0ZWQgbWV0YWRhdGEuXG4gICAqL1xuICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgbWV0YVVzZXJJZCwgbWV0YVVzZXJJbmZvLCBzY29wZXMpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5zZXQoXG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBmcmVlemUoe1xuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIGlkOiBtZXRhVXNlcklkLFxuICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgIHNjb3Blc1xuICAgICAgfSlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEga25vd24gY29ubmVjdGlvbklkLiBSZW1vdmVzIGJvdGggdGhlIGNvbm5lY3Rpb24ncyBtZXRhZGF0YSBhbmRcbiAgICogdGhlIHByZXNlbmNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIHByZXNlbmNlIGRhdGEgZm9yIGFuIGV4aXN0aW5nIFwib3RoZXJcIi4gSWYgd2UgZG9uJ3Qga25vdyB0aGVcbiAgICogaW5pdGlhbCBwcmVzZW5jZSBkYXRhIGZvciB0aGlzIHVzZXIgeWV0LCBkaXNjYXJkIHRoaXMgcGF0Y2ggYW5kIGF3YWl0IHRoZVxuICAgKiBmdWxsIC5zZXRPdGhlcigpIGNhbGwgZmlyc3QuXG4gICAqL1xuICBwYXRjaE90aGVyKGNvbm5lY3Rpb25JZCwgcGF0Y2gpIHtcbiAgICBjb25zdCBvbGRQcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdQcmVzZW5jZSA9IG1lcmdlKG9sZFByZXNlbmNlLCBwYXRjaCk7XG4gICAgaWYgKG9sZFByZXNlbmNlICE9PSBuZXdQcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShuZXdQcmVzZW5jZSkpO1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1BhdGNoYWJsZVJlZi50c1xudmFyIFBhdGNoYWJsZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShjb21wYWN0T2JqZWN0KGRhdGEpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBwYXRjaChwYXRjaCkge1xuICAgIGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBtZXJnZShvbGREYXRhLCBwYXRjaCk7XG4gICAgaWYgKG9sZERhdGEgIT09IG5ld0RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBmcmVlemUobmV3RGF0YSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1ZhbHVlUmVmLnRzXG52YXIgVmFsdWVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUoaW5pdGlhbFZhbHVlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUobmV3VmFsdWUpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG59O1xudmFyIERlcml2ZWRSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBvdGhlclJlZnMgPSBhcmdzO1xuICAgIHRoaXMuX3JlZnMgPSBvdGhlclJlZnM7XG4gICAgdGhpcy5fcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHJlZi5kaWRJbnZhbGlkYXRlLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludmFsaWRhdGUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtRm47XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShcbiAgICAgIC4uLnRoaXMuX3JlZnMubWFwKChyZWYpID0+IHJlZi5jdXJyZW50KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDEwMjQ7XG5mdW5jdGlvbiBtYWtlSWRGYWN0b3J5KGNvbm5lY3Rpb25JZCkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gKCkgPT4gYCR7Y29ubmVjdGlvbklkfToke2NvdW50Kyt9YDtcbn1cbmZ1bmN0aW9uIHVzZXJUb1RyZWVOb2RlKGtleSwgdXNlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVXNlclwiLFxuICAgIGlkOiBgJHt1c2VyLmNvbm5lY3Rpb25JZH1gLFxuICAgIGtleSxcbiAgICBwYXlsb2FkOiB1c2VyXG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxQcmVzZW5jZShjb25maWcucm9vbUlkKSA6IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlO1xuICBjb25zdCBpbml0aWFsU3RvcmFnZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxTdG9yYWdlKGNvbmZpZy5yb29tSWQpIDogb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIGR5bmFtaWNTZXNzaW9uSW5mbzogbmV3IFZhbHVlUmVmKG51bGwpLFxuICAgIG15UHJlc2VuY2U6IG5ldyBQYXRjaGFibGVSZWYoaW5pdGlhbFByZXNlbmNlKSxcbiAgICBvdGhlcnM6IG5ldyBPdGhlcnNSZWYoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gU3RvcmFnZVxuICAgIGNsb2NrOiAwLFxuICAgIG9wQ2xvY2s6IDAsXG4gICAgbm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIHVuZG9TdGFjazogW10sXG4gICAgcmVkb1N0YWNrOiBbXSxcbiAgICBwYXVzZWRIaXN0b3J5OiBudWxsLFxuICAgIGFjdGl2ZUJhdGNoOiBudWxsLFxuICAgIHVuYWNrbm93bGVkZ2VkT3BzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIC8vIERlYnVnXG4gICAgb3BTdGFja1RyYWNlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSA6IHZvaWQgMFxuICB9O1xuICBjb25zdCBkb05vdEJhdGNoVXBkYXRlcyA9IChjYikgPT4gY2IoKTtcbiAgY29uc3QgYmF0Y2hVcGRhdGVzID0gY29uZmlnLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID8/IGRvTm90QmF0Y2hVcGRhdGVzO1xuICBsZXQgbGFzdFRva2VuS2V5O1xuICBmdW5jdGlvbiBvblN0YXR1c0RpZENoYW5nZShuZXdTdGF0dXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZTtcbiAgICBpZiAoYXV0aFZhbHVlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b2tlbktleSA9IGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiID8gYXV0aFZhbHVlLnRva2VuLnJhdyA6IGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuc3RhdHVzLm5vdGlmeShuZXdTdGF0dXMpO1xuICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGxldCBfY29ubmVjdGlvbkxvc3NUaW1lcklkO1xuICBsZXQgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQobmV3U3RhdHVzKSB7XG4gICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImxvc3RcIik7XG4gICAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb250ZXh0Lm90aGVycy5jbGVhck90aGVycygpO1xuICAgICAgICAgIG5vdGlmeSh7IG90aGVyczogW3sgdHlwZTogXCJyZXNldFwiIH1dIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcImZhaWxlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwicmVzdG9yZWRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uRGlkQ29ubmVjdCgpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgIGRhdGE6IChcbiAgICAgICAgLy8gQmVjYXVzZSBjb250ZXh0Lm1lLmN1cnJlbnQgaXMgYSByZWFkb25seSBvYmplY3QsIHdlJ2xsIGhhdmUgdG9cbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgaGVyZS4gT3RoZXJ3aXNlLCB0eXBlIGVycm9ycyBoYXBwZW4gbGF0ZXIgd2hlblxuICAgICAgICAvLyBcInBhdGNoaW5nXCIgbXkgcHJlc2VuY2UuXG4gICAgICAgIHsgLi4uY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQgfVxuICAgICAgKVxuICAgIH07XG4gICAgaWYgKF9nZXRTdG9yYWdlJCAhPT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gb25EaWREaXNjb25uZWN0KCkge1xuICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICB9XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTWVzc2FnZS5zdWJzY3JpYmUoaGFuZGxlU2VydmVyTWVzc2FnZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUob25TdGF0dXNEaWRDaGFuZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKGhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWRDb25uZWN0LnN1YnNjcmliZShvbkRpZENvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5kaWREaXNjb25uZWN0LnN1YnNjcmliZShvbkRpZERpc2Nvbm5lY3QpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbkxpdmVibG9ja3NFcnJvci5zdWJzY3JpYmUoKGVycikgPT4ge1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke2Vyci5tZXNzYWdlfSAoY29kZTogJHtlcnIuY29kZX0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50SHViLmVycm9yLm5vdGlmeShlcnIpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgcG9vbCA9IHtcbiAgICByb29tSWQ6IGNvbmZpZy5yb29tSWQsXG4gICAgZ2V0Tm9kZTogKGlkKSA9PiBjb250ZXh0Lm5vZGVzLmdldChpZCksXG4gICAgYWRkTm9kZTogKGlkLCBub2RlKSA9PiB2b2lkIGNvbnRleHQubm9kZXMuc2V0KGlkLCBub2RlKSxcbiAgICBkZWxldGVOb2RlOiAoaWQpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5kZWxldGUoaWQpLFxuICAgIGdlbmVyYXRlSWQ6ICgpID0+IGAke2dldENvbm5lY3Rpb25JZCgpfToke2NvbnRleHQuY2xvY2srK31gLFxuICAgIGdlbmVyYXRlT3BJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5vcENsb2NrKyt9YCxcbiAgICBkaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICBjb25zdCBhY3RpdmVCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBjYXB0dXJlU3RhY2tUcmFjZShcIlN0b3JhZ2UgbXV0YXRpb25cIiwgdGhpcy5kaXNwYXRjaCk7XG4gICAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICAgIGlmIChvcC5vcElkKSB7XG4gICAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuc2V0KG9wLm9wSWQsIHN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZUJhdGNoKSB7XG4gICAgICAgIGFjdGl2ZUJhdGNoLm9wcy5wdXNoKC4uLm9wcyk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KC4uLnJldmVyc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhyZXZlcnNlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICBkaXNwYXRjaE9wcyhvcHMpO1xuICAgICAgICAgIG5vdGlmeSh7IHN0b3JhZ2VVcGRhdGVzIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3NlcnRTdG9yYWdlSXNXcml0YWJsZTogKCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudD8uc2NvcGVzO1xuICAgICAgaWYgKHNjb3BlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcyk7XG4gICAgICBpZiAoIWNhbldyaXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCB3cml0ZSB0byBzdG9yYWdlIHdpdGggYSByZWFkIG9ubHkgdXNlciwgcGxlYXNlIGVuc3VyZSB0aGUgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbnNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZXZlbnRIdWIgPSB7XG4gICAgY29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgLy8gT2xkL2RlcHJlY2F0ZWQgQVBJXG4gICAgc3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBOZXcvcmVjb21tZW5kZWQgQVBJXG4gICAgbG9zdENvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGN1c3RvbUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzZWxmOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBteVByZXNlbmNlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBvdGhlcnM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGVycm9yOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBoaXN0b3J5OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlRGlkTG9hZDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZVN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgeWRvYzogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY29tbWVudHM6IG1ha2VFdmVudFNvdXJjZSgpXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhUb2tlbk9yUHVibGljQXBpS2V5LCByb29tSWQpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCl9L3N0b3JhZ2VgLFxuICAgICAgY29uZmlnLmJhc2VVcmxcbiAgICApLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IGNvbmZpZy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmV0Y2g7XG4gICAgcmV0dXJuIGZldGNoZXIodXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthdXRoVG9rZW5PclB1YmxpY0FwaUtleX1gXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaHR0cFBvc3RUb1Jvb20oZW5kcG9pbnQsIGJvZHkpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aFRva2VuT3JQdWJsaWNBcGlLZXkgPSBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiID8gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUucHVibGljQXBpS2V5IDogbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUudG9rZW4ucmF3O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBgL3YyL2Mvcm9vbXMvJHtlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLnJvb21JZCl9JHtlbmRwb2ludH1gLFxuICAgICAgY29uZmlnLmJhc2VVcmxcbiAgICApLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZmV0Y2hlciA9IGNvbmZpZy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmV0Y2g7XG4gICAgcmV0dXJuIGZldGNoZXIodXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbk9yUHVibGljQXBpS2V5fWBcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpO1xuICAgIGNvbnN0IG5vbmNlID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudD8ubm9uY2U7XG4gICAgaWYgKGNvbmZpZy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCAmJiBub25jZSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZXJpYWxpemVkUGF5bG9hZCkubGVuZ3RoO1xuICAgICAgaWYgKHNpemUgPiBNQVhfU09DS0VUX01FU1NBR0VfU0laRSkge1xuICAgICAgICB2b2lkIGh0dHBQb3N0VG9Sb29tKFwiL3NlbmQtbWVzc2FnZVwiLCB7IG5vbmNlLCBtZXNzYWdlcyB9KS50aGVuKFxuICAgICAgICAgIChyZXNwKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3Aub2sgJiYgcmVzcC5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICBtYW5hZ2VkU29ja2V0LnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1lc3NhZ2Ugd2FzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cyBhbmQgc2VudCBvdmVyIEhUVFAgaW5zdGVhZFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFuYWdlZFNvY2tldC5zZW5kKHNlcmlhbGl6ZWRQYXlsb2FkKTtcbiAgfVxuICBjb25zdCBzZWxmID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mbyxcbiAgICBjb250ZXh0Lm15UHJlc2VuY2UsXG4gICAgKHN0YXRpY1Nlc3Npb24sIGR5bmFtaWNTZXNzaW9uLCBteVByZXNlbmNlKSA9PiB7XG4gICAgICBpZiAoc3RhdGljU2Vzc2lvbiA9PT0gbnVsbCB8fCBkeW5hbWljU2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gY2FuV3JpdGVTdG9yYWdlKGR5bmFtaWNTZXNzaW9uLnNjb3Blcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29ubmVjdGlvbklkOiBkeW5hbWljU2Vzc2lvbi5hY3RvcixcbiAgICAgICAgICBpZDogc3RhdGljU2Vzc2lvbi51c2VySWQsXG4gICAgICAgICAgaW5mbzogc3RhdGljU2Vzc2lvbi51c2VySW5mbyxcbiAgICAgICAgICBwcmVzZW5jZTogbXlQcmVzZW5jZSxcbiAgICAgICAgICBjYW5Xcml0ZSxcbiAgICAgICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGR5bmFtaWNTZXNzaW9uLnNjb3BlcyksXG4gICAgICAgICAgaXNSZWFkT25seTogIWNhbldyaXRlXG4gICAgICAgICAgLy8gRGVwcmVjYXRlZCwga2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgbGV0IF9sYXN0U2VsZjtcbiAgZnVuY3Rpb24gbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3QgY3VyclNlbGYgPSBzZWxmLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJTZWxmICE9PSBudWxsICYmIGN1cnJTZWxmICE9PSBfbGFzdFNlbGYpIHtcbiAgICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICAgIGV2ZW50SHViLnNlbGYubm90aWZ5KGN1cnJTZWxmKTtcbiAgICAgIH0pO1xuICAgICAgX2xhc3RTZWxmID0gY3VyclNlbGY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGZBc1RyZWVOb2RlID0gbmV3IERlcml2ZWRSZWYoXG4gICAgc2VsZixcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gdXNlclRvVHJlZU5vZGUoXCJNZVwiLCBtZSkgOiBudWxsXG4gICk7XG4gIGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBsb2FkIHN0b3JhZ2Ugd2l0aG91dCBpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICB1cGRhdGVSb290KG1lc3NhZ2UuaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQucm9vdCA9IExpdmVPYmplY3QuX2Zyb21JdGVtcyhtZXNzYWdlLml0ZW1zLCBwb29sKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2tTaXplQmVmb3JlID0gY29udGV4dC51bmRvU3RhY2subGVuZ3RoO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHQuaW5pdGlhbFN0b3JhZ2UpIHtcbiAgICAgIGlmIChjb250ZXh0LnJvb3QuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0LnJvb3Quc2V0KGtleSwgY2xvbmVMc29uKGNvbnRleHQuaW5pdGlhbFN0b3JhZ2Vba2V5XSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIGNvbnRleHQubm9kZXMpIHtcbiAgICAgIGN1cnJlbnRJdGVtcy5zZXQoaWQsIG5vZGUuX3NlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ldyBNYXAoaXRlbXMpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIGZhbHNlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC51bmRvU3RhY2subGVuZ3RoID49IDUwKSB7XG4gICAgICBjb250ZXh0LnVuZG9TdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5wdXNoKGhpc3RvcnlPcHMpO1xuICAgIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeS51bnNoaWZ0KC4uLmhpc3RvcnlPcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeSh1cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXM7XG4gICAgY29uc3Qgb3RoZXJzVXBkYXRlcyA9IHVwZGF0ZXMub3RoZXJzO1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBpZiAob3RoZXJzVXBkYXRlcyAhPT0gdm9pZCAwICYmIG90aGVyc1VwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIG90aGVyc1VwZGF0ZXMpIHtcbiAgICAgICAgICBldmVudEh1Yi5vdGhlcnMubm90aWZ5KHsgLi4uZXZlbnQsIG90aGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMucHJlc2VuY2UgPz8gZmFsc2UpIHtcbiAgICAgICAgbm90aWZ5U2VsZkNoYW5nZWQoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBldmVudEh1Yi5teVByZXNlbmNlLm5vdGlmeShjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcmFnZVVwZGF0ZXMgIT09IHZvaWQgMCAmJiBzdG9yYWdlVXBkYXRlcy5zaXplID4gMCkge1xuICAgICAgICBjb25zdCB1cGRhdGVzMiA9IEFycmF5LmZyb20oc3RvcmFnZVVwZGF0ZXMudmFsdWVzKCkpO1xuICAgICAgICBldmVudEh1Yi5zdG9yYWdlLm5vdGlmeSh1cGRhdGVzMik7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbklkKCkge1xuICAgIGNvbnN0IGluZm8gPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5hY3RvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnRlcm5hbC4gVHJpZWQgdG8gZ2V0IGNvbm5lY3Rpb24gaWQgYnV0IGNvbm5lY3Rpb24gd2FzIG5ldmVyIG9wZW5cIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcHMocmF3T3BzLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgcmV2ZXJzZTogW10sXG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHByZXNlbmNlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlZE5vZGVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9wcyA9IHJhd09wcy5tYXAoKG9wKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiICYmICFvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wLCBvcElkOiBwb29sLmdlbmVyYXRlT3BJZCgpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3A7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgIGlmIChvcC50eXBlID09PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YToge31cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgIHJldmVyc2UuZGF0YVtrZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gob3AuZGF0YSk7XG4gICAgICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7IHR5cGU6IFwicGFydGlhbFwiLCBkYXRhOiBvcC5kYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG9wLmRhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdChyZXZlcnNlKTtcbiAgICAgICAgb3V0cHV0LnByZXNlbmNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgICAgc291cmNlID0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3BJZCA9IG5uKG9wLm9wSWQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KC4uLmFwcGx5T3BSZXN1bHQucmV2ZXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcC50eXBlID09PSAyIC8qIENSRUFURV9MSVNUICovIHx8IG9wLnR5cGUgPT09IDcgLyogQ1JFQVRFX01BUCAqLyB8fCBvcC50eXBlID09PSA0IC8qIENSRUFURV9PQkpFQ1QgKi8pIHtcbiAgICAgICAgICAgIGNyZWF0ZWROb2RlSWRzLmFkZChubihvcC5pZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3BzLFxuICAgICAgcmV2ZXJzZTogb3V0cHV0LnJldmVyc2UsXG4gICAgICB1cGRhdGVzOiB7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzOiBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMsXG4gICAgICAgIHByZXNlbmNlOiBvdXRwdXQucHJlc2VuY2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3Aob3AsIHNvdXJjZSkge1xuICAgIGlmIChpc0Fja09wKG9wKSkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovOlxuICAgICAgY2FzZSAzIC8qIFVQREFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnQubm9kZS5fc2V0Q2hpbGRLZXkoXG4gICAgICAgICAgICBhc1BvcyhvcC5wYXJlbnRLZXkpLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzoge1xuICAgICAgICBpZiAob3AucGFyZW50SWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Tm9kZS5fYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVByZXNlbmNlKHBhdGNoLCBvcHRpb25zMikge1xuICAgIGNvbnN0IG9sZFZhbHVlcyA9IHt9O1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgICAgdHlwZTogXCJwYXJ0aWFsXCIsXG4gICAgICAgIGRhdGE6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAob3ZlcnJpZGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFba2V5XSA9IG92ZXJyaWRlVmFsdWU7XG4gICAgICBvbGRWYWx1ZXNba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgfVxuICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChwYXRjaCk7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gucmV2ZXJzZU9wcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soXG4gICAgICAgICAgICBbeyB0eXBlOiBcInByZXNlbmNlXCIsIGRhdGE6IG9sZFZhbHVlcyB9XSxcbiAgICAgICAgICAgIGRvTm90QmF0Y2hVcGRhdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkoeyBwcmVzZW5jZTogdHJ1ZSB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnRhcmdldEFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG9sZFVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0T3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKTtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgaWYgKG9sZFVzZXIgPT09IHZvaWQgMCAmJiBuZXdVc2VyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBuZXdVc2VyIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnBhdGNoT3RoZXIobWVzc2FnZS5hY3RvciwgbWVzc2FnZS5kYXRhKSwgbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKG1lc3NhZ2UuYWN0b3IpO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsZWF2ZVwiLCB1c2VyIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGJhdGNoZWRVcGRhdGVzV3JhcHBlcigoKSA9PiB7XG4gICAgICBldmVudEh1Yi5oaXN0b3J5Lm5vdGlmeSh7IGNhblVuZG86IGNhblVuZG8oKSwgY2FuUmVkbzogY2FuUmVkbygpIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICBtZXNzYWdlLmFjdG9yLFxuICAgICAgbWVzc2FnZS5pZCxcbiAgICAgIG1lc3NhZ2UuaW5mbyxcbiAgICAgIG1lc3NhZ2Uuc2NvcGVzXG4gICAgKTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICBkYXRhOiBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAob2ZmbGluZU9wcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3Qgb3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIHRydWUpO1xuICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgb3BzOiByZXN1bHQub3BzXG4gICAgfSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMDEgLyogVVNFUl9KT0lORUQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJKb2luZWRVcGRhdGUgPSBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaCh1c2VySm9pbmVkVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJzUHJlc2VuY2VVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvdGhlcnNQcmVzZW5jZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UuYWN0b3IgPCAwID8gbnVsbCA6IG90aGVycy5maW5kKCh1KSA9PiB1LmNvbm5lY3Rpb25JZCA9PT0gbWVzc2FnZS5hY3RvcikgPz8gbnVsbCxcbiAgICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAyIC8qIFVTRVJfTEVGVCAqLzoge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQyID0gb25Vc2VyTGVmdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2goZXZlbnQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDMwMCAvKiBVUERBVEVfWURPQyAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLzoge1xuICAgICAgICAgICAgY29uc3QgYXBwbHlSZXN1bHQgPSBhcHBseU9wcyhtZXNzYWdlLm9wcywgZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgICB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDI5OSAvKiBSRUpFQ1RfU1RPUkFHRV9PUCAqLzoge1xuICAgICAgICAgICAgZXJyb3JXaXRoVGl0bGUoXG4gICAgICAgICAgICAgIFwiU3RvcmFnZSBtdXRhdGlvbiByZWplY3Rpb24gZXJyb3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZS5yZWFzb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3Qgb3BJZCBvZiBtZXNzYWdlLm9wSWRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBjb250ZXh0Lm9wU3RhY2tUcmFjZXM/LmdldChvcElkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRyYWNlcy5hZGQodHJhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2VzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2FybldpdGhUaXRsZShcbiAgICAgICAgICAgICAgICAgIFwiVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYWxscyBjYXVzZWQgdGhlIHJlamVjdGVkIHN0b3JhZ2UgbXV0YXRpb25zOlwiLFxuICAgICAgICAgICAgICAgICAgYFxuXG4ke0FycmF5LmZyb20odHJhY2VzKS5qb2luKFwiXFxuXFxuXCIpfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDQwMCAvKiBUSFJFQURfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMSAvKiBUSFJFQURfTUVUQURBVEFfVVBEQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICAgIGNhc2UgNDA2IC8qIENPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMiAvKiBDT01NRU5UX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDQgLyogQ09NTUVOVF9ERUxFVEVEICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi5jb21tZW50cy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vdGlmeSh1cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkTWlsbGlzID0gbm93IC0gY29udGV4dC5idWZmZXIubGFzdEZsdXNoZWRBdDtcbiAgICBpZiAoZWxhcHNlZE1pbGxpcyA+PSBjb25maWcudGhyb3R0bGVEZWxheSkge1xuICAgICAgY29uc3QgbWVzc2FnZXNUb0ZsdXNoID0gc2VyaWFsaXplQnVmZmVyKCk7XG4gICAgICBpZiAobWVzc2FnZXNUb0ZsdXNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXNUb0ZsdXNoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0ge1xuICAgICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgICAgbGFzdEZsdXNoZWRBdDogbm93LFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkXG4gICAgfTtcbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKGNsaWVudE1zZyk7XG4gICAgZXZlbnRIdWIueWRvYy5ub3RpZnkoY2xpZW50TXNnKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zMiA9IHtcbiAgICBzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeTogZmFsc2VcbiAgfSkge1xuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiICYmICFvcHRpb25zMi5zaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDEwMyAvKiBCUk9BRENBU1RfRVZFTlQgKi8sXG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hPcHMob3BzKSB7XG4gICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaCguLi5vcHMpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIGFwcGx5QW5kU2VuZE9wcyh1bmFja25vd2xlZGdlZE9wcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2U/LigpO1xuICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5ub3RpZnkoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdG9yYWdlKCkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyZWFtRmV0Y2goXG4gICAgICBtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiID8gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUucHVibGljQXBpS2V5IDogbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUudG9rZW4ucmF3LFxuICAgICAgY29uZmlnLnJvb21JZFxuICAgICk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQub3RoZXJzLFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyLCBpbmRleCkgPT4gdXNlclRvVHJlZU5vZGUoYE90aGVyICR7aW5kZXh9YCwgb3RoZXIpKVxuICApO1xuICBjb25zdCBldmVudHMgPSB7XG4gICAgc3RhdHVzOiBldmVudEh1Yi5zdGF0dXMub2JzZXJ2YWJsZSxcbiAgICBsb3N0Q29ubmVjdGlvbjogZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ub2JzZXJ2YWJsZSxcbiAgICBjdXN0b21FdmVudDogZXZlbnRIdWIuY3VzdG9tRXZlbnQub2JzZXJ2YWJsZSxcbiAgICBvdGhlcnM6IGV2ZW50SHViLm90aGVycy5vYnNlcnZhYmxlLFxuICAgIHNlbGY6IGV2ZW50SHViLnNlbGYub2JzZXJ2YWJsZSxcbiAgICBteVByZXNlbmNlOiBldmVudEh1Yi5teVByZXNlbmNlLm9ic2VydmFibGUsXG4gICAgZXJyb3I6IGV2ZW50SHViLmVycm9yLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZTogZXZlbnRIdWIuc3RvcmFnZS5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGNvbnN0IGNvbW1lbnRzQXBpID0gY3JlYXRlQ29tbWVudHNBcGkoY29uZmlnLnJvb21JZCwgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSwge1xuICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIC8qIE5PVEU6IEV4cG9zaW5nIF9faW50ZXJuYWwgaGVyZSBvbmx5IHRvIGFsbG93IHRlc3RpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBpbiB1bml0IHRlc3RzICovXG4gICAgICBfX2ludGVybmFsOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lm5vZGVzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgZXZlbnRzLFxuICAgICAgLy8gQ29yZVxuICAgICAgZ2V0U3RhdHVzOiAoKSA9PiBtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpLFxuICAgICAgZ2V0Q29ubmVjdGlvblN0YXRlOiAoKSA9PiBtYW5hZ2VkU29ja2V0LmdldExlZ2FjeVN0YXR1cygpLFxuICAgICAgZ2V0U2VsZjogKCkgPT4gc2VsZi5jdXJyZW50LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIGdldFByZXNlbmNlOiAoKSA9PiBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCxcbiAgICAgIGdldE90aGVyczogKCkgPT4gY29udGV4dC5vdGhlcnMuY3VycmVudCxcbiAgICAgIC4uLmNvbW1lbnRzQXBpXG4gICAgfSxcbiAgICAvLyBFeHBsaWN0bHkgbWFrZSB0aGUgX19pbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAgXCJfX2ludGVybmFsXCIsXG4gICAgeyBlbnVtZXJhYmxlOiBmYWxzZSB9XG4gICk7XG59XG5mdW5jdGlvbiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cykge1xuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwiY29ubmVjdGlvblwiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoc3RhdHVzKSA9PiBjYihuZXdUb0xlZ2FjeVN0YXR1cyhzdGF0dXMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RhdHVzLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJsb3N0LWNvbm5lY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhpc3RvcnlcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcInN0b3JhZ2Utc3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMaXZlTm9kZShmaXJzdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmaXJzdDtcbiAgICAgIGlmIChvcHRpb25zPy5pc0RlZXApIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgbm9kZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7U3RyaW5nKGZpcnN0KX0gaXMgbm90IGEgdmFsdWUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0by5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3Vic2NyaWJlO1xufVxuZnVuY3Rpb24gaXNSb29tRXZlbnROYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJteS1wcmVzZW5jZVwiIHx8IHZhbHVlID09PSBcIm90aGVyc1wiIHx8IHZhbHVlID09PSBcImV2ZW50XCIgfHwgdmFsdWUgPT09IFwiZXJyb3JcIiB8fCB2YWx1ZSA9PT0gXCJoaXN0b3J5XCIgfHwgdmFsdWUgPT09IFwic3RhdHVzXCIgfHwgdmFsdWUgPT09IFwic3RvcmFnZS1zdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJsb3N0LWNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCI7XG59XG5mdW5jdGlvbiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZShcInJvb206cmVhZFwiLCByb29tSWQpO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybC50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbmZ1bmN0aW9uIGdldEJhc2VVcmxGcm9tQ2xpZW50T3B0aW9ucyhjbGllbnRPcHRpb25zKSB7XG4gIGlmIChcImxpdmVibG9ja3NTZXJ2ZXJcIiBpbiBjbGllbnRPcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IG9wdGlvbiBubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgY2xpZW50T3B0aW9ucy5iYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGNsaWVudE9wdGlvbnMuYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBjbGllbnRPcHRpb25zLmJhc2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQkFTRV9VUkw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucyk7XG4gIGNvbnN0IHJvb21zQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duUm9vbShyb29tKSB7XG4gICAgdW5saW5rRGV2VG9vbHMocm9vbS5pZCk7XG4gICAgcm9vbXNCeUlkLmRlbGV0ZShyb29tLmlkKTtcbiAgICByb29tLmRlc3Ryb3koKTtcbiAgfVxuICBmdW5jdGlvbiBsZWFzZVJvb20oaW5mbykge1xuICAgIGNvbnN0IGxlYXZlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGxlYXZlO1xuICAgICAgaWYgKCFpbmZvLnVuc3Vicy5kZWxldGUoc2VsZikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIlRoaXMgbGVhdmUgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkLiBDYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGhhcyBubyBlZmZlY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLnVuc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGVhcmRvd25Sb29tKGluZm8ucm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluZm8udW5zdWJzLmFkZChsZWF2ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IGluZm8ucm9vbSxcbiAgICAgIGxlYXZlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgZGVwcmVjYXRlSWYoXG4gICAgICBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IG51bGwgfHwgb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSB2b2lkIDAsXG4gICAgICBcIlBsZWFzZSBwcm92aWRlIGFuIGluaXRpYWwgcHJlc2VuY2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHVzZXIgd2hlbiBlbnRlcmluZyB0aGUgcm9vbS5cIlxuICAgICk7XG4gICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmxGcm9tQ2xpZW50T3B0aW9ucyhjbGllbnRPcHRpb25zKTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHtcbiAgICAgICAgaW5pdGlhbFByZXNlbmNlOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPz8ge30sXG4gICAgICAgIGluaXRpYWxTdG9yYWdlOiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0aHJvdHRsZURlbGF5LFxuICAgICAgICBsb3N0Q29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0LFxuICAgICAgICBwb2x5ZmlsbHM6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLFxuICAgICAgICBkZWxlZ2F0ZXM6IGNsaWVudE9wdGlvbnMubW9ja2VkRGVsZWdhdGVzID8/IHtcbiAgICAgICAgICBjcmVhdGVTb2NrZXQ6IG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20oXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LldlYlNvY2tldFxuICAgICAgICAgICksXG4gICAgICAgICAgYXV0aGVudGljYXRlOiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKVxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IGNsaWVudE9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nLFxuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogb3B0aW9uczI/LnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgICBiYXNlVXJsLFxuICAgICAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQLFxuICAgICAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfc3RyZWFtRGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbUluZm8gPSB7XG4gICAgICByb29tOiBuZXdSb29tLFxuICAgICAgdW5zdWJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICByb29tc0J5SWQuc2V0KHJvb21JZCwgbmV3Um9vbUluZm8pO1xuICAgIHNldHVwRGV2VG9vbHMoKCkgPT4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKSk7XG4gICAgbGlua0RldlRvb2xzKHJvb21JZCwgbmV3Um9vbSk7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IG9wdGlvbnMyLmF1dG9Db25uZWN0ID8/IG9wdGlvbnMyLnNob3VsZEluaXRpYWxseUNvbm5lY3QgPz8gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uYXRvYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJZb3UgbmVlZCB0byBwb2x5ZmlsbCBhdG9iIHRvIHVzZSB0aGUgY2xpZW50IGluIHlvdXIgZW52aXJvbm1lbnQuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYXRvYi1wb2x5ZmlsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuYXRvYiA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLmF0b2I7XG4gICAgICB9XG4gICAgICBuZXdSb29tLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXNlUm9vbShuZXdSb29tSW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXIocm9vbUlkLCBvcHRpb25zMikge1xuICAgIGNvbnN0IHsgcm9vbSwgbGVhdmU6IF8gfSA9IGVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMyKTtcbiAgICByZXR1cm4gcm9vbTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUxlYXZlKHJvb21JZCkge1xuICAgIGNvbnN0IHVuc3VicyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8udW5zdWJzID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhdXRoTWFuYWdlci5yZXNldCgpO1xuICAgIGZvciAoY29uc3QgeyByb29tIH0gb2Ygcm9vbXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIWlzSWRsZShyb29tLmdldFN0YXR1cygpKSkge1xuICAgICAgICByb29tLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvZ291dCxcbiAgICAvLyBPbGQsIGRlcHJlY2F0ZWQgQVBJc1xuICAgIGVudGVyLFxuICAgIGdldFJvb20sXG4gICAgbGVhdmU6IGZvcmNlTGVhdmUsXG4gICAgLy8gTmV3LCBwcmVmZXJyZWQgQVBJXG4gICAgZW50ZXJSb29tXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUXG4gICk7XG59XG5mdW5jdGlvbiBnZXRUaHJvdHRsZSh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXCJ0aHJvdHRsZVwiLCB2YWx1ZSwgTUlOX1RIUk9UVExFLCBNQVhfVEhST1RUTEUpO1xufVxuZnVuY3Rpb24gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcbiAgICBcImxvc3RDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUXG4gICk7XG59XG5cbi8vIHNyYy9jcmR0cy91dGlscy50c1xuZnVuY3Rpb24gdG9QbGFpbkxzb24obHNvbikge1xuICBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhsc29uLnRvT2JqZWN0KCkpLmZsYXRNYXAoXG4gICAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IFtba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldXSA6IFtdXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgWy4uLmxzb25dLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBkYXRhOiBbLi4ubHNvbl0ubWFwKChpdGVtKSA9PiB0b1BsYWluTHNvbihpdGVtKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsc29uO1xuICB9XG59XG5cbi8vIHNyYy9pbW11dGFibGUudHNcbmZ1bmN0aW9uIGxzb25PYmplY3RUb0pzb24ob2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbGl2ZU9iamVjdFRvSnNvbihsaXZlT2JqZWN0KSB7XG4gIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QudG9PYmplY3QoKSk7XG59XG5mdW5jdGlvbiBsaXZlTWFwVG9Kc29uKG1hcCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxzb25MaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAobHNvblRvSnNvbik7XG59XG5mdW5jdGlvbiBsaXZlTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUudG9BcnJheSgpKTtcbn1cbmZ1bmN0aW9uIGxzb25Ub0pzb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBsaXZlT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIGxpdmVMaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4gbGl2ZU1hcFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBMaXZlaWZ5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3QodmFsdWUubWFwKGRlZXBMaXZlaWZ5KSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBpbml0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2tleV07XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0W2tleV0gPSBkZWVwTGl2ZWlmeSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdmVPYmplY3QoaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVMaXN0KGxpdmVMaXN0LCBwcmV2LCBuZXh0KSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IHByZXZFbmQgPSBwcmV2Lmxlbmd0aCAtIDE7XG4gIGxldCBuZXh0RW5kID0gbmV4dC5sZW5ndGggLSAxO1xuICBsZXQgcHJldk5vZGUgPSBwcmV2WzBdO1xuICBsZXQgbmV4dE5vZGUgPSBuZXh0WzBdO1xuICBvdXRlcjoge1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgICsraTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICB9XG4gICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICBwcmV2RW5kLS07XG4gICAgICBuZXh0RW5kLS07XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgfVxuICB9XG4gIGlmIChpID4gcHJldkVuZCkge1xuICAgIGlmIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpID4gbmV4dEVuZCkge1xuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpIDw9IHByZXZFbmQgJiYgaSA8PSBuZXh0RW5kKSB7XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgICBjb25zdCBsaXZlTGlzdE5vZGUgPSBsaXZlTGlzdC5nZXQoaSk7XG4gICAgICBpZiAoaXNMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChuZXh0Tm9kZSkpIHtcbiAgICAgICAgcGF0Y2hMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSwgcHJldk5vZGUsIG5leHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVMaXN0LnNldChpLCBkZWVwTGl2ZWlmeShuZXh0Tm9kZSkpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0S2V5KGxpdmVPYmplY3QsIGtleSwgcHJldiwgbmV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmV4dCk7XG4gICAgaWYgKG5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICBlcnJvcjIoXG4gICAgICAgIGBOZXcgc3RhdGUgcGF0aDogJyR7bm9uU2VyaWFsaXphYmxlVmFsdWUucGF0aH0nIHZhbHVlOiAnJHtTdHJpbmcoXG4gICAgICAgICAgbm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWVcbiAgICAgICAgKX0nIGlzIG5vdCBzZXJpYWxpemFibGUuXG5Pbmx5IHNlcmlhbGl6YWJsZSB2YWx1ZSBjYW4gYmUgc3luY2VkIHdpdGggTGl2ZWJsb2Nrcy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCB2YWx1ZSA9IGxpdmVPYmplY3QuZ2V0KGtleSk7XG4gIGlmIChuZXh0ID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LmRlbGV0ZShrZXkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfSBlbHNlIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzTGl2ZUxpc3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocHJldikgJiYgQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHBhdGNoTGl2ZUxpc3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2UgaWYgKGlzTGl2ZU9iamVjdCh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2KSAmJiBpc1BsYWluT2JqZWN0KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0KHJvb3QsIHByZXYsIG5leHQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0S2V5KHJvb3QsIGtleSwgcHJldltrZXldLCBuZXh0W2tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHJvb3QuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyh1cGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgcm9vdC51cGRhdGUodXBkYXRlcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudHNQYXRoKG5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIGlmIChpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQubm9kZS5faW5kZXhPZlBvc2l0aW9uKG5vZGUucGFyZW50LmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQua2V5KTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Lm5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3Qoc3RhdGUsIHVwZGF0ZXMpIHtcbiAgcmV0dXJuIHVwZGF0ZXMucmVkdWNlKFxuICAgIChzdGF0ZTIsIHVwZGF0ZSkgPT4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZTIsIHVwZGF0ZSksXG4gICAgc3RhdGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoID0gZ2V0UGFyZW50c1BhdGgodXBkYXRlLm5vZGUpO1xuICByZXR1cm4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoSXRlbSA9IHBhdGgucG9wKCk7XG4gIGlmIChwYXRoSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcIkxpdmVPYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU9iamVjdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVMaXN0XCI6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTGlzdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBhcnJheVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBzdGF0ZS5tYXAoKHgpID0+IHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RVcGRhdGUgb2YgdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLm1hcChcbiAgICAgICAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpbmRleCA9PT0gbGlzdFVwZGF0ZS5pbmRleCA/IGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSA6IGl0ZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLmluZGV4ID09PSBuZXdTdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUucHVzaChsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNwbGljZShsaXN0VXBkYXRlLmluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggPiBsaXN0VXBkYXRlLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4LCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUuaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTWFwXCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVNYXAgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbLi4uc3RhdGVdO1xuICAgIG5ld0FycmF5W3BhdGhJdGVtXSA9IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoXG4gICAgICBzdGF0ZVtwYXRoSXRlbV0sXG4gICAgICBwYXRoLFxuICAgICAgdXBkYXRlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZVtwYXRoSXRlbV07XG4gICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZUFzT2JqID0gc3RhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZUFzT2JqLFxuICAgICAgICBbcGF0aEl0ZW1dOiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKG5vZGUsIHBhdGgsIHVwZGF0ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3NoYWxsb3cudHNcbmZ1bmN0aW9uIHNoYWxsb3dBcnJheSh4cywgeXMpIHtcbiAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5pcyh4c1tpXSwgeXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2hhbGxvd09iaihvYmpBLCBvYmpCKSB7XG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakEpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpCKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmpCKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleXNBLmV2ZXJ5KFxuICAgIChrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXkpICYmIE9iamVjdC5pcyhvYmpBW2tleV0sIG9iakJba2V5XSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3coYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gIGlmIChpc0FycmF5QSB8fCBpc0FycmF5Qikge1xuICAgIGlmICghaXNBcnJheUEgfHwgIWlzQXJyYXlCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFsbG93QXJyYXkoYSwgYik7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dPYmooYSwgYik7XG59XG5cbi8vIHNyYy9saWIvQXN5bmNDYWNoZS50c1xudmFyIG5vb3AgPSAoKSA9PiB7XG59O1xuZnVuY3Rpb24gaXNTaGFsbG93RXF1YWwoYSwgYikge1xuICBpZiAoYS5pc0xvYWRpbmcgIT09IGIuaXNMb2FkaW5nIHx8IGEuZGF0YSA9PT0gdm9pZCAwICE9PSAoYi5kYXRhID09PSB2b2lkIDApIHx8IGEuZXJyb3IgPT09IHZvaWQgMCAhPT0gKGIuZXJyb3IgPT09IHZvaWQgMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYWxsb3coYS5kYXRhLCBiLmRhdGEpICYmIHNoYWxsb3coYS5lcnJvciwgYi5lcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlSXRlbShrZXksIGFzeW5jRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgJGFzeW5jRnVuY3Rpb24gPSBhc3luYyAoKSA9PiBhc3luY0Z1bmN0aW9uKGtleSk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgaXNJbnZhbGlkOiB0cnVlXG4gIH07XG4gIGxldCBzdGF0ZSA9IHsgaXNMb2FkaW5nOiBmYWxzZSB9O1xuICBsZXQgcHJldmlvdXNTdGF0ZSA9IHsgaXNMb2FkaW5nOiBmYWxzZSB9O1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIGNvbnN0IGlzRXF1YWwgPSBvcHRpb25zPy5pc1N0YXRlRXF1YWwgPz8gaXNTaGFsbG93RXF1YWw7XG4gICAgaWYgKCFpc0VxdWFsKHByZXZpb3VzU3RhdGUsIHN0YXRlKSkge1xuICAgICAgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgZXZlbnRTb3VyY2UyLm5vdGlmeShzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKCFjb250ZXh0LnByb21pc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjb250ZXh0LnByb21pc2U7XG4gICAgICBjb250ZXh0LmlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YSxcbiAgICAgICAgZXJyb3I6IGVycm9yM1xuICAgICAgfTtcbiAgICB9XG4gICAgY29udGV4dC5wcm9taXNlID0gdm9pZCAwO1xuICAgIG5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgY29udGV4dC5pc0ludmFsaWQgPSB0cnVlO1xuICAgIHJldHVybiBnZXQoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKGNvbnRleHQuaXNJbnZhbGlkKSB7XG4gICAgICBpZiAoIWNvbnRleHQucHJvbWlzZSkge1xuICAgICAgICBjb250ZXh0LmlzSW52YWxpZCA9IHRydWU7XG4gICAgICAgIGNvbnRleHQucHJvbWlzZSA9ICRhc3luY0Z1bmN0aW9uKCk7XG4gICAgICAgIHN0YXRlID0geyBpc0xvYWRpbmc6IHRydWUsIGRhdGE6IHN0YXRlLmRhdGEgfTtcbiAgICAgICAgbm90aWZ5KCk7XG4gICAgICB9XG4gICAgICBhd2FpdCByZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMi5vYnNlcnZhYmxlLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZSxcbiAgICByZXZhbGlkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBc3luY0NhY2hlKGFzeW5jRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBjcmVhdGUoa2V5KSB7XG4gICAgbGV0IGNhY2hlSXRlbSA9IGNhY2hlLmdldChrZXkpO1xuICAgIGlmIChjYWNoZUl0ZW0pIHtcbiAgICAgIHJldHVybiBjYWNoZUl0ZW07XG4gICAgfVxuICAgIGNhY2hlSXRlbSA9IGNyZWF0ZUNhY2hlSXRlbShrZXksIGFzeW5jRnVuY3Rpb24sIG9wdGlvbnMpO1xuICAgIGNhY2hlLnNldChrZXksIGNhY2hlSXRlbSk7XG4gICAgcmV0dXJuIGNhY2hlSXRlbTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZShrZXkpLmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKGtleSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KT8uZ2V0U3RhdGUoKTtcbiAgfVxuICBmdW5jdGlvbiByZXZhbGlkYXRlKGtleSkge1xuICAgIHJldHVybiBjcmVhdGUoa2V5KS5yZXZhbGlkYXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY3JlYXRlKGtleSkuc3Vic2NyaWJlKGNhbGxiYWNrKSA/PyBub29wO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZU9uY2Uoa2V5LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjcmVhdGUoa2V5KS5zdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSA/PyBub29wO1xuICB9XG4gIGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY2FjaGUuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNyZWF0ZSxcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBoYXMsXG4gICAgY2xlYXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2spIHtcbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZShjb250ZXh0LmludGVydmFsKTtcbiAgICB9XG4gICAgdm9pZCBjYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGludGVydmFsKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LnN0YXRlICE9PSBcInN0b3BwZWRcIiA/IGNvbnRleHQuaW50ZXJ2YWwgOiBpbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZVJlbWFpbmluZyhyZW1haW5pbmcpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCByZW1haW5pbmcpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KGludGVydmFsKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KGludGVydmFsKSB7XG4gICAgc3RvcCgpO1xuICAgIHN0YXJ0KGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInBhdXNlZFwiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBjb250ZXh0LmludGVydmFsIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U2NoZWR1bGVkQXQpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1haW5pbmcoY29udGV4dC5yZW1haW5pbmdJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgICBpbnRlcnZhbDogbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXN0YXJ0LFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKTtcbiAgfVxuICBjb25zdCBzb3J0ZWRPYmplY3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5yZWR1Y2UoXG4gICAgKHNvcnRlZE9iamVjdDIsIGtleSkgPT4ge1xuICAgICAgc29ydGVkT2JqZWN0MltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gc29ydGVkT2JqZWN0MjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0ZWRPYmplY3QsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgTGl2ZUxpc3QsXG4gIExpdmVNYXAsXG4gIExpdmVPYmplY3QsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgV2Vic29ja2V0Q2xvc2VDb2RlcyxcbiAgYWNrT3AsXG4gIGFzUG9zLFxuICBhc3NlcnQsXG4gIGFzc2VydE5ldmVyLFxuICBiNjRkZWNvZGUsXG4gIGNsb25lTHNvbixcbiAgZmFuY3lfY29uc29sZV9leHBvcnRzIGFzIGNvbnNvbGUsXG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVBc3luY0NhY2hlLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRzQXBpLFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdCxcbiAgbHNvblRvSnNvbixcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBtYWtlUG9zaXRpb24sXG4gIG5uLFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHJhaXNlLFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJQS0dfTkFNRSIsIlBLR19WRVJTSU9OIiwiUEtHX0ZPUk1BVCIsImciLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwiY3Jvc3NMaW5rZWREb2NzIiwiZHVwZXNEb2NzIiwiU1BBQ0UiLCJlcnJvciIsIm1zZyIsInByb2Nlc3MiLCJjb25zb2xlIiwiRXJyb3IiLCJkZXRlY3REdXBlcyIsInBrZ05hbWUiLCJwa2dWZXJzaW9uIiwicGtnRm9ybWF0IiwicGtnSWQiLCJTeW1ib2wiLCJmb3IiLCJwa2dCdWlsZEluZm8iLCJqb2luIiwiYXNzZXJ0TmV2ZXIiLCJfdmFsdWUiLCJlcnJtc2ciLCJhc3NlcnQiLCJjb25kaXRpb24iLCJlcnIiLCJubiIsInZhbHVlIiwiY29udHJvbGxlZFByb21pc2UiLCJmbGFnZ2VyIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJtYWtlRXZlbnRTb3VyY2UiLCJfb25ldGltZU9ic2VydmVycyIsIlNldCIsIl9vYnNlcnZlcnMiLCJfYnVmZmVyIiwicGF1c2UiLCJ1bnBhdXNlIiwiZXZlbnQiLCJub3RpZnkiLCJzdWJzY3JpYmUiLCJjYWxsYmFjayIsImFkZCIsImRlbGV0ZSIsInN1YnNjcmliZU9uY2UiLCJ3YWl0VW50aWwiLCJwcmVkaWNhdGUiLCJ1bnN1YiIsImZpbmFsbHkiLCJub3RpZnlPckJ1ZmZlciIsInB1c2giLCJmb3JFYWNoIiwiY2xlYXIiLCJjb3VudCIsInNpemUiLCJvYnNlcnZhYmxlIiwiZmFuY3lfY29uc29sZV9leHBvcnRzIiwiZXJyb3IyIiwiZXJyb3JXaXRoVGl0bGUiLCJ3YXJuIiwid2FybldpdGhUaXRsZSIsImJhZGdlIiwiYm9sZCIsIndyYXAiLCJtZXRob2QiLCJtZXNzYWdlIiwiYXJncyIsIndyYXBXaXRoVGl0bGUiLCJ0aXRsZSIsImRpc3RhbmNlIiwic3RhdGUxIiwic3RhdGUyIiwiY2h1bmtzMSIsInNwbGl0IiwiY2h1bmtzMiIsIm1pbkxlbiIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJzaGFyZWQiLCJ1cCIsImRvd24iLCJwYXR0ZXJucyIsInRhcmdldFN0YXRlIiwibGV2ZWxzIiwicGFydHMiLCJyZXN1bHQiLCJpIiwic2xpY2UiLCJTYWZlQ29udGV4dCIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbENvbnRleHQiLCJjdXJyIiwiY3VycmVudCIsImFsbG93UGF0Y2hpbmciLCJzZWxmIiwiYWxsb3dlZCIsInBhdGNoYWJsZUNvbnRleHQiLCJwYXRjaCIsImFzc2lnbiIsInBhaXIiLCJlbnRyaWVzIiwia2V5IiwibmV4dElkIiwiRlNNIiwiaW5pdGlhbFN0YXRlIiwic3RhdGVzIiwidmFsdWVzIiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRTdGF0ZU9yTnVsbCIsInJ1bm5pbmdTdGF0ZSIsInN0YXJ0IiwiZW50ZXIiLCJzdG9wIiwiZXhpdCIsImlkIiwiZW50ZXJGbnMiLCJNYXAiLCJjbGVhbnVwU3RhY2siLCJrbm93bkV2ZW50VHlwZXMiLCJhbGxvd2VkVHJhbnNpdGlvbnMiLCJjdXJyZW50Q29udGV4dCIsImV2ZW50SHViIiwiZGlkUmVjZWl2ZUV2ZW50Iiwid2lsbFRyYW5zaXRpb24iLCJkaWRJZ25vcmVFdmVudCIsIndpbGxFeGl0U3RhdGUiLCJkaWRFbnRlclN0YXRlIiwiZXZlbnRzIiwiY29udGV4dCIsImFkZFN0YXRlIiwic3RhdGUiLCJvbkVudGVyIiwibmFtZU9yUGF0dGVybiIsImVudGVyRm4iLCJoYXMiLCJzZXQiLCJvbkVudGVyQXN5bmMiLCJwcm9taXNlRm4iLCJvbk9LIiwib25FcnJvciIsImNhbmNlbGxlZCIsInRoZW4iLCJkYXRhIiwidHJhbnNpdGlvbiIsInR5cGUiLCJyZWFzb24iLCJnZXRTdGF0ZXNNYXRjaGluZyIsIm1hdGNoZXMiLCJlbmRzV2l0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJKU09OIiwic3RyaW5naWZ5IiwiYWRkVHJhbnNpdGlvbnMiLCJtYXBwaW5nIiwic3JjU3RhdGUiLCJtYXAiLCJ0YXJnZXRfIiwidGFyZ2V0Rm4iLCJhZGRUaW1lZFRyYW5zaXRpb24iLCJzdGF0ZU9yUGF0dGVybiIsImFmdGVyMiIsIm1zIiwidGltZW91dElEIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImdldFRhcmdldEZuIiwiZXZlbnROYW1lIiwicG9wIiwiZW50ZXJQYXR0ZXJucyIsInBhdHRlcm4iLCJjbGVhbnVwRm4iLCJzZW5kIiwib2xkU3RhdGUiLCJuZXh0VGFyZ2V0IiwibmV4dFN0YXRlIiwiZWZmZWN0cyIsIkFycmF5IiwiaXNBcnJheSIsImVmZmVjdCIsImZyb20iLCJ0byIsImVmZmVjdHNUb1J1biIsInJhaXNlIiwiaXNQbGFpbk9iamVjdCIsImJsb2IiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJvYmoiLCJ0cnlQYXJzZUpzb24iLCJyYXdNZXNzYWdlIiwicGFyc2UiLCJlIiwiZGVlcENsb25lIiwiYjY0ZGVjb2RlIiwiYjY0dmFsdWUiLCJmb3JtYXR0ZWRWYWx1ZSIsInJlcGxhY2UiLCJkZWNvZGVkVmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJhdG9iIiwiYyIsImNoYXJDb2RlQXQiLCJjb21wYWN0IiwiaXRlbXMiLCJmaWx0ZXIiLCJpdGVtIiwiY29tcGFjdE9iamVjdCIsIm5ld09iaiIsImtleXMiLCJrIiwid2l0aFRpbWVvdXQiLCJtaWxsaXMiLCJ0aW1lcklEIiwidGltZXIkIiwiXyIsInJlamVjdCIsInJhY2UiLCJTZXJ2ZXJNc2dDb2RlIiwiU2VydmVyTXNnQ29kZTIiLCJXZWJzb2NrZXRDbG9zZUNvZGVzIiwiV2Vic29ja2V0Q2xvc2VDb2RlczIiLCJzaG91bGREaXNjb25uZWN0IiwiY29kZSIsInNob3VsZFJlYXV0aCIsInNob3VsZFJldHJ5V2l0aG91dFJlYXV0aCIsImlzSWRsZSIsInN0YXR1cyIsIm5ld1RvTGVnYWN5U3RhdHVzIiwidG9OZXdDb25uZWN0aW9uU3RhdHVzIiwibWFjaGluZSIsInN1Y2Nlc3NDb3VudCIsIkJBQ0tPRkZfREVMQVlTIiwiUkVTRVRfREVMQVkiLCJCQUNLT0ZGX0RFTEFZU19TTE9XIiwiSEVBUlRCRUFUX0lOVEVSVkFMIiwiUE9OR19USU1FT1VUIiwiQVVUSF9USU1FT1VUIiwiU09DS0VUX0NPTk5FQ1RfVElNRU9VVCIsIlN0b3BSZXRyeWluZyIsIkxpdmVibG9ja3NFcnJvciIsIm5leHRCYWNrb2ZmRGVsYXkiLCJjdXJyZW50RGVsYXkiLCJkZWxheXMiLCJmaW5kIiwiZGVsYXkiLCJpbmNyZWFzZUJhY2tvZmZEZWxheSIsImJhY2tvZmZEZWxheSIsImluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5IiwicmVzZXRTdWNjZXNzQ291bnQiLCJsb2ciLCJsZXZlbCIsImxvZ2dlciIsImxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50IiwiY29ubiIsImN0eCIsIlN0cmluZyIsImlzQ2xvc2VFdmVudCIsImxvZ0Nsb3NlRXZlbnQiLCJsb2dQZXJtYW5lbnRDbG9zZSIsImVycm9yMyIsImVuYWJsZVRyYWNpbmciLCJEYXRlIiwiZ2V0VGltZSIsImxvZzIiLCJ0b0ZpeGVkIiwidW5zdWJzIiwiZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzIiwic3RhdHVzRGlkQ2hhbmdlIiwiZGlkQ29ubmVjdCIsImRpZERpc2Nvbm5lY3QiLCJsYXN0U3RhdHVzIiwidW5zdWJzY3JpYmUiLCJjdXJyU3RhdHVzIiwiY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZSIsImRlbGVnYXRlcyIsIm9wdGlvbnMiLCJvbk1lc3NhZ2UiLCJvbkxpdmVibG9ja3NFcnJvciIsImZpcmVFcnJvckV2ZW50IiwiZXJyY29kZSIsImF1dGhWYWx1ZSIsInNvY2tldCIsIlJFQ09OTkVDVCIsIkRJU0NPTk5FQ1QiLCJDT05ORUNUIiwiTkFWSUdBVE9SX09OTElORSIsImF1dGhlbnRpY2F0ZSIsIm9rRXZlbnQiLCJmYWlsZWRFdmVudCIsIm9uU29ja2V0RXJyb3IiLCJvblNvY2tldENsb3NlIiwib25Tb2NrZXRNZXNzYWdlIiwidGVhcmRvd25Tb2NrZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2UiLCJjYXB0dXJlZFByZW1hdHVyZUV2ZW50IiwiY29ubmVjdCQiLCJyZXNvbHZlIiwicmVqIiwiY3JlYXRlU29ja2V0IiwiYWN0b3IkIiwiZGlkUmVjZWl2ZUFjdG9yIiwid2FpdEZvckFjdG9ySWQiLCJzZXJ2ZXJNc2ciLCJhZGRFdmVudExpc3RlbmVyIiwiZmFpbHVyZSIsInNlbmRIZWFydGJlYXQiLCJtYXliZUhlYXJ0YmVhdCIsImRvYyIsImRvY3VtZW50IiwiY2FuWm9tYmllIiwidmlzaWJpbGl0eVN0YXRlIiwiTkFWSUdBVE9SX09GRkxJTkUiLCJXSU5ET1dfR09UX0ZPQ1VTIiwiY3R4MiIsIlBPTkciLCJFWFBMSUNJVF9TT0NLRVRfRVJST1IiLCJyZWFkeVN0YXRlIiwiRVhQTElDSVRfU09DS0VUX0NMT1NFIiwid2luIiwicm9vdCIsIm9uTmV0d29ya09mZmxpbmUiLCJvbk5ldHdvcmtCYWNrT25saW5lIiwib25WaXNpYmlsaXR5Q2hhbmdlIiwiY2xlYW51cHMiLCJlbmFibGVEZWJ1Z0xvZ2dpbmciLCJNYW5hZ2VkU29ja2V0IiwiZ2V0TGVnYWN5U3RhdHVzIiwiZ2V0U3RhdHVzIiwiY29ubmVjdCIsInJlY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJkZXN0cm95IiwiY2xlYW51cCIsIl9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCIsImNhbldyaXRlU3RvcmFnZSIsInNjb3BlcyIsImluY2x1ZGVzIiwiY2FuQ29tbWVudCIsImlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkIiwicGFyc2VBdXRoVG9rZW4iLCJyYXdUb2tlblN0cmluZyIsInRva2VuUGFydHMiLCJwYXlsb2FkIiwicmF3IiwicGFyc2VkIiwiY3JlYXRlQXV0aE1hbmFnZXIiLCJhdXRoT3B0aW9ucyIsImF1dGhlbnRpY2F0aW9uIiwicHJlcGFyZUF1dGhlbnRpY2F0aW9uIiwic2VlblRva2VucyIsInRva2VucyIsImV4cGlyeVRpbWVzIiwicmVxdWVzdFByb21pc2VzIiwicmVzZXQiLCJoYXNDb3JyZXNwb25kaW5nU2NvcGVzIiwicmVxdWVzdGVkU2NvcGUiLCJnZXRDYWNoZWRUb2tlbiIsInJvb21JZCIsIm5vdyIsImNlaWwiLCJ0b2tlbiIsImV4cGlyZXNBdCIsInNwbGljZSIsInJlc291cmNlIiwicGVybXMiLCJtYWtlQXV0aFJlcXVlc3QiLCJmZXRjaGVyIiwicG9seWZpbGxzIiwiZmV0Y2giLCJyZXNwb25zZSIsImZldGNoQXV0aEVuZHBvaW50IiwidXJsIiwicm9vbSIsImdldEF1dGhWYWx1ZSIsInB1YmxpY0FwaUtleSIsImNhY2hlZFRva2VuIiwiY3VycmVudFByb21pc2UiLCJCVUZGRVIiLCJmbG9vciIsImV4cCIsImlhdCIsImF1dGhFbmRwb2ludCIsImZldGNoMiIsImVuZHBvaW50IiwiYm9keSIsImhlYWRlcnMiLCJvayIsInRleHQiLCJ0cmltIiwianNvbiIsImVyIiwiREVGQVVMVF9CQVNFX1VSTCIsIl9icmlkZ2VBY3RpdmUiLCJhY3RpdmF0ZUJyaWRnZSIsInNlbmRUb1BhbmVsIiwiZnVsbE1zZyIsInNvdXJjZSIsImZvcmNlIiwicG9zdE1lc3NhZ2UiLCJldmVudFNvdXJjZSIsIm9uTWVzc2FnZUZyb21QYW5lbCIsIlZFUlNJT04iLCJfZGV2dG9vbHNTZXR1cEhhc1J1biIsInNldHVwRGV2VG9vbHMiLCJnZXRBbGxSb29tcyIsImNsaWVudFZlcnNpb24iLCJ1bnN1YnNCeVJvb21JZCIsInN0b3BTeW5jU3RyZWFtIiwic3RhcnRTeW5jU3RyZWFtIiwiZnVsbFN5bmMiLCJwYXJ0aWFsU3luY0Nvbm5lY3Rpb24iLCJzdG9yYWdlRGlkTG9hZCIsInBhcnRpYWxTeW5jU3RvcmFnZSIsInN0b3JhZ2UiLCJwYXJ0aWFsU3luY01lIiwib3RoZXJzIiwicGFydGlhbFN5bmNPdGhlcnMiLCJ5ZG9jIiwidXBkYXRlIiwic3luY1lkb2NVcGRhdGUiLCJjdXN0b21FdmVudCIsImV2ZW50RGF0YSIsImZvcndhcmRFdmVudCIsImxvYWRlZEF0IiwiZXZlbnRDb3VudGVyIiwibmV4dEV2ZW50SWQiLCJjb25uZWN0aW9uSWQiLCJnZXRTdG9yYWdlU25hcHNob3QiLCJ0b1RyZWVOb2RlIiwibWUiLCJfX2ludGVybmFsIiwiZ2V0U2VsZl9mb3JEZXZUb29scyIsImdldE90aGVyc19mb3JEZXZUb29scyIsImZldGNoWURvYyIsInJvb21DaGFubmVsTGlzdGVuZXJzIiwic3RvcFJvb21DaGFubmVsTGlzdGVuZXIiLCJsaXN0ZW5lciIsImxpbmtEZXZUb29scyIsInVubGlua0RldlRvb2xzIiwiX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRlIiwiZGVwcmVjYXRlSWYiLCJ0aHJvd1VzYWdlRXJyb3IiLCJ1c2FnZUVycm9yIiwiZXJyb3JJZiIsImlzQ29tbWVudEJvZHlQYXJhZ3JhcGgiLCJlbGVtZW50IiwiaXNDb21tZW50Qm9keVRleHQiLCJpc0NvbW1lbnRCb2R5TWVudGlvbiIsImlzQ29tbWVudEJvZHlMaW5rIiwiY29tbWVudEJvZHlFbGVtZW50c0d1YXJkcyIsInBhcmFncmFwaCIsImxpbmsiLCJtZW50aW9uIiwiY29tbWVudEJvZHlFbGVtZW50c1R5cGVzIiwidHJhdmVyc2VDb21tZW50Qm9keSIsImVsZW1lbnRPclZpc2l0b3IiLCJwb3NzaWJseVZpc2l0b3IiLCJjb250ZW50IiwiZ3VhcmQiLCJ2aXNpdG9yIiwiYmxvY2siLCJpbmxpbmUiLCJjaGlsZHJlbiIsImdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSIsIm1lbnRpb25lZElkcyIsInJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkiLCJyZXNvbHZlVXNlcnMiLCJyZXNvbHZlZFVzZXJzIiwidXNlcklkcyIsInVzZXJzIiwiaW5kZXgiLCJ1c2VySWQiLCJ1c2VyIiwiaHRtbEVzY2FwYWJsZXMiLCJodG1sRXNjYXBhYmxlc1JlZ2V4IiwiUmVnRXhwIiwiZW50aXR5IiwiaHRtbFNhZmUiLCJIdG1sU2FmZVN0cmluZyIsImpvaW5IdG1sIiwic3RyaW5ncyIsImZpbGwiLCJlc2NhcGVIdG1sIiwiY2hhcmFjdGVyIiwiX3N0cmluZ3MiLCJfdmFsdWVzIiwicmVkdWNlIiwic3RyIiwiaHRtbCIsIm1hcmtkb3duRXNjYXBhYmxlcyIsIm1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4Iiwiam9pbk1hcmtkb3duIiwiTWFya2Rvd25TYWZlU3RyaW5nIiwiZXNjYXBlTWFya2Rvd24iLCJtYXJrZG93biIsInRvQWJzb2x1dGVVcmwiLCJzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMiLCJzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyIsIml0YWxpYyIsInN0cmlrZXRocm91Z2giLCJocmVmIiwic3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIiwic3RyaW5naWZ5Q29tbWVudEJvZHkiLCJmb3JtYXQiLCJzZXBhcmF0b3IiLCJlbGVtZW50cyIsImJsb2NrcyIsImZsYXRNYXAiLCJibG9ja0luZGV4IiwiaW5saW5lcyIsImlubGluZUluZGV4IiwiY29udmVydFRvQ29tbWVudERhdGEiLCJlZGl0ZWRBdCIsImNyZWF0ZWRBdCIsInJlYWN0aW9ucyIsInJlYWN0aW9uIiwiZGVsZXRlZEF0IiwiY29udmVydFRvVGhyZWFkRGF0YSIsInVwZGF0ZWRBdCIsImNvbW1lbnRzIiwiY29tbWVudCIsImNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24iLCJnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZSIsIkNvbW1lbnRzQXBpRXJyb3IiLCJkZXRhaWxzIiwiY3JlYXRlQ29tbWVudHNBcGkiLCJjb25maWciLCJmZXRjaEpzb24iLCJmZXRjaEFwaSIsImVycm9yQm9keSIsInN0YXR1c1RleHQiLCJyb29tSWQyIiwiVVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYmFzZVVybCIsIkF1dGhvcml6YXRpb24iLCJnZXRUaHJlYWRzIiwicXVlcnkiLCJtZXRhZGF0YSIsInRocmVhZCIsImNyZWF0ZVRocmVhZCIsImNvbW1lbnRJZCIsInRocmVhZElkIiwiZWRpdFRocmVhZE1ldGFkYXRhIiwiY3JlYXRlQ29tbWVudCIsImVkaXRDb21tZW50IiwiZGVsZXRlQ29tbWVudCIsImFkZFJlYWN0aW9uIiwiZW1vamkiLCJyZW1vdmVSZWFjdGlvbiIsIk1JTl9DT0RFIiwiTUFYX0NPREUiLCJOVU1fRElHSVRTIiwiWkVSTyIsIm50aERpZ2l0IiwiT05FIiwiWkVST19OSU5FIiwibiIsImZyb21DaGFyQ29kZSIsIm1ha2VQb3NpdGlvbiIsIngiLCJ5IiwiYmV0d2VlbiIsImFmdGVyIiwiYmVmb3JlIiwicG9zIiwibGFzdEluZGV4Iiwic3Vic3RyaW5nIiwibG8iLCJoaSIsIl9iZXR3ZWVuIiwibG9MZW4iLCJoaUxlbiIsImxvQ29kZSIsImhpQ29kZSIsInJlcGVhdCIsInN1ZmZpeCIsIm5pbmVzIiwidGFrZU4iLCJNSU5fTk9OX1pFUk9fQ09ERSIsImlzUG9zIiwibGFzdElkeCIsImxhc3QiLCJjb252ZXJ0VG9Qb3MiLCJjb2RlcyIsImFzUG9zIiwiT3BDb2RlIiwiT3BDb2RlMiIsImFja09wIiwib3BJZCIsImlzQWNrT3AiLCJvcCIsImNyZHRBc0xpdmVOb2RlIiwiSGFzUGFyZW50Iiwibm9kZSIsImZyZWV6ZSIsIk5vUGFyZW50IiwiT3JwaGFuZWQiLCJvbGRLZXkiLCJvbGRQb3MiLCJBYnN0cmFjdENyZHQiLCJfcGFyZW50IiwiX2dldFBhcmVudEtleU9yVGhyb3ciLCJwYXJlbnQiLCJfcGFyZW50UG9zIiwiX3Bvb2wiLCJfX3Bvb2wiLCJfaWQiLCJfX2lkIiwiX3BhcmVudEtleSIsIl9hcHBseSIsIl9pc0xvY2FsIiwiX2RldGFjaENoaWxkIiwibW9kaWZpZWQiLCJfc2V0UGFyZW50TGluayIsIm5ld1BhcmVudE5vZGUiLCJuZXdQYXJlbnRLZXkiLCJfYXR0YWNoIiwicG9vbCIsImFkZE5vZGUiLCJfZGV0YWNoIiwiZGVsZXRlTm9kZSIsImludmFsaWRhdGUiLCJfY2FjaGVkSW1tdXRhYmxlIiwiX2NhY2hlZFRyZWVOb2RlIiwiX2NhY2hlZFRyZWVOb2RlS2V5IiwiX3RvVHJlZU5vZGUiLCJ0b0ltbXV0YWJsZSIsIl90b0ltbXV0YWJsZSIsIkNyZHRUeXBlIiwiQ3JkdFR5cGUyIiwiaXNSb290Q3JkdCIsImNyZHQiLCJpc0NoaWxkQ3JkdCIsInBhcmVudElkIiwicGFyZW50S2V5IiwibmFub2lkIiwiYWxwaGFiZXQiLCJsZW4iLCJjaGFyQXQiLCJyYW5kb20iLCJMaXZlUmVnaXN0ZXIiLCJfTGl2ZVJlZ2lzdGVyIiwiX2RhdGEiLCJfZGVzZXJpYWxpemUiLCJfcGFyZW50VG9DaGlsZHJlbiIsInJlZ2lzdGVyIiwiX3RvT3BzIiwiZ2VuZXJhdGVPcElkIiwiX3NlcmlhbGl6ZSIsIl9hdHRhY2hDaGlsZCIsIl9vcCIsIl9jcmR0IiwiaXNMb2NhbCIsImNsb25lIiwiY29tcGFyZU5vZGVQb3NpdGlvbiIsIml0ZW1BIiwiaXRlbUIiLCJwb3NBIiwicG9zQiIsIkxpdmVMaXN0IiwiX0xpdmVMaXN0IiwiX2l0ZW1zIiwiX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMiLCJXZWFrU2V0IiwiX3VuYWNrbm93bGVkZ2VkU2V0cyIsInBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJsc29uVG9MaXZlTm9kZSIsInBhcmVudFRvQ2hpbGRyZW4iLCJsaXN0IiwiaWQyIiwiY2hpbGQiLCJkZXNlcmlhbGl6ZSIsIl9pbnNlcnRBbmRTb3J0Iiwib3BzIiwicGFyZW50S2V5MiIsImNoaWxkT3BzIiwiSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbiIsImNoaWxkT3BJZCIsIl9zb3J0SXRlbXMiLCJzb3J0IiwiX2luZGV4T2ZQb3NpdGlvbiIsImZpbmRJbmRleCIsImdlbmVyYXRlSWQiLCJfYXBwbHlTZXRSZW1vdGUiLCJjcmVhdGlvbk9wVG9MaXZlTm9kZSIsImRlbGV0ZWRJZCIsImluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiIsIml0ZW1XaXRoU2FtZVBvc2l0aW9uIiwibWFrZVVwZGF0ZSIsInNldERlbHRhIiwicmV2ZXJzZSIsImRlbHRhIiwiZGVsZXRlRGVsdGEyIiwiX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24iLCJ1cGRhdGVzIiwiaW5zZXJ0RGVsdGEiLCJfYXBwbHlTZXRBY2siLCJkZWxldGVkRGVsdGEiLCJ1bmFja25vd2xlZGdlZE9wSWQiLCJleGlzdGluZ0l0ZW0iLCJkZWxldGVEZWx0YSIsInByZXZpb3VzSW5kZXgiLCJpbmRleE9mIiwibmV3SW5kZXgiLCJtb3ZlRGVsdGEiLCJvcnBoYW4iLCJnZXROb2RlIiwicmVjcmVhdGVkSXRlbUluZGV4IiwibmV3SXRlbSIsIl9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydCIsImRlbGV0ZWRJdGVtIiwiX2FwcGx5UmVtb3RlSW5zZXJ0IiwiZXhpc3RpbmdJdGVtSW5kZXgiLCJfc2hpZnRJdGVtUG9zaXRpb24iLCJfYXBwbHlJbnNlcnRBY2siLCJpdGVtSW5kZXhBdFBvc2l0aW9uIiwib2xkUG9zaXRpb25JbmRleCIsIl9hcHBseUluc2VydFVuZG9SZWRvIiwibmV3S2V5IiwiYmVmb3JlMiIsIl9hcHBseVNldFVuZG9SZWRvIiwiaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSIsImludGVudCIsImluZGV4VG9EZWxldGUiLCJfYXBwbHlTZXRDaGlsZEtleVJlbW90ZSIsInByZXZpb3VzS2V5IiwiX2FwcGx5U2V0Q2hpbGRLZXlBY2siLCJfYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvIiwiX3NldENoaWxkS2V5IiwiYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUiLCJpbnNlcnQiLCJkaXNwYXRjaCIsIm1vdmUiLCJ0YXJnZXRJbmRleCIsImJlZm9yZVBvc2l0aW9uIiwiYWZ0ZXJQb3NpdGlvbiIsInByZXZpb3VzUG9zaXRpb24iLCJzdG9yYWdlVXBkYXRlcyIsImNoaWxkUmVjb3JkSWQiLCJyZXZlcnNlT3BzIiwidXBkYXRlRGVsdGEiLCJjaGlsZElkIiwiZXhpc3RpbmdJZCIsInRvQXJyYXkiLCJlbnRyeSIsImxpdmVOb2RlVG9Mc29uIiwiZXZlcnkiLCJjYWxsYmFja2ZuIiwic2VhcmNoRWxlbWVudCIsImZyb21JbmRleCIsImxhc3RJbmRleE9mIiwic29tZSIsIkxpdmVMaXN0SXRlcmF0b3IiLCJzaGlmdGVkUG9zaXRpb24iLCJfaW5uZXJJdGVyYXRvciIsImxpdmVMaXN0IiwiZGVsdGFVcGRhdGVzIiwiZmlyc3RPcCIsIkxpdmVNYXAiLCJfTGl2ZU1hcCIsImVudHJpZXMyIiwidW5hY2tub3dsZWRnZWRTZXQiLCJtYXBwZWRFbnRyaWVzIiwiX21hcCIsIl9pdGVtIiwiX2tleSIsImlzTGl2ZU5vZGUiLCJsYXN0VXBkYXRlT3BJZCIsInByZXZpb3VzVmFsdWUiLCJ0aGlzSWQiLCJzdG9yYWdlVXBkYXRlIiwib2xkVmFsdWUiLCJpbm5lckl0ZXJhdG9yIiwiaXRlcmF0b3JWYWx1ZSIsImtleTIiLCJ2YWwiLCJMaXZlT2JqZWN0IiwiX0xpdmVPYmplY3QiLCJfcHJvcFRvTGFzdFVwZGF0ZSIsIl9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuIiwidHVwbGUiLCJfZnJvbUl0ZW1zIiwibGl2ZU9iaiIsIl9kZXNlcmlhbGl6ZUNoaWxkcmVuIiwiZGVzZXJpYWxpemVUb0xzb24iLCJpc0xpdmVTdHJ1Y3R1cmUiLCJjcmVhdGlvbk9wVG9Mc29uIiwiX2FwcGx5VXBkYXRlIiwiX2FwcGx5RGVsZXRlT2JqZWN0S2V5IiwiaXNNb2RpZmllZCIsInJldmVyc2VVcGRhdGUiLCJ1bnNoaWZ0IiwidG9PYmplY3QiLCJmcm9tRW50cmllcyIsImtleUFzU3RyaW5nIiwibmV3VmFsdWUiLCJ1cGRhdGVkUHJvcHMiLCJyZXZlcnNlVXBkYXRlT3AiLCJuZXdBdHRhY2hDaGlsZE9wcyIsImNyZWF0ZUNyZHRPcCIsIm5vZGVJZCIsImlzU2FtZU5vZGVPckNoaWxkT2YiLCJpc0xpdmVMaXN0IiwiaXNMaXZlTWFwIiwiaXNMaXZlT2JqZWN0IiwiaXNMaXZlUmVnaXN0ZXIiLCJjbG9uZUxzb24iLCJnZXRUcmVlc0RpZmZPcGVyYXRpb25zIiwiY3VycmVudEl0ZW1zIiwibmV3SXRlbXMiLCJjdXJyZW50Q3JkdCIsIm1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMiLCJmaXJzdCIsInNlY29uZCIsIm1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMiLCJtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyIsImNvbmNhdCIsIm1lcmdlU3RvcmFnZVVwZGF0ZXMiLCJpc1BsYWluIiwiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwicGF0aCIsIm5lc3RlZFZhbHVlIiwibmVzdGVkUGF0aCIsIm5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJ0cmFjZVJvb3QiLCJlcnJvckxpa2UiLCJzdGFjayIsImlzSnNvblNjYWxhciIsImlzSnNvbkFycmF5IiwiaXNKc29uT2JqZWN0IiwiQ2xpZW50TXNnQ29kZSIsIkNsaWVudE1zZ0NvZGUyIiwibWVyZ2UiLCJ1cGRhdGVkIiwiSW1tdXRhYmxlUmVmIiwiX2V2IiwiZGlkSW52YWxpZGF0ZSIsIl9jYWNoZSIsIm1ha2VVc2VyIiwicHJlc2VuY2UiLCJpbmZvIiwiY2FuV3JpdGUiLCJpc1JlYWRPbmx5IiwiT3RoZXJzUmVmIiwiX2Nvbm5lY3Rpb25zIiwiX3ByZXNlbmNlcyIsIl91c2VycyIsImNvbm5lY3Rpb25JZHMiLCJnZXRVc2VyIiwiTnVtYmVyIiwiY2xlYXJPdGhlcnMiLCJfZ2V0VXNlciIsImNhY2hlZFVzZXIiLCJjb21wdXRlZFVzZXIiLCJfaW52YWxpZGF0ZVVzZXIiLCJzZXRDb25uZWN0aW9uIiwibWV0YVVzZXJJZCIsIm1ldGFVc2VySW5mbyIsInJlbW92ZUNvbm5lY3Rpb24iLCJzZXRPdGhlciIsInBhdGNoT3RoZXIiLCJvbGRQcmVzZW5jZSIsIm5ld1ByZXNlbmNlIiwiUGF0Y2hhYmxlUmVmIiwib2xkRGF0YSIsIm5ld0RhdGEiLCJWYWx1ZVJlZiIsImluaXRpYWxWYWx1ZSIsIkRlcml2ZWRSZWYiLCJ0cmFuc2Zvcm1GbiIsIm90aGVyUmVmcyIsIl9yZWZzIiwicmVmIiwiX3RyYW5zZm9ybSIsIk1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFIiwibWFrZUlkRmFjdG9yeSIsInVzZXJUb1RyZWVOb2RlIiwiaW5zdGFsbEJhY2tncm91bmRUYWJTcHkiLCJpbkJhY2tncm91bmRTaW5jZSIsImNyZWF0ZVJvb20iLCJpbml0aWFsUHJlc2VuY2UiLCJpbml0aWFsU3RvcmFnZSIsInVuaW5zdGFsbEJnVGFiU3B5IiwiYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQiLCJnZXRTdG9yYWdlU3RhdHVzIiwibWFuYWdlZFNvY2tldCIsImJ1ZmZlciIsImZsdXNoVGltZXJJRCIsImxhc3RGbHVzaGVkQXQiLCJwcmVzZW5jZVVwZGF0ZXMiLCJtZXNzYWdlcyIsInN0b3JhZ2VPcGVyYXRpb25zIiwic3RhdGljU2Vzc2lvbkluZm8iLCJkeW5hbWljU2Vzc2lvbkluZm8iLCJteVByZXNlbmNlIiwiaWRGYWN0b3J5IiwiY2xvY2siLCJvcENsb2NrIiwibm9kZXMiLCJ1bmRvU3RhY2siLCJyZWRvU3RhY2siLCJwYXVzZWRIaXN0b3J5IiwiYWN0aXZlQmF0Y2giLCJ1bmFja25vd2xlZGdlZE9wcyIsIm9wU3RhY2tUcmFjZXMiLCJkb05vdEJhdGNoVXBkYXRlcyIsImNiIiwiYmF0Y2hVcGRhdGVzIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJsYXN0VG9rZW5LZXkiLCJvblN0YXR1c0RpZENoYW5nZSIsIm5ld1N0YXR1cyIsInRva2VuS2V5IiwidWlkIiwidXNlckluZm8iLCJ1aSIsIm5vdGlmeVNlbGZDaGFuZ2VkIiwiX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCIsIl9oYXNMb3N0Q29ubmVjdGlvbiIsImhhbmRsZUNvbm5lY3Rpb25Mb3NzRXZlbnQiLCJsb3N0Q29ubmVjdGlvbiIsImxvc3RDb25uZWN0aW9uVGltZW91dCIsIm9uRGlkQ29ubmVjdCIsIl9nZXRTdG9yYWdlJCIsInJlZnJlc2hTdG9yYWdlIiwiZmx1c2giLCJmbHVzaE5vd09yU29vbiIsIm9uRGlkRGlzY29ubmVjdCIsImhhbmRsZVNlcnZlck1lc3NhZ2UiLCJnZXRDb25uZWN0aW9uSWQiLCJzdGFja1RyYWNlIiwiYWRkVG9VbmRvU3RhY2siLCJkaXNwYXRjaE9wcyIsImNvbm5lY3Rpb24iLCJoaXN0b3J5Iiwic3RvcmFnZVN0YXR1cyIsInN0cmVhbUZldGNoIiwiYXV0aFRva2VuT3JQdWJsaWNBcGlLZXkiLCJodHRwUG9zdFRvUm9vbSIsInNlbmRNZXNzYWdlcyIsInNlcmlhbGl6ZWRQYXlsb2FkIiwibm9uY2UiLCJ1bnN0YWJsZV9mYWxsYmFja1RvSFRUUCIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwicmVzcCIsInN0YXRpY1Nlc3Npb24iLCJkeW5hbWljU2Vzc2lvbiIsImFjdG9yIiwiX2xhc3RTZWxmIiwiYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyIiwiY3VyclNlbGYiLCJzZWxmQXNUcmVlTm9kZSIsImNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlIiwidXBkYXRlUm9vdCIsInN0YWNrU2l6ZUJlZm9yZSIsImFwcGx5T3BzIiwiX2FkZFRvUmVhbFVuZG9TdGFjayIsImhpc3RvcnlPcHMiLCJzaGlmdCIsIm9uSGlzdG9yeUNoYW5nZSIsIm90aGVyc1VwZGF0ZXMiLCJ1cGRhdGVzMiIsIm5vdGlmeVN0b3JhZ2VTdGF0dXMiLCJyYXdPcHMiLCJvdXRwdXQiLCJjcmVhdGVkTm9kZUlkcyIsImRlbGV0ZWQiLCJhcHBseU9wUmVzdWx0IiwiYXBwbHlPcCIsInBhcmVudE5vZGUiLCJ1cGRhdGVQcmVzZW5jZSIsIm9wdGlvbnMyIiwib2xkVmFsdWVzIiwib3ZlcnJpZGVWYWx1ZSIsImFkZFRvSGlzdG9yeSIsIm9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlIiwidGFyZ2V0QWN0b3IiLCJvbGRVc2VyIiwibmV3VXNlciIsIm9uVXNlckxlZnRNZXNzYWdlIiwib25Sb29tU3RhdGVNZXNzYWdlIiwiY2FuVW5kbyIsImNhblJlZG8iLCJvblVzZXJKb2luZWRNZXNzYWdlIiwicGFyc2VTZXJ2ZXJNZXNzYWdlIiwicGFyc2VTZXJ2ZXJNZXNzYWdlcyIsImFwcGx5QW5kU2VuZE9wcyIsIm9mZmxpbmVPcHMiLCJ1c2VySm9pbmVkVXBkYXRlIiwib3RoZXJzUHJlc2VuY2VVcGRhdGUiLCJ1IiwiZXZlbnQyIiwicHJvY2Vzc0luaXRpYWxTdG9yYWdlIiwiYXBwbHlSZXN1bHQiLCJ0cmFjZXMiLCJvcElkcyIsInRyYWNlIiwic3RvcmFnZU9wcyIsImVsYXBzZWRNaWxsaXMiLCJ0aHJvdHRsZURlbGF5IiwibWVzc2FnZXNUb0ZsdXNoIiwic2VyaWFsaXplQnVmZmVyIiwidXBkYXRlWURvYyIsImd1aWQiLCJjbGllbnRNc2ciLCJicm9hZGNhc3RFdmVudCIsInNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5IiwiX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSIsInN0cmVhbVN0b3JhZ2UiLCJ1bnN0YWJsZV9zdHJlYW1EYXRhIiwic3RhcnRMb2FkaW5nU3RvcmFnZSIsImdldFN0b3JhZ2UiLCJ2ZWN0b3IiLCJtIiwidW5kbyIsInJlZG8iLCJiYXRjaCIsInJldHVyblZhbHVlIiwiY3VycmVudEJhdGNoIiwicGF1c2VIaXN0b3J5IiwicmVzdW1lSGlzdG9yeSIsIl9sYXN0U3RvcmFnZVN0YXR1cyIsIm90aGVyc19mb3JEZXZUb29scyIsIm90aGVyIiwiY29tbWVudHNBcGkiLCJwcmVzZW5jZUJ1ZmZlciIsIm5vZGVDb3VudCIsInNpbXVsYXRlIiwiZXhwbGljaXRDbG9zZSIsInJhd1NlbmQiLCJtYWtlQ2xhc3NpY1N1YnNjcmliZUZuIiwicmVzdW1lIiwiZ2V0Q29ubmVjdGlvblN0YXRlIiwiZ2V0U2VsZiIsImdldFByZXNlbmNlIiwiZ2V0T3RoZXJzIiwic3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5IiwicmVsYXRlZFVwZGF0ZXMiLCJzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkiLCJpc1Jvb21FdmVudE5hbWUiLCJpbnRlcm5hbEV2ZW50Iiwic3RvcmFnZUNhbGxiYWNrIiwiaXNEZWVwIiwibm9kZUNhbGxiYWNrIiwibWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20iLCJhdXRoTWFuYWdlciIsIm1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20iLCJXZWJTb2NrZXRQb2x5ZmlsbCIsIndzIiwiV2ViU29ja2V0IiwicHJvdG9jb2wiLCJwYXRobmFtZSIsInNlYXJjaFBhcmFtcyIsIk1JTl9USFJPVFRMRSIsIk1BWF9USFJPVFRMRSIsIkRFRkFVTFRfVEhST1RUTEUiLCJNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVQiLCJNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQiLCJERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUIiwiZ2V0QmFzZVVybEZyb21DbGllbnRPcHRpb25zIiwiY2xpZW50T3B0aW9ucyIsImNyZWF0ZUNsaWVudCIsImdldFRocm90dGxlIiwidGhyb3R0bGUiLCJnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQiLCJnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCIsInJvb21zQnlJZCIsInRlYXJkb3duUm9vbSIsImxlYXNlUm9vbSIsImxlYXZlIiwiZW50ZXJSb29tIiwiZXhpc3RpbmciLCJuZXdSb29tIiwibW9ja2VkRGVsZWdhdGVzIiwibmV3Um9vbUluZm8iLCJzaG91bGRDb25uZWN0IiwiYXV0b0Nvbm5lY3QiLCJzaG91bGRJbml0aWFsbHlDb25uZWN0IiwiZ2V0Um9vbSIsImZvcmNlTGVhdmUiLCJsb2dvdXQiLCJjaGVja0JvdW5kcyIsIm9wdGlvbiIsIm1heCIsInJlY29tbWVuZGVkTWluIiwidG9QbGFpbkxzb24iLCJsc29uIiwibGl2ZWJsb2Nrc1R5cGUiLCJsc29uT2JqZWN0VG9Kc29uIiwibHNvblRvSnNvbiIsImxpdmVPYmplY3RUb0pzb24iLCJsaXZlT2JqZWN0IiwibGl2ZU1hcFRvSnNvbiIsImxzb25MaXN0VG9Kc29uIiwibGl2ZUxpc3RUb0pzb24iLCJkZWVwTGl2ZWlmeSIsImluaXQiLCJwYXRjaExpdmVMaXN0IiwicHJldiIsInByZXZFbmQiLCJuZXh0RW5kIiwicHJldk5vZGUiLCJuZXh0Tm9kZSIsIm91dGVyIiwibG9jYWxJIiwibGl2ZUxpc3ROb2RlIiwicGF0Y2hMaXZlT2JqZWN0IiwicGF0Y2hMaXZlT2JqZWN0S2V5Iiwibm9uU2VyaWFsaXphYmxlVmFsdWUiLCJnZXRQYXJlbnRzUGF0aCIsImxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdCIsImxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUiLCJsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlIiwicGF0aEl0ZW0iLCJuZXdTdGF0ZSIsImxpc3RVcGRhdGUiLCJuZXdBcnJheSIsInN0YXRlQXNPYmoiLCJzaGFsbG93QXJyYXkiLCJ4cyIsInlzIiwiaXMiLCJzaGFsbG93T2JqIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImhhc093blByb3BlcnR5Iiwic2hhbGxvdyIsImEiLCJiIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsIm5vb3AiLCJpc1NoYWxsb3dFcXVhbCIsImlzTG9hZGluZyIsImNyZWF0ZUNhY2hlSXRlbSIsImFzeW5jRnVuY3Rpb24iLCIkYXN5bmNGdW5jdGlvbiIsImlzSW52YWxpZCIsInByZXZpb3VzU3RhdGUiLCJldmVudFNvdXJjZTIiLCJpc0VxdWFsIiwiaXNTdGF0ZUVxdWFsIiwicmV2YWxpZGF0ZSIsImdldFN0YXRlIiwiY3JlYXRlQXN5bmNDYWNoZSIsImNhY2hlIiwiY3JlYXRlIiwiY2FjaGVJdGVtIiwibWFrZVBvbGxlciIsInRpbWVvdXRIYW5kbGUiLCJpbnRlcnZhbCIsImxhc3RTY2hlZHVsZWRBdCIsInJlbWFpbmluZ0ludGVydmFsIiwicG9sbCIsInNjaGVkdWxlIiwicGVyZm9ybWFuY2UiLCJzY2hlZHVsZVJlbWFpbmluZyIsInJlbWFpbmluZyIsInJlc3RhcnQiLCJvYmplY3QiLCJzb3J0ZWRPYmplY3QiLCJzb3J0ZWRPYmplY3QyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   shallow: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n/* harmony export */   useRoomContextBundle: () => (/* binding */ useRoomContextBundle)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createRoomContext,shallow,useRoomContextBundle auto */ // src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.9.7\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n// src/factory.tsx\n\n\n\n\n// src/comments/CommentsRoom.tsx\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\n// src/comments/lib/revalidation.ts\n\n// src/comments/lib/use-is-document-visible.ts\n\nfunction useIsDocumentVisible() {\n    const isVisible = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n    return isVisible;\n}\nfunction subscribe(onStoreChange) {\n    document.addEventListener(\"visibilitychange\", onStoreChange);\n    return ()=>{\n        document.removeEventListener(\"visibilitychange\", onStoreChange);\n    };\n}\nfunction getSnapshot() {\n    const isDocumentDefined = typeof document !== \"undefined\";\n    return isDocumentDefined ? document.visibilityState === \"visible\" : true;\n}\n// src/comments/lib/use-is-online.ts\n\n\nfunction useIsOnline() {\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((onStoreChange)=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n            onStoreChange();\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n            onStoreChange();\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const getSnapshot2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return isOnlineRef.current;\n    }, []);\n    const isOnline = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);\n    return isOnline;\n}\n// src/comments/lib/revalidation.ts\nvar DEFAULT_ERROR_RETRY_INTERVAL = 5e3;\nvar DEFAULT_MAX_ERROR_RETRY_COUNT = 5;\nvar DEFAULT_DEDUPING_INTERVAL = 2e3;\nvar timestamp = 0;\nfunction useRevalidateCache(manager, fetcher, options = {}) {\n    const isOnlineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const { dedupingInterval = DEFAULT_DEDUPING_INTERVAL, errorRetryInterval = DEFAULT_ERROR_RETRY_INTERVAL, errorRetryCount = DEFAULT_MAX_ERROR_RETRY_COUNT } = options;\n    const _revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ shouldDedupe, retryCount = 0 })=>{\n        let startAt;\n        const shouldStartRequest = !manager.getRequest() || !shouldDedupe;\n        function deleteActiveRequest() {\n            const activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            if (activeRequest.timestamp !== startAt) return;\n            manager.setRequest(void 0);\n        }\n        function handleError() {\n            const timeout = ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) * errorRetryInterval;\n            if (retryCount > errorRetryCount) return;\n            setTimeout(()=>{\n                void _revalidateCache({\n                    shouldDedupe: false,\n                    retryCount: retryCount + 1\n                });\n            }, timeout);\n        }\n        if (shouldStartRequest) {\n            manager.setRequest({\n                fetcher: fetcher(),\n                timestamp: ++timestamp\n            });\n        }\n        try {\n            let activeRequest = manager.getRequest();\n            if (!activeRequest) return;\n            startAt = activeRequest.timestamp;\n            const newData = await activeRequest.fetcher;\n            if (shouldStartRequest) {\n                setTimeout(deleteActiveRequest, dedupingInterval);\n            }\n            activeRequest = manager.getRequest();\n            if (!activeRequest || activeRequest.timestamp !== startAt) return;\n            const activeMutation = manager.getMutation();\n            if (activeMutation && (activeMutation.startTime > startAt || activeMutation.endTime > startAt || activeMutation.endTime === 0)) {\n                return;\n            }\n            manager.setCache(newData);\n        } catch (err) {\n            deleteActiveRequest();\n            const isVisible = document.visibilityState === \"visible\";\n            const isOnline = isOnlineRef.current;\n            if (shouldStartRequest && isVisible && isOnline) handleError();\n            manager.setError(err);\n        }\n        return;\n    }, [\n        manager,\n        fetcher,\n        dedupingInterval,\n        errorRetryInterval,\n        errorRetryCount\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        function handleIsOnline() {\n            isOnlineRef.current = true;\n        }\n        function handleIsOffline() {\n            isOnlineRef.current = false;\n        }\n        window.addEventListener(\"online\", handleIsOnline);\n        window.addEventListener(\"offline\", handleIsOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", handleIsOnline);\n            window.removeEventListener(\"offline\", handleIsOffline);\n        };\n    }, []);\n    const revalidateCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ shouldDedupe })=>{\n        return _revalidateCache({\n            shouldDedupe,\n            retryCount: 0\n        });\n    }, [\n        _revalidateCache\n    ]);\n    return revalidateCache;\n}\nfunction useMutate(manager, revalidateCache) {\n    const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (data, options)=>{\n        const beforeMutationTimestamp = ++timestamp;\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: 0\n        });\n        const currentCache = manager.getCache();\n        manager.setCache(options.optimisticData);\n        let error;\n        try {\n            await data;\n        } catch (err) {\n            error = err;\n        }\n        const activeMutation = manager.getMutation();\n        if (activeMutation && beforeMutationTimestamp !== activeMutation.startTime) {\n            if (error) throw error;\n            return;\n        }\n        if (error) {\n            manager.setCache(currentCache);\n        }\n        manager.setMutation({\n            startTime: beforeMutationTimestamp,\n            endTime: ++timestamp\n        });\n        manager.setRequest(void 0);\n        void revalidateCache({\n            shouldDedupe: false\n        });\n        if (error) throw error;\n    }, [\n        manager,\n        revalidateCache\n    ]);\n    return mutate;\n}\n// src/comments/CommentsRoom.tsx\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar POLLING_INTERVAL_REALTIME = 3e4;\nvar POLLING_INTERVAL = 5e3;\nfunction createCommentsRoom(errorEventSource) {\n    const store = createClientCacheStore();\n    const FetcherContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    const RoomManagerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n    function getThreads(manager) {\n        const threads = manager.getCache();\n        if (!threads) {\n            throw new Error(\"Cannot update threads or comments before they are loaded.\");\n        }\n        return threads;\n    }\n    function CommentsRoomProvider({ room, children }) {\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n            return createRoomRevalidationManager(room.id, {\n                getCache: store.getThreads,\n                setCache: store.setThreads\n            });\n        }, [\n            room.id\n        ]);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async ()=>{\n            const options = manager.getRevalidationManagers().filter(([key])=>manager.getReferenceCount(key) > 0).map(([_, manager2])=>manager2.getOptions());\n            const responses = await Promise.all(options.map(async (option)=>{\n                return await room.getThreads(option);\n            }));\n            const threads = Array.from(new Map(responses.flat().map((thread)=>[\n                    thread.id,\n                    thread\n                ])).values());\n            return threads;\n        }, [\n            room,\n            manager\n        ]);\n        const revalidateCache = useRevalidateCache(manager, fetcher);\n        const status = useSyncExternalStore3(room.events.status.subscribe, room.getStatus, room.getStatus);\n        const isOnline = useIsOnline();\n        const isDocumentVisible = useIsDocumentVisible();\n        const refreshInterval = getPollingInterval(isOnline, isDocumentVisible, status === \"connected\");\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            let revalidationTimerId;\n            function scheduleRevalidation() {\n                if (refreshInterval === 0) return;\n                revalidationTimerId = window.setTimeout(()=>{\n                    if (isOnline && isDocumentVisible && !manager.getError() && manager.getTotalReferenceCount() > 0) {\n                        void revalidateCache({\n                            shouldDedupe: true\n                        }).then(scheduleRevalidation);\n                        return;\n                    }\n                    scheduleRevalidation();\n                }, refreshInterval);\n            }\n            scheduleRevalidation();\n            return ()=>{\n                window.clearTimeout(revalidationTimerId);\n            };\n        }, [\n            revalidateCache,\n            refreshInterval,\n            isOnline,\n            isDocumentVisible,\n            manager\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleIsOnline() {\n                if (isDocumentVisible) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            revalidateCache,\n            isDocumentVisible\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            function handleVisibilityChange() {\n                const isVisible = document.visibilityState === \"visible\";\n                if (isVisible && isOnline) {\n                    void revalidateCache({\n                        shouldDedupe: true\n                    });\n                }\n            }\n            document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n            return ()=>{\n                document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            };\n        }, [\n            revalidateCache,\n            isOnline\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const unsubscribe = room.events.comments.subscribe(()=>{\n                void revalidateCache({\n                    shouldDedupe: false\n                });\n            });\n            return ()=>{\n                unsubscribe();\n            };\n        }, [\n            room,\n            revalidateCache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetcherContext.Provider, {\n            value: fetcher\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomManagerContext.Provider, {\n            value: manager\n        }, children));\n    }\n    function useRoomManager() {\n        const manager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomManagerContext);\n        if (manager === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return manager;\n    }\n    function getUseThreadsRevalidationManager(options, roomManager) {\n        const key = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options);\n        const revalidationManager = roomManager.getRevalidationManager(key);\n        if (!revalidationManager) {\n            const useThreadsRevalidationManager = createUseThreadsRevalidationManager(options, roomManager);\n            roomManager.setRevalidationmanager(key, useThreadsRevalidationManager);\n            return useThreadsRevalidationManager;\n        }\n        return revalidationManager;\n    }\n    function useThreadsFetcher() {\n        const fetcher = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FetcherContext);\n        if (fetcher === null) {\n            throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n        }\n        return fetcher;\n    }\n    function useThreads(room, options = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        return cache;\n    }\n    function useThreadsSuspense(room, options = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const key = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options), [\n            options\n        ]);\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        const fetcher = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            return room.getThreads(options);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n        [\n            key,\n            room\n        ]);\n        const revalidateCache = useRevalidateCache(useThreadsRevalidationManager, fetcher);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void revalidateCache({\n                shouldDedupe: true\n            });\n        }, [\n            revalidateCache\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            manager.incrementReferenceCount(key);\n            return ()=>{\n                manager.decrementReferenceCount(key);\n            };\n        }, [\n            manager,\n            key\n        ]);\n        const cache = _useThreads(room, options);\n        if (cache.error) {\n            throw cache.error;\n        }\n        if (cache.isLoading || !cache.threads) {\n            throw revalidateCache({\n                shouldDedupe: true\n            });\n        }\n        return {\n            isLoading: false,\n            threads: cache.threads,\n            error: cache.error\n        };\n    }\n    function _useThreads(room, options) {\n        const manager = useRoomManager();\n        const useThreadsRevalidationManager = getUseThreadsRevalidationManager(options, manager);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(store.subscribe, ()=>store.getThreads(), ()=>store.getThreads(), (state)=>{\n            const isLoading = useThreadsRevalidationManager.getIsLoading();\n            if (isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            const options2 = useThreadsRevalidationManager.getOptions();\n            const error = useThreadsRevalidationManager.getError();\n            const filtered = state.filter((thread)=>{\n                if (thread.roomId !== room.id) return false;\n                const query = options2.query ?? {};\n                for(const key in query.metadata){\n                    if (thread.metadata[key] !== query.metadata[key]) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n            return {\n                isLoading: false,\n                threads: filtered,\n                error\n            };\n        });\n    }\n    function useEditThreadMetadata(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editThreadMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const threadId = options.threadId;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    metadata: {\n                        ...thread.metadata,\n                        ...metadata\n                    }\n                } : thread);\n            mutate(room.editThreadMetadata({\n                metadata,\n                threadId\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditThreadMetadataError(error, {\n                    roomId: room.id,\n                    threadId,\n                    metadata\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editThreadMetadata;\n    }\n    function useCreateThread(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createThread = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options)=>{\n            const body = options.body;\n            const metadata = \"metadata\" in options ? options.metadata : {};\n            const threads = getThreads(manager);\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt: now,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt: now,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            mutate(room.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }), {\n                optimisticData: [\n                    ...threads,\n                    newThread\n                ]\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateThreadError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                    metadata\n                }));\n            });\n            return newThread;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createThread;\n    }\n    function useCreateComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, body })=>{\n            const threads = getThreads(manager);\n            const commentId = createCommentId();\n            const now = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt: now,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: [\n                        ...thread.comments,\n                        comment\n                    ]\n                } : thread);\n            mutate(room.createComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new CreateCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n            return comment;\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    function useEditComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const editComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, body })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                            ...comment,\n                            editedAt: now,\n                            body\n                        } : comment)\n                } : thread);\n            mutate(room.editComment({\n                threadId,\n                commentId,\n                body\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new EditCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return editComment;\n    }\n    function useDeleteComment(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const deleteComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const newThreads = [];\n            for (const thread of threads){\n                if (thread.id === threadId) {\n                    const newThread = {\n                        ...thread,\n                        comments: thread.comments.map((comment)=>comment.id === commentId ? {\n                                ...comment,\n                                deletedAt: now,\n                                body: void 0\n                            } : comment)\n                    };\n                    if (newThread.comments.some((comment)=>comment.deletedAt === void 0)) {\n                        newThreads.push(newThread);\n                    }\n                } else {\n                    newThreads.push(thread);\n                }\n            }\n            mutate(room.deleteComment({\n                threadId,\n                commentId\n            }), {\n                optimisticData: newThreads\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new DeleteCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return deleteComment;\n    }\n    function useAddReaction(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, emoji })=>{\n            const threads = getThreads(manager);\n            const now = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        let reactions;\n                        if (comment.reactions.some((reaction)=>reaction.emoji === emoji)) {\n                            reactions = comment.reactions.map((reaction)=>reaction.emoji === emoji ? {\n                                    ...reaction,\n                                    users: [\n                                        ...reaction.users,\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                } : reaction);\n                        } else {\n                            reactions = [\n                                ...comment.reactions,\n                                {\n                                    emoji,\n                                    createdAt: now,\n                                    users: [\n                                        {\n                                            id: userId\n                                        }\n                                    ]\n                                }\n                            ];\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new AddReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    function useRemoveReaction(room) {\n        const manager = useRoomManager();\n        const fetcher = useThreadsFetcher();\n        const revalidate = useRevalidateCache(manager, fetcher);\n        const mutate = useMutate(manager, revalidate);\n        const createComment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ threadId, commentId, emoji })=>{\n            const threads = getThreads(manager);\n            const userId = getCurrentUserId(room);\n            const optimisticData = threads.map((thread)=>thread.id === threadId ? {\n                    ...thread,\n                    comments: thread.comments.map((comment)=>{\n                        if (comment.id !== commentId) {\n                            return comment;\n                        }\n                        const reactionIndex = comment.reactions.findIndex((reaction)=>reaction.emoji === emoji);\n                        let reactions = comment.reactions;\n                        if (reactionIndex >= 0 && comment.reactions[reactionIndex].users.some((user)=>user.id === userId)) {\n                            if (comment.reactions[reactionIndex].users.length <= 1) {\n                                reactions = [\n                                    ...comment.reactions\n                                ];\n                                reactions.splice(reactionIndex, 1);\n                            } else {\n                                reactions[reactionIndex] = {\n                                    ...reactions[reactionIndex],\n                                    users: reactions[reactionIndex].users.filter((user)=>user.id !== userId)\n                                };\n                            }\n                        }\n                        return {\n                            ...comment,\n                            reactions\n                        };\n                    })\n                } : thread);\n            mutate(room.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }), {\n                optimisticData\n            }).catch((err)=>{\n                if (!(err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError)) {\n                    throw err;\n                }\n                const error = handleCommentsApiError(err);\n                errorEventSource.notify(new RemoveReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji\n                }));\n            });\n        }, [\n            room,\n            mutate,\n            manager\n        ]);\n        return createComment;\n    }\n    return {\n        CommentsRoomProvider,\n        useThreads,\n        useThreadsSuspense,\n        useEditThreadMetadata,\n        useCreateThread,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction\n    };\n}\nfunction createOptimisticId(prefix) {\n    return `${prefix}_${(0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)()}`;\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleCommentsApiError(err) {\n    const message = `Request failed with status ${err.status}: ${err.message}`;\n    if (err.details?.error === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction createRoomRevalidationManager(roomId, { getCache, setCache }) {\n    let request;\n    let error;\n    let mutation;\n    const revalidationManagerByOptions = /* @__PURE__ */ new Map();\n    const referenceCountByOptions = /* @__PURE__ */ new Map();\n    return {\n        // Cache\n        getCache () {\n            const threads = getCache();\n            const filtered = threads.filter((thread)=>thread.roomId === roomId);\n            return filtered;\n        },\n        setCache (value) {\n            for (const key of revalidationManagerByOptions.keys()){\n                if (referenceCountByOptions.get(key) === 0) {\n                    revalidationManagerByOptions.delete(key);\n                    referenceCountByOptions.delete(key);\n                }\n            }\n            const sorted = value.sort((a, b)=>new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n            const threads = getCache();\n            const newThreads = threads.filter((thread)=>thread.roomId !== roomId).concat(sorted);\n            setCache(newThreads);\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n        },\n        // Mutation\n        getMutation () {\n            return mutation;\n        },\n        setMutation (info) {\n            mutation = info;\n        },\n        getRevalidationManagers () {\n            return Array.from(revalidationManagerByOptions.entries());\n        },\n        getRevalidationManager (key) {\n            return revalidationManagerByOptions.get(key);\n        },\n        setRevalidationmanager (key, manager) {\n            revalidationManagerByOptions.set(key, manager);\n        },\n        getTotalReferenceCount () {\n            return Array.from(referenceCountByOptions.values()).reduce((acc, count)=>acc + count, 0);\n        },\n        incrementReferenceCount (key) {\n            const count = referenceCountByOptions.get(key) ?? 0;\n            referenceCountByOptions.set(key, count + 1);\n        },\n        decrementReferenceCount (key) {\n            const count = referenceCountByOptions.get(key) ?? 0;\n            referenceCountByOptions.set(key, count - 1);\n        },\n        getReferenceCount (key) {\n            return referenceCountByOptions.get(key) ?? 0;\n        }\n    };\n}\nfunction createClientCacheStore() {\n    let threads = [];\n    const threadsEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    return {\n        getThreads () {\n            return threads;\n        },\n        setThreads (value) {\n            threads = value;\n            threadsEventSource.notify(threads);\n        },\n        subscribe (callback) {\n            return threadsEventSource.subscribe(callback);\n        }\n    };\n}\nfunction createUseThreadsRevalidationManager(options, manager) {\n    let isLoading = true;\n    let request;\n    let error;\n    return {\n        // Cache\n        getCache () {\n            return void 0;\n        },\n        setCache (value) {\n            const cache = new Map((manager.getCache() ?? []).map((thread)=>[\n                    thread.id,\n                    thread\n                ]));\n            for (const thread of value){\n                cache.set(thread.id, thread);\n            }\n            manager.setCache(Array.from(cache.values()));\n            isLoading = false;\n        },\n        // Request\n        getRequest () {\n            return request;\n        },\n        setRequest (value) {\n            request = value;\n        },\n        // Error\n        getError () {\n            return error;\n        },\n        setError (err) {\n            error = err;\n            isLoading = false;\n            const cache = manager.getCache();\n            manager.setCache(cache);\n        },\n        // Mutation\n        getMutation () {\n            return void 0;\n        },\n        setMutation (_) {\n            return;\n        },\n        getOptions () {\n            return options;\n        },\n        getIsLoading () {\n            return isLoading;\n        },\n        setIsLoading (value) {\n            isLoading = value;\n        }\n    };\n}\nfunction getPollingInterval(isBrowserOnline, isDocumentVisible, isRoomConnected) {\n    if (!isBrowserOnline || !isDocumentVisible) return;\n    if (isRoomConnected) return POLLING_INTERVAL_REALTIME;\n    return POLLING_INTERVAL;\n}\n// src/comments/lib/use-debounce.ts\n\nvar DEFAULT_DELAY = 500;\nfunction useDebounce(value, delay = DEFAULT_DELAY) {\n    const timeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [debouncedValue, setDebouncedValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (delay === false) {\n            return;\n        }\n        if (timeout.current === void 0) {\n            setDebouncedValue(value);\n        }\n        timeout.current = window.setTimeout(()=>{\n            setDebouncedValue(value);\n            timeout.current = void 0;\n        }, delay);\n        return ()=>{\n            window.clearTimeout(timeout.current);\n        };\n    }, [\n        value,\n        delay\n    ]);\n    return debouncedValue;\n}\n// src/lib/use-async-cache.ts\n\n\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n// src/lib/use-async-cache.ts\nvar INITIAL_ASYNC_STATE = {\n    isLoading: false,\n    data: void 0,\n    error: void 0\n};\nvar noop = ()=>{};\nfunction useAsyncCache(cache, key, options) {\n    const frozenOptions = useInitial(options);\n    const cacheItem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (key === null || !cache) {\n            return null;\n        }\n        const cacheItem2 = cache.create(key);\n        void cacheItem2.get();\n        return cacheItem2;\n    }, [\n        cache,\n        key\n    ]);\n    const subscribe2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>cacheItem?.subscribe(callback) ?? noop, [\n        cacheItem\n    ]);\n    const getState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>cacheItem?.getState() ?? INITIAL_ASYNC_STATE, [\n        cacheItem\n    ]);\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>cacheItem?.revalidate(), [\n        cacheItem\n    ]);\n    const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStore)(subscribe2, getState, getState);\n    const previousData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let data = state.data;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousData.current = {\n            key,\n            data: state.data\n        };\n    }, [\n        key,\n        state.data\n    ]);\n    if (!cacheItem) {\n        return {\n            isLoading: false,\n            data: void 0,\n            error: void 0,\n            getState,\n            revalidate\n        };\n    }\n    if (frozenOptions?.suspense) {\n        const error = getState().error;\n        if (error) {\n            throw error;\n        } else if (getState().isLoading) {\n            throw new Promise((resolve)=>{\n                cacheItem.subscribeOnce((state2)=>{\n                    if (!state2.isLoading) {\n                        resolve();\n                    }\n                });\n            });\n        }\n    }\n    if (state.isLoading && frozenOptions?.keepPreviousDataWhileLoading && typeof state.data === \"undefined\" && previousData.current?.key !== key && typeof previousData.current?.data !== \"undefined\") {\n        data = previousData.current.data;\n    }\n    return {\n        isLoading: state.isLoading,\n        data,\n        error: state.error,\n        getState,\n        revalidate\n    };\n}\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n// src/factory.tsx\nvar noop2 = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>`We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(roomId)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You donâ€™t need to pass unstable_batchedUpdates to RoomProvider anymore, since youâ€™re on React 18+ already.\";\nfunction useSyncExternalStore3(s, gs, gss) {\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar hasWarnedIfNoResolveUsers = false;\nfunction warnIfNoResolveUsers(usersCache) {\n    if (!hasWarnedIfNoResolveUsers && !usersCache && \"development\" !== \"production\") {\n        console.warn(\"Set the resolveUsers option in createRoomContext to specify user info.\");\n        hasWarnedIfNoResolveUsers = true;\n    }\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nfunction createRoomContext(client, options) {\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const { CommentsRoomProvider, ...commentsRoom } = createCommentsRoom(commentsErrorEventSource);\n    function RoomProviderOuter(props) {\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    function RoomProviderInner(props) {\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? \"undefined\" !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CommentsRoomProvider, {\n            room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: internalBundle\n        }, props.children)));\n    }\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    function useStatus() {\n        const room = useRoom();\n        const subscribe2 = room.events.status.subscribe;\n        const getSnapshot2 = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    function useMyPresence() {\n        const room = useRoom();\n        const subscribe2 = room.events.myPresence.subscribe;\n        const getSnapshot2 = room.getPresence;\n        const presence = useSyncExternalStore3(subscribe2, getSnapshot2, getSnapshot2);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    function useUpdateMyPresence() {\n        return useRoom().updatePresence;\n    }\n    function useOthers(selector, isEqual) {\n        const room = useRoom();\n        const subscribe2 = room.events.others.subscribe;\n        const getSnapshot2 = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, selector ?? identity, isEqual);\n    }\n    function useOthersConnectionIds() {\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual ?? Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual ?? Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(`No such other user with connection id ${connectionId} exists`);\n        }\n        return other;\n    }\n    function useBroadcastEvent() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event, options2 = {\n            shouldQueueEventIfNotReady: false\n        })=>{\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    function useOthersListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useLostConnectionListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useErrorListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useEventListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    function useSelf(maybeSelector, isEqual) {\n        const room = useRoom();\n        const subscribe2 = room.events.self.subscribe;\n        const getSnapshot2 = room.getSelf;\n        const selector = maybeSelector ?? identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function useMutableStorageRoot() {\n        const room = useRoom();\n        const subscribe2 = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot2 = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);\n    }\n    function useStorageRoot() {\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    function useHistory() {\n        return useRoom().history;\n    }\n    function useUndo() {\n        return useHistory().undo;\n    }\n    function useRedo() {\n        return useHistory().redo;\n    }\n    function useCanUndo() {\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore3(subscribe2, canUndo, canUndo);\n    }\n    function useCanRedo() {\n        const room = useRoom();\n        const subscribe2 = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore3(subscribe2, canRedo, canRedo);\n    }\n    function useBatch() {\n        return useRoom().batch;\n    }\n    function useLegacyKey(key) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr?.();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr?.();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    function useStorage(selector, isEqual) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop2, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot2, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function ensureNotServerSide() {\n        if (true) {\n            throw new Error(\"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\");\n        }\n    }\n    function useSuspendUntilStorageLoaded() {\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    function useSuspendUntilPresenceLoaded() {\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    function useMutation(callback, deps) {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args));\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    function useStorageSuspense(selector, isEqual) {\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    function useSelfSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    function useOthersSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    function useOthersConnectionIdsSuspense() {\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    function useLegacyKeySuspense(key) {\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    function useThreads(options2) {\n        const room = useRoom();\n        return commentsRoom.useThreads(room, options2);\n    }\n    function useThreadsSuspense(options2) {\n        const room = useRoom();\n        return commentsRoom.useThreadsSuspense(room, options2);\n    }\n    function useCreateThread() {\n        const room = useRoom();\n        return commentsRoom.useCreateThread(room);\n    }\n    function useEditThreadMetadata() {\n        const room = useRoom();\n        return commentsRoom.useEditThreadMetadata(room);\n    }\n    function useAddReaction() {\n        const room = useRoom();\n        return commentsRoom.useAddReaction(room);\n    }\n    function useRemoveReaction() {\n        const room = useRoom();\n        return commentsRoom.useRemoveReaction(room);\n    }\n    function useCreateComment() {\n        const room = useRoom();\n        return commentsRoom.useCreateComment(room);\n    }\n    function useEditComment() {\n        const room = useRoom();\n        return commentsRoom.useEditComment(room);\n    }\n    function useDeleteComment() {\n        const room = useRoom();\n        return commentsRoom.useDeleteComment(room);\n    }\n    const { resolveUsers, resolveMentionSuggestions } = options ?? {};\n    const usersCache = resolveUsers ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(async (stringifiedOptions)=>{\n        const users = await resolveUsers(JSON.parse(stringifiedOptions));\n        return users?.[0];\n    }) : void 0;\n    function useUser(userId) {\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        if (state.isLoading) {\n            return {\n                isLoading: true\n            };\n        } else {\n            return {\n                user: state.data,\n                error: state.error,\n                isLoading: false\n            };\n        }\n    }\n    function useUserSuspense(userId) {\n        const room = useRoom();\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                userIds: [\n                    userId\n                ],\n                roomId: room.id\n            }), [\n            userId,\n            room.id\n        ]);\n        const state = useAsyncCache(usersCache, resolverKey, {\n            suspense: true\n        });\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>warnIfNoResolveUsers(usersCache), []);\n        return {\n            user: state.data,\n            isLoading: false\n        };\n    }\n    const mentionSuggestionsCache = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createAsyncCache)(resolveMentionSuggestions ? (stringifiedOptions)=>{\n        return resolveMentionSuggestions(JSON.parse(stringifiedOptions));\n    } : ()=>Promise.resolve([]));\n    function useMentionSuggestions(search) {\n        const room = useRoom();\n        const debouncedSearch = useDebounce(search, 500);\n        const resolverKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>debouncedSearch !== void 0 ? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)({\n                text: debouncedSearch,\n                roomId: room.id\n            }) : null, [\n            debouncedSearch,\n            room.id\n        ]);\n        const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {\n            keepPreviousDataWhileLoading: true\n        });\n        return data;\n    }\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useUser,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useUser: useUserSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction\n        }\n    };\n    const internalBundle = {\n        ...bundle,\n        hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n        useMentionSuggestions\n    };\n    return bundle;\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3VIQUVBLGVBQWU7QUFDZ0M7QUFFL0MsaUJBQWlCO0FBQ2pCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGFBQWE7QUFFakIsNkJBQTZCO0FBQ0U7QUFDL0IsU0FBU0UsbUJBQW1CQyxLQUFLO0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7QUFFQSxrQkFBa0I7QUFDMkI7QUFRbkI7QUFDTTtBQUNzRztBQUV0SSxnQ0FBZ0M7QUFDZ0Q7QUFDaEQ7QUFPakI7QUFDa0Y7QUFFakcseUJBQXlCO0FBQ3pCLElBQUl1QixvQkFBb0IsY0FBY0M7SUFDcENDLFlBQVlDLEtBQUssRUFBRUMsT0FBTyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUNBLElBQUlDLDBCQUEwQixjQUFjTDtJQUMxQ0MsWUFBWUMsS0FBSyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBQ0EsSUFBSUUscUJBQXFCLGNBQWNOO0lBQ3JDQyxZQUFZQyxLQUFLLEVBQUVDLE9BQU8sQ0FBRTtRQUMxQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFDQSxJQUFJRyxtQkFBbUIsY0FBY1A7SUFDbkNDLFlBQVlDLEtBQUssRUFBRUMsT0FBTyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUNBLElBQUlJLHFCQUFxQixjQUFjUjtJQUNyQ0MsWUFBWUMsS0FBSyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBQ0EsSUFBSUssbUJBQW1CLGNBQWNUO0lBQ25DQyxZQUFZQyxLQUFLLEVBQUVDLE9BQU8sQ0FBRTtRQUMxQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFDQSxJQUFJTSxzQkFBc0IsY0FBY1Y7SUFDdENDLFlBQVlDLEtBQUssRUFBRUMsT0FBTyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLG1DQUFtQztBQUM2RDtBQUVoRyw4Q0FBOEM7QUFDK0I7QUFDN0UsU0FBU1k7SUFDUCxNQUFNQyxZQUFZRiwyRkFBb0JBLENBQUNHLFdBQVdDLGFBQWFBO0lBQy9ELE9BQU9GO0FBQ1Q7QUFDQSxTQUFTQyxVQUFVRSxhQUFhO0lBQzlCQyxTQUFTQyxnQkFBZ0IsQ0FBQyxvQkFBb0JGO0lBQzlDLE9BQU87UUFDTEMsU0FBU0UsbUJBQW1CLENBQUMsb0JBQW9CSDtJQUNuRDtBQUNGO0FBQ0EsU0FBU0Q7SUFDUCxNQUFNSyxvQkFBb0IsT0FBT0gsYUFBYTtJQUM5QyxPQUFPRyxvQkFBb0JILFNBQVNJLGVBQWUsS0FBSyxZQUFZO0FBQ3RFO0FBRUEsb0NBQW9DO0FBQ1E7QUFDMEQ7QUFDdEcsU0FBU0U7SUFDUCxNQUFNQyxjQUFjZiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNZ0IsYUFBYW5DLGtEQUFXQSxDQUFDLENBQUMwQjtRQUM5QixTQUFTVTtZQUNQRixZQUFZRyxPQUFPLEdBQUc7WUFDdEJYO1FBQ0Y7UUFDQSxTQUFTWTtZQUNQSixZQUFZRyxPQUFPLEdBQUc7WUFDdEJYO1FBQ0Y7UUFDQWEsT0FBT1gsZ0JBQWdCLENBQUMsVUFBVVE7UUFDbENHLE9BQU9YLGdCQUFnQixDQUFDLFdBQVdVO1FBQ25DLE9BQU87WUFDTEMsT0FBT1YsbUJBQW1CLENBQUMsVUFBVU87WUFDckNHLE9BQU9WLG1CQUFtQixDQUFDLFdBQVdTO1FBQ3hDO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTUUsZUFBZXhDLGtEQUFXQSxDQUFDO1FBQy9CLE9BQU9rQyxZQUFZRyxPQUFPO0lBQzVCLEdBQUcsRUFBRTtJQUNMLE1BQU1JLFdBQVdULDJGQUFxQkEsQ0FBQ0csWUFBWUssY0FBY0E7SUFDakUsT0FBT0M7QUFDVDtBQUVBLG1DQUFtQztBQUNuQyxJQUFJQywrQkFBK0I7QUFDbkMsSUFBSUMsZ0NBQWdDO0FBQ3BDLElBQUlDLDRCQUE0QjtBQUNoQyxJQUFJQyxZQUFZO0FBQ2hCLFNBQVNDLG1CQUFtQkMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3hELE1BQU1mLGNBQWNkLDZDQUFPQSxDQUFDO0lBQzVCLE1BQU0sRUFDSjhCLG1CQUFtQk4seUJBQXlCLEVBQzVDTyxxQkFBcUJULDRCQUE0QixFQUNqRFUsa0JBQWtCVCw2QkFBNkIsRUFDaEQsR0FBR007SUFDSixNQUFNSSxtQkFBbUJwQyxrREFBWUEsQ0FDbkMsT0FBTyxFQUNMcUMsWUFBWSxFQUNaQyxhQUFhLENBQUMsRUFDZjtRQUNDLElBQUlDO1FBQ0osTUFBTUMscUJBQXFCLENBQUNWLFFBQVFXLFVBQVUsTUFBTSxDQUFDSjtRQUNyRCxTQUFTSztZQUNQLE1BQU1DLGdCQUFnQmIsUUFBUVcsVUFBVTtZQUN4QyxJQUFJLENBQUNFLGVBQ0g7WUFDRixJQUFJQSxjQUFjZixTQUFTLEtBQUtXLFNBQzlCO1lBQ0ZULFFBQVFjLFVBQVUsQ0FBQyxLQUFLO1FBQzFCO1FBQ0EsU0FBU0M7WUFDUCxNQUFNQyxVQUFVLENBQUMsQ0FBRSxFQUFDQyxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFNLE1BQU1WLENBQUFBLGFBQWEsSUFBSUEsYUFBYSxFQUFDLENBQUMsSUFBS0o7WUFDdkYsSUFBSUksYUFBYUgsaUJBQ2Y7WUFDRmMsV0FBVztnQkFDVCxLQUFLYixpQkFBaUI7b0JBQ3BCQyxjQUFjO29CQUNkQyxZQUFZQSxhQUFhO2dCQUMzQjtZQUNGLEdBQUdRO1FBQ0w7UUFDQSxJQUFJTixvQkFBb0I7WUFDdEJWLFFBQVFjLFVBQVUsQ0FBQztnQkFDakJiLFNBQVNBO2dCQUNUSCxXQUFXLEVBQUVBO1lBQ2Y7UUFDRjtRQUNBLElBQUk7WUFDRixJQUFJZSxnQkFBZ0JiLFFBQVFXLFVBQVU7WUFDdEMsSUFBSSxDQUFDRSxlQUNIO1lBQ0ZKLFVBQVVJLGNBQWNmLFNBQVM7WUFDakMsTUFBTXNCLFVBQVUsTUFBTVAsY0FBY1osT0FBTztZQUMzQyxJQUFJUyxvQkFBb0I7Z0JBQ3RCUyxXQUFXUCxxQkFBcUJUO1lBQ2xDO1lBQ0FVLGdCQUFnQmIsUUFBUVcsVUFBVTtZQUNsQyxJQUFJLENBQUNFLGlCQUFpQkEsY0FBY2YsU0FBUyxLQUFLVyxTQUNoRDtZQUNGLE1BQU1ZLGlCQUFpQnJCLFFBQVFzQixXQUFXO1lBQzFDLElBQUlELGtCQUFtQkEsQ0FBQUEsZUFBZUUsU0FBUyxHQUFHZCxXQUFXWSxlQUFlRyxPQUFPLEdBQUdmLFdBQVdZLGVBQWVHLE9BQU8sS0FBSyxJQUFJO2dCQUM5SDtZQUNGO1lBQ0F4QixRQUFReUIsUUFBUSxDQUFDTDtRQUNuQixFQUFFLE9BQU9NLEtBQUs7WUFDWmQ7WUFDQSxNQUFNcEMsWUFBWUksU0FBU0ksZUFBZSxLQUFLO1lBQy9DLE1BQU1VLFdBQVdQLFlBQVlHLE9BQU87WUFDcEMsSUFBSW9CLHNCQUFzQmxDLGFBQWFrQixVQUNyQ3FCO1lBQ0ZmLFFBQVEyQixRQUFRLENBQUNEO1FBQ25CO1FBQ0E7SUFDRixHQUNBO1FBQUMxQjtRQUFTQztRQUFTRTtRQUFrQkM7UUFBb0JDO0tBQWdCO0lBRTNFbEMsZ0RBQVVBLENBQUM7UUFDVCxTQUFTa0I7WUFDUEYsWUFBWUcsT0FBTyxHQUFHO1FBQ3hCO1FBQ0EsU0FBU0M7WUFDUEosWUFBWUcsT0FBTyxHQUFHO1FBQ3hCO1FBQ0FFLE9BQU9YLGdCQUFnQixDQUFDLFVBQVVRO1FBQ2xDRyxPQUFPWCxnQkFBZ0IsQ0FBQyxXQUFXVTtRQUNuQyxPQUFPO1lBQ0xDLE9BQU9WLG1CQUFtQixDQUFDLFVBQVVPO1lBQ3JDRyxPQUFPVixtQkFBbUIsQ0FBQyxXQUFXUztRQUN4QztJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU1xQyxrQkFBa0IxRCxrREFBWUEsQ0FDbEMsQ0FBQyxFQUFFcUMsWUFBWSxFQUFFO1FBQ2YsT0FBT0QsaUJBQWlCO1lBQUVDO1lBQWNDLFlBQVk7UUFBRTtJQUN4RCxHQUNBO1FBQUNGO0tBQWlCO0lBRXBCLE9BQU9zQjtBQUNUO0FBQ0EsU0FBU0MsVUFBVTdCLE9BQU8sRUFBRTRCLGVBQWU7SUFDekMsTUFBTUUsU0FBUzVELGtEQUFZQSxDQUN6QixPQUFPNkQsTUFBTTdCO1FBQ1gsTUFBTThCLDBCQUEwQixFQUFFbEM7UUFDbENFLFFBQVFpQyxXQUFXLENBQUM7WUFDbEJWLFdBQVdTO1lBQ1hSLFNBQVM7UUFDWDtRQUNBLE1BQU1VLGVBQWVsQyxRQUFRbUMsUUFBUTtRQUNyQ25DLFFBQVF5QixRQUFRLENBQUN2QixRQUFRa0MsY0FBYztRQUN2QyxJQUFJQztRQUNKLElBQUk7WUFDRixNQUFNTjtRQUNSLEVBQUUsT0FBT0wsS0FBSztZQUNaVyxRQUFRWDtRQUNWO1FBQ0EsTUFBTUwsaUJBQWlCckIsUUFBUXNCLFdBQVc7UUFDMUMsSUFBSUQsa0JBQWtCVyw0QkFBNEJYLGVBQWVFLFNBQVMsRUFBRTtZQUMxRSxJQUFJYyxPQUNGLE1BQU1BO1lBQ1I7UUFDRjtRQUNBLElBQUlBLE9BQU87WUFDVHJDLFFBQVF5QixRQUFRLENBQUNTO1FBQ25CO1FBQ0FsQyxRQUFRaUMsV0FBVyxDQUFDO1lBQ2xCVixXQUFXUztZQUNYUixTQUFTLEVBQUUxQjtRQUNiO1FBQ0FFLFFBQVFjLFVBQVUsQ0FBQyxLQUFLO1FBQ3hCLEtBQUtjLGdCQUFnQjtZQUFFckIsY0FBYztRQUFNO1FBQzNDLElBQUk4QixPQUNGLE1BQU1BO0lBQ1YsR0FDQTtRQUFDckM7UUFBUzRCO0tBQWdCO0lBRTVCLE9BQU9FO0FBQ1Q7QUFFQSxnQ0FBZ0M7QUFDaEMsSUFBSVEsbUJBQW1CO0FBQ3ZCLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyw0QkFBNEI7QUFDaEMsSUFBSUMsbUJBQW1CO0FBQ3ZCLFNBQVNDLG1CQUFtQkMsZ0JBQWdCO0lBQzFDLE1BQU1DLFFBQVFDO0lBQ2QsTUFBTUMsK0JBQWlCOUYsb0RBQWFBLENBQUM7SUFDckMsTUFBTStGLG1DQUFxQi9GLG9EQUFhQSxDQUFDO0lBQ3pDLFNBQVNnRyxXQUFXaEQsT0FBTztRQUN6QixNQUFNaUQsVUFBVWpELFFBQVFtQyxRQUFRO1FBQ2hDLElBQUksQ0FBQ2MsU0FBUztZQUNaLE1BQU0sSUFBSTFGLE1BQ1I7UUFFSjtRQUNBLE9BQU8wRjtJQUNUO0lBQ0EsU0FBU0MscUJBQXFCLEVBQzVCQyxJQUFJLEVBQ0puSCxRQUFRLEVBQ1Q7UUFDQyxNQUFNZ0UsVUFBVTNDLDhDQUFPQSxDQUFDO1lBQ3RCLE9BQU8rRiw4QkFBOEJELEtBQUtFLEVBQUUsRUFBRTtnQkFDNUNsQixVQUFVUyxNQUFNSSxVQUFVO2dCQUMxQnZCLFVBQVVtQixNQUFNVSxVQUFVO1lBQzVCO1FBQ0YsR0FBRztZQUFDSCxLQUFLRSxFQUFFO1NBQUM7UUFDWixNQUFNcEQsVUFBVWxELDhDQUFrQixDQUFDO1lBQ2pDLE1BQU1tRCxVQUFVRixRQUFRdUQsdUJBQXVCLEdBQUdDLE1BQU0sQ0FBQyxDQUFDLENBQUNDLElBQUksR0FBS3pELFFBQVEwRCxpQkFBaUIsQ0FBQ0QsT0FBTyxHQUFHRSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxHQUFHQyxTQUFTLEdBQUtBLFNBQVNDLFVBQVU7WUFDbEosTUFBTUMsWUFBWSxNQUFNQyxRQUFRQyxHQUFHLENBQ2pDL0QsUUFBUXlELEdBQUcsQ0FBQyxPQUFPTztnQkFDakIsT0FBTyxNQUFNZixLQUFLSCxVQUFVLENBQUNrQjtZQUMvQjtZQUVGLE1BQU1qQixVQUFVa0IsTUFBTUMsSUFBSSxDQUN4QixJQUFJQyxJQUFJTixVQUFVTyxJQUFJLEdBQUdYLEdBQUcsQ0FBQyxDQUFDWSxTQUFXO29CQUFDQSxPQUFPbEIsRUFBRTtvQkFBRWtCO2lCQUFPLEdBQUdDLE1BQU07WUFFdkUsT0FBT3ZCO1FBQ1QsR0FBRztZQUFDRTtZQUFNbkQ7U0FBUTtRQUNsQixNQUFNNEIsa0JBQWtCN0IsbUJBQW1CQyxTQUFTQztRQUNwRCxNQUFNd0UsU0FBU0Msc0JBQ2J2QixLQUFLd0IsTUFBTSxDQUFDRixNQUFNLENBQUNoRyxTQUFTLEVBQzVCMEUsS0FBS3lCLFNBQVMsRUFDZHpCLEtBQUt5QixTQUFTO1FBRWhCLE1BQU1sRixXQUFXUjtRQUNqQixNQUFNMkYsb0JBQW9CdEc7UUFDMUIsTUFBTXVHLGtCQUFrQkMsbUJBQ3RCckYsVUFDQW1GLG1CQUNBSixXQUFXO1FBRWJySCxnREFBVUEsQ0FBQztZQUNULElBQUk0SDtZQUNKLFNBQVNDO2dCQUNQLElBQUlILG9CQUFvQixHQUN0QjtnQkFDRkUsc0JBQXNCeEYsT0FBTzJCLFVBQVUsQ0FBQztvQkFDdEMsSUFBSXpCLFlBQVltRixxQkFBcUIsQ0FBQzdFLFFBQVFrRixRQUFRLE1BQU1sRixRQUFRbUYsc0JBQXNCLEtBQUssR0FBRzt3QkFDaEcsS0FBS3ZELGdCQUFnQjs0QkFBRXJCLGNBQWM7d0JBQUssR0FBRzZFLElBQUksQ0FDL0NIO3dCQUVGO29CQUNGO29CQUNBQTtnQkFDRixHQUFHSDtZQUNMO1lBQ0FHO1lBQ0EsT0FBTztnQkFDTHpGLE9BQU82RixZQUFZLENBQUNMO1lBQ3RCO1FBQ0YsR0FBRztZQUNEcEQ7WUFDQWtEO1lBQ0FwRjtZQUNBbUY7WUFDQTdFO1NBQ0Q7UUFDRDVDLGdEQUFVQSxDQUFDO1lBQ1QsU0FBU2lDO2dCQUNQLElBQUl3RixtQkFBbUI7b0JBQ3JCLEtBQUtqRCxnQkFBZ0I7d0JBQUVyQixjQUFjO29CQUFLO2dCQUM1QztZQUNGO1lBQ0FmLE9BQU9YLGdCQUFnQixDQUFDLFVBQVVRO1lBQ2xDLE9BQU87Z0JBQ0xHLE9BQU9WLG1CQUFtQixDQUFDLFVBQVVPO1lBQ3ZDO1FBQ0YsR0FBRztZQUFDdUM7WUFBaUJpRDtTQUFrQjtRQUN2Q3pILGdEQUFVQSxDQUFDO1lBQ1QsU0FBU2tJO2dCQUNQLE1BQU05RyxZQUFZSSxTQUFTSSxlQUFlLEtBQUs7Z0JBQy9DLElBQUlSLGFBQWFrQixVQUFVO29CQUN6QixLQUFLa0MsZ0JBQWdCO3dCQUFFckIsY0FBYztvQkFBSztnQkFDNUM7WUFDRjtZQUNBM0IsU0FBU0MsZ0JBQWdCLENBQUMsb0JBQW9CeUc7WUFDOUMsT0FBTztnQkFDTDFHLFNBQVNFLG1CQUFtQixDQUMxQixvQkFDQXdHO1lBRUo7UUFDRixHQUFHO1lBQUMxRDtZQUFpQmxDO1NBQVM7UUFDOUJ0QyxnREFBVUEsQ0FBQztZQUNULE1BQU1tSSxjQUFjcEMsS0FBS3dCLE1BQU0sQ0FBQ2EsUUFBUSxDQUFDL0csU0FBUyxDQUFDO2dCQUNqRCxLQUFLbUQsZ0JBQWdCO29CQUFFckIsY0FBYztnQkFBTTtZQUM3QztZQUNBLE9BQU87Z0JBQ0xnRjtZQUNGO1FBQ0YsR0FBRztZQUFDcEM7WUFBTXZCO1NBQWdCO1FBQzFCLE9BQU8sYUFBYSxpQkFBRzdFLGdEQUFvQixDQUFDK0YsZUFBZTJDLFFBQVEsRUFBRTtZQUFFQyxPQUFPekY7UUFBUSxHQUFHLGFBQWEsaUJBQUdsRCxnREFBb0IsQ0FBQ2dHLG1CQUFtQjBDLFFBQVEsRUFBRTtZQUFFQyxPQUFPMUY7UUFBUSxHQUFHaEU7SUFDakw7SUFDQSxTQUFTMko7UUFDUCxNQUFNM0YsVUFBVTdDLGlEQUFVQSxDQUFDNEY7UUFDM0IsSUFBSS9DLFlBQVksTUFBTTtZQUNwQixNQUFNLElBQUl6QyxNQUFNO1FBQ2xCO1FBQ0EsT0FBT3lDO0lBQ1Q7SUFDQSxTQUFTNEYsaUNBQWlDMUYsT0FBTyxFQUFFMkYsV0FBVztRQUM1RCxNQUFNcEMsTUFBTWpILDJEQUFTQSxDQUFDMEQ7UUFDdEIsTUFBTTRGLHNCQUFzQkQsWUFBWUUsc0JBQXNCLENBQUN0QztRQUMvRCxJQUFJLENBQUNxQyxxQkFBcUI7WUFDeEIsTUFBTUUsZ0NBQWdDQyxvQ0FDcEMvRixTQUNBMkY7WUFFRkEsWUFBWUssc0JBQXNCLENBQUN6QyxLQUFLdUM7WUFDeEMsT0FBT0E7UUFDVDtRQUNBLE9BQU9GO0lBQ1Q7SUFDQSxTQUFTSztRQUNQLE1BQU1sRyxVQUFVOUMsaURBQVVBLENBQUMyRjtRQUMzQixJQUFJN0MsWUFBWSxNQUFNO1lBQ3BCLE1BQU0sSUFBSTFDLE1BQU07UUFDbEI7UUFDQSxPQUFPMEM7SUFDVDtJQUNBLFNBQVNtRyxXQUFXakQsSUFBSSxFQUFFakQsVUFBVTtRQUFFbUcsT0FBTztZQUFFQyxVQUFVLENBQUM7UUFBRTtJQUFFLENBQUM7UUFDN0QsTUFBTTdDLE1BQU1wRyw4Q0FBT0EsQ0FBQyxJQUFNYiwyREFBU0EsQ0FBQzBELFVBQVU7WUFBQ0E7U0FBUTtRQUN2RCxNQUFNRixVQUFVMkY7UUFDaEIsTUFBTUssZ0NBQWdDSixpQ0FDcEMxRixTQUNBRjtRQUVGLE1BQU1DLFVBQVVsRCw4Q0FBa0IsQ0FDaEM7WUFDRSxPQUFPb0csS0FBS0gsVUFBVSxDQUFDOUM7UUFDekIsR0FDQSxvUUFBb1E7UUFDcFE7WUFBQ3VEO1lBQUtOO1NBQUs7UUFFYixNQUFNdkIsa0JBQWtCN0IsbUJBQ3RCaUcsK0JBQ0EvRjtRQUVGN0MsZ0RBQVVBLENBQUM7WUFDVCxLQUFLd0UsZ0JBQWdCO2dCQUFFckIsY0FBYztZQUFLO1FBQzVDLEdBQUc7WUFBQ3FCO1NBQWdCO1FBQ3BCeEUsZ0RBQVVBLENBQUM7WUFDVDRDLFFBQVF1Ryx1QkFBdUIsQ0FBQzlDO1lBQ2hDLE9BQU87Z0JBQ0x6RCxRQUFRd0csdUJBQXVCLENBQUMvQztZQUNsQztRQUNGLEdBQUc7WUFBQ3pEO1lBQVN5RDtTQUFJO1FBQ2pCLE1BQU1nRCxRQUFRQyxZQUFZdkQsTUFBTWpEO1FBQ2hDLE9BQU91RztJQUNUO0lBQ0EsU0FBU0UsbUJBQW1CeEQsSUFBSSxFQUFFakQsVUFBVTtRQUFFbUcsT0FBTztZQUFFQyxVQUFVLENBQUM7UUFBRTtJQUFFLENBQUM7UUFDckUsTUFBTTdDLE1BQU1wRyw4Q0FBT0EsQ0FBQyxJQUFNYiwyREFBU0EsQ0FBQzBELFVBQVU7WUFBQ0E7U0FBUTtRQUN2RCxNQUFNRixVQUFVMkY7UUFDaEIsTUFBTUssZ0NBQWdDSixpQ0FDcEMxRixTQUNBRjtRQUVGLE1BQU1DLFVBQVVsRCw4Q0FBa0IsQ0FDaEM7WUFDRSxPQUFPb0csS0FBS0gsVUFBVSxDQUFDOUM7UUFDekIsR0FDQSxvUUFBb1E7UUFDcFE7WUFBQ3VEO1lBQUtOO1NBQUs7UUFFYixNQUFNdkIsa0JBQWtCN0IsbUJBQ3RCaUcsK0JBQ0EvRjtRQUVGN0MsZ0RBQVVBLENBQUM7WUFDVCxLQUFLd0UsZ0JBQWdCO2dCQUFFckIsY0FBYztZQUFLO1FBQzVDLEdBQUc7WUFBQ3FCO1NBQWdCO1FBQ3BCeEUsZ0RBQVVBLENBQUM7WUFDVDRDLFFBQVF1Ryx1QkFBdUIsQ0FBQzlDO1lBQ2hDLE9BQU87Z0JBQ0x6RCxRQUFRd0csdUJBQXVCLENBQUMvQztZQUNsQztRQUNGLEdBQUc7WUFBQ3pEO1lBQVN5RDtTQUFJO1FBQ2pCLE1BQU1nRCxRQUFRQyxZQUFZdkQsTUFBTWpEO1FBQ2hDLElBQUl1RyxNQUFNcEUsS0FBSyxFQUFFO1lBQ2YsTUFBTW9FLE1BQU1wRSxLQUFLO1FBQ25CO1FBQ0EsSUFBSW9FLE1BQU1HLFNBQVMsSUFBSSxDQUFDSCxNQUFNeEQsT0FBTyxFQUFFO1lBQ3JDLE1BQU1yQixnQkFBZ0I7Z0JBQ3BCckIsY0FBYztZQUNoQjtRQUNGO1FBQ0EsT0FBTztZQUNMcUcsV0FBVztZQUNYM0QsU0FBU3dELE1BQU14RCxPQUFPO1lBQ3RCWixPQUFPb0UsTUFBTXBFLEtBQUs7UUFDcEI7SUFDRjtJQUNBLFNBQVNxRSxZQUFZdkQsSUFBSSxFQUFFakQsT0FBTztRQUNoQyxNQUFNRixVQUFVMkY7UUFDaEIsTUFBTUssZ0NBQWdDSixpQ0FDcEMxRixTQUNBRjtRQUVGLE9BQU9yRCwrR0FBZ0NBLENBQ3JDaUcsTUFBTW5FLFNBQVMsRUFDZixJQUFNbUUsTUFBTUksVUFBVSxJQUN0QixJQUFNSixNQUFNSSxVQUFVLElBQ3RCLENBQUM2RDtZQUNDLE1BQU1ELFlBQVlaLDhCQUE4QmMsWUFBWTtZQUM1RCxJQUFJRixXQUFXO2dCQUNiLE9BQU87b0JBQ0xBLFdBQVc7Z0JBQ2I7WUFDRjtZQUNBLE1BQU1HLFdBQVdmLDhCQUE4QmxDLFVBQVU7WUFDekQsTUFBTXpCLFFBQVEyRCw4QkFBOEJkLFFBQVE7WUFDcEQsTUFBTThCLFdBQVdILE1BQU1yRCxNQUFNLENBQUMsQ0FBQ2U7Z0JBQzdCLElBQUlBLE9BQU8wQyxNQUFNLEtBQUs5RCxLQUFLRSxFQUFFLEVBQzNCLE9BQU87Z0JBQ1QsTUFBTWdELFFBQVFVLFNBQVNWLEtBQUssSUFBSSxDQUFDO2dCQUNqQyxJQUFLLE1BQU01QyxPQUFPNEMsTUFBTUMsUUFBUSxDQUFFO29CQUNoQyxJQUFJL0IsT0FBTytCLFFBQVEsQ0FBQzdDLElBQUksS0FBSzRDLE1BQU1DLFFBQVEsQ0FBQzdDLElBQUksRUFBRTt3QkFDaEQsT0FBTztvQkFDVDtnQkFDRjtnQkFDQSxPQUFPO1lBQ1Q7WUFDQSxPQUFPO2dCQUNMbUQsV0FBVztnQkFDWDNELFNBQVMrRDtnQkFDVDNFO1lBQ0Y7UUFDRjtJQUVKO0lBQ0EsU0FBUzZFLHNCQUFzQi9ELElBQUk7UUFDakMsTUFBTW5ELFVBQVUyRjtRQUNoQixNQUFNMUYsVUFBVWtHO1FBQ2hCLE1BQU1nQixhQUFhcEgsbUJBQW1CQyxTQUFTQztRQUMvQyxNQUFNNkIsU0FBU0QsVUFBVTdCLFNBQVNtSDtRQUNsQyxNQUFNQyxxQkFBcUJsSyxrREFBWUEsQ0FDckMsQ0FBQ2dEO1lBQ0MsTUFBTW1ILFdBQVduSCxRQUFRbUgsUUFBUTtZQUNqQyxNQUFNZixXQUFXLGNBQWNwRyxVQUFVQSxRQUFRb0csUUFBUSxHQUFHLENBQUM7WUFDN0QsTUFBTXJELFVBQVVELFdBQVdoRDtZQUMzQixNQUFNb0MsaUJBQWlCYSxRQUFRVSxHQUFHLENBQ2hDLENBQUNZLFNBQVdBLE9BQU9sQixFQUFFLEtBQUtnRSxXQUFXO29CQUNuQyxHQUFHOUMsTUFBTTtvQkFDVCtCLFVBQVU7d0JBQ1IsR0FBRy9CLE9BQU8rQixRQUFRO3dCQUNsQixHQUFHQSxRQUFRO29CQUNiO2dCQUNGLElBQUkvQjtZQUVOekMsT0FBT3FCLEtBQUtpRSxrQkFBa0IsQ0FBQztnQkFBRWQ7Z0JBQVVlO1lBQVMsSUFBSTtnQkFDdERqRjtZQUNGLEdBQUdrRixLQUFLLENBQUMsQ0FBQzVGO2dCQUNSLElBQUksQ0FBRUEsQ0FBQUEsZUFBZTdFLDhEQUFlLEdBQUk7b0JBQ3RDLE1BQU02RTtnQkFDUjtnQkFDQSxNQUFNVyxRQUFRa0YsdUJBQXVCN0Y7Z0JBQ3JDaUIsaUJBQWlCNkUsTUFBTSxDQUNyQixJQUFJNUosd0JBQXdCeUUsT0FBTztvQkFDakM0RSxRQUFROUQsS0FBS0UsRUFBRTtvQkFDZmdFO29CQUNBZjtnQkFDRjtZQUVKO1FBQ0YsR0FDQTtZQUFDbkQ7WUFBTXJCO1lBQVE5QjtTQUFRO1FBRXpCLE9BQU9vSDtJQUNUO0lBQ0EsU0FBU0ssZ0JBQWdCdEUsSUFBSTtRQUMzQixNQUFNbkQsVUFBVTJGO1FBQ2hCLE1BQU0xRixVQUFVa0c7UUFDaEIsTUFBTWdCLGFBQWFwSCxtQkFBbUJDLFNBQVNDO1FBQy9DLE1BQU02QixTQUFTRCxVQUFVN0IsU0FBU21IO1FBQ2xDLE1BQU1PLGVBQWV4SyxrREFBWUEsQ0FDL0IsQ0FBQ2dEO1lBQ0MsTUFBTXlILE9BQU96SCxRQUFReUgsSUFBSTtZQUN6QixNQUFNckIsV0FBVyxjQUFjcEcsVUFBVUEsUUFBUW9HLFFBQVEsR0FBRyxDQUFDO1lBQzdELE1BQU1yRCxVQUFVRCxXQUFXaEQ7WUFDM0IsTUFBTXFILFdBQVdPO1lBQ2pCLE1BQU1DLFlBQVlDO1lBQ2xCLE1BQU1DLE1BQU0sYUFBYSxHQUFHLElBQUlDO1lBQ2hDLE1BQU1DLGFBQWE7Z0JBQ2pCNUUsSUFBSXdFO2dCQUNKUjtnQkFDQUosUUFBUTlELEtBQUtFLEVBQUU7Z0JBQ2Y2RSxXQUFXSDtnQkFDWEksTUFBTTtnQkFDTkMsUUFBUUMsaUJBQWlCbEY7Z0JBQ3pCd0U7Z0JBQ0FXLFdBQVcsRUFBRTtZQUNmO1lBQ0EsTUFBTUMsWUFBWTtnQkFDaEJsRixJQUFJZ0U7Z0JBQ0pjLE1BQU07Z0JBQ05ELFdBQVdIO2dCQUNYZCxRQUFROUQsS0FBS0UsRUFBRTtnQkFDZmlEO2dCQUNBZCxVQUFVO29CQUFDeUM7aUJBQVc7WUFDeEI7WUFDQW5HLE9BQU9xQixLQUFLdUUsWUFBWSxDQUFDO2dCQUFFTDtnQkFBVVE7Z0JBQVdGO2dCQUFNckI7WUFBUyxJQUFJO2dCQUNqRWxFLGdCQUFnQjt1QkFBSWE7b0JBQVNzRjtpQkFBVTtZQUN6QyxHQUFHakIsS0FBSyxDQUFDLENBQUM1RjtnQkFDUixJQUFJLENBQUVBLENBQUFBLGVBQWU3RSw4REFBZSxHQUFJO29CQUN0QyxNQUFNNkU7Z0JBQ1I7Z0JBQ0EsTUFBTVcsUUFBUWtGLHVCQUF1QjdGO2dCQUNyQ2lCLGlCQUFpQjZFLE1BQU0sQ0FDckIsSUFBSWxLLGtCQUFrQitFLE9BQU87b0JBQzNCNEUsUUFBUTlELEtBQUtFLEVBQUU7b0JBQ2ZnRTtvQkFDQVE7b0JBQ0FGO29CQUNBckI7Z0JBQ0Y7WUFFSjtZQUNBLE9BQU9pQztRQUNULEdBQ0E7WUFBQ3BGO1lBQU1yQjtZQUFROUI7U0FBUTtRQUV6QixPQUFPMEg7SUFDVDtJQUNBLFNBQVNjLGlCQUFpQnJGLElBQUk7UUFDNUIsTUFBTW5ELFVBQVUyRjtRQUNoQixNQUFNMUYsVUFBVWtHO1FBQ2hCLE1BQU1nQixhQUFhcEgsbUJBQW1CQyxTQUFTQztRQUMvQyxNQUFNNkIsU0FBU0QsVUFBVTdCLFNBQVNtSDtRQUNsQyxNQUFNc0IsZ0JBQWdCdkwsa0RBQVlBLENBQ2hDLENBQUMsRUFBRW1LLFFBQVEsRUFBRU0sSUFBSSxFQUFFO1lBQ2pCLE1BQU0xRSxVQUFVRCxXQUFXaEQ7WUFDM0IsTUFBTTZILFlBQVlDO1lBQ2xCLE1BQU1DLE1BQU0sYUFBYSxHQUFHLElBQUlDO1lBQ2hDLE1BQU1VLFVBQVU7Z0JBQ2RyRixJQUFJd0U7Z0JBQ0pSO2dCQUNBSixRQUFROUQsS0FBS0UsRUFBRTtnQkFDZjhFLE1BQU07Z0JBQ05ELFdBQVdIO2dCQUNYSyxRQUFRQyxpQkFBaUJsRjtnQkFDekJ3RTtnQkFDQVcsV0FBVyxFQUFFO1lBQ2Y7WUFDQSxNQUFNbEcsaUJBQWlCYSxRQUFRVSxHQUFHLENBQ2hDLENBQUNZLFNBQVdBLE9BQU9sQixFQUFFLEtBQUtnRSxXQUFXO29CQUNuQyxHQUFHOUMsTUFBTTtvQkFDVGlCLFVBQVU7MkJBQUlqQixPQUFPaUIsUUFBUTt3QkFBRWtEO3FCQUFRO2dCQUN6QyxJQUFJbkU7WUFFTnpDLE9BQU9xQixLQUFLc0YsYUFBYSxDQUFDO2dCQUFFcEI7Z0JBQVVRO2dCQUFXRjtZQUFLLElBQUk7Z0JBQ3hEdkY7WUFDRixHQUFHa0YsS0FBSyxDQUFDLENBQUM1RjtnQkFDUixJQUFJLENBQUVBLENBQUFBLGVBQWU3RSw4REFBZSxHQUFJO29CQUN0QyxNQUFNNkU7Z0JBQ1I7Z0JBQ0EsTUFBTVcsUUFBUWtGLHVCQUF1QjdGO2dCQUNyQ2lCLGlCQUFpQjZFLE1BQU0sQ0FDckIsSUFBSTNKLG1CQUFtQndFLE9BQU87b0JBQzVCNEUsUUFBUTlELEtBQUtFLEVBQUU7b0JBQ2ZnRTtvQkFDQVE7b0JBQ0FGO2dCQUNGO1lBRUo7WUFDQSxPQUFPZTtRQUNULEdBQ0E7WUFBQ3ZGO1lBQU1yQjtZQUFROUI7U0FBUTtRQUV6QixPQUFPeUk7SUFDVDtJQUNBLFNBQVNFLGVBQWV4RixJQUFJO1FBQzFCLE1BQU1uRCxVQUFVMkY7UUFDaEIsTUFBTTFGLFVBQVVrRztRQUNoQixNQUFNZ0IsYUFBYXBILG1CQUFtQkMsU0FBU0M7UUFDL0MsTUFBTTZCLFNBQVNELFVBQVU3QixTQUFTbUg7UUFDbEMsTUFBTXlCLGNBQWMxTCxrREFBWUEsQ0FDOUIsQ0FBQyxFQUFFbUssUUFBUSxFQUFFUSxTQUFTLEVBQUVGLElBQUksRUFBRTtZQUM1QixNQUFNMUUsVUFBVUQsV0FBV2hEO1lBQzNCLE1BQU0rSCxNQUFNLGFBQWEsR0FBRyxJQUFJQztZQUNoQyxNQUFNNUYsaUJBQWlCYSxRQUFRVSxHQUFHLENBQ2hDLENBQUNZLFNBQVdBLE9BQU9sQixFQUFFLEtBQUtnRSxXQUFXO29CQUNuQyxHQUFHOUMsTUFBTTtvQkFDVGlCLFVBQVVqQixPQUFPaUIsUUFBUSxDQUFDN0IsR0FBRyxDQUMzQixDQUFDK0UsVUFBWUEsUUFBUXJGLEVBQUUsS0FBS3dFLFlBQVk7NEJBQ3RDLEdBQUdhLE9BQU87NEJBQ1ZHLFVBQVVkOzRCQUNWSjt3QkFDRixJQUFJZTtnQkFFUixJQUFJbkU7WUFFTnpDLE9BQU9xQixLQUFLeUYsV0FBVyxDQUFDO2dCQUFFdkI7Z0JBQVVRO2dCQUFXRjtZQUFLLElBQUk7Z0JBQ3REdkY7WUFDRixHQUFHa0YsS0FBSyxDQUFDLENBQUM1RjtnQkFDUixJQUFJLENBQUVBLENBQUFBLGVBQWU3RSw4REFBZSxHQUFJO29CQUN0QyxNQUFNNkU7Z0JBQ1I7Z0JBQ0EsTUFBTVcsUUFBUWtGLHVCQUF1QjdGO2dCQUNyQ2lCLGlCQUFpQjZFLE1BQU0sQ0FDckIsSUFBSTFKLGlCQUFpQnVFLE9BQU87b0JBQzFCNEUsUUFBUTlELEtBQUtFLEVBQUU7b0JBQ2ZnRTtvQkFDQVE7b0JBQ0FGO2dCQUNGO1lBRUo7UUFDRixHQUNBO1lBQUN4RTtZQUFNckI7WUFBUTlCO1NBQVE7UUFFekIsT0FBTzRJO0lBQ1Q7SUFDQSxTQUFTRSxpQkFBaUIzRixJQUFJO1FBQzVCLE1BQU1uRCxVQUFVMkY7UUFDaEIsTUFBTTFGLFVBQVVrRztRQUNoQixNQUFNZ0IsYUFBYXBILG1CQUFtQkMsU0FBU0M7UUFDL0MsTUFBTTZCLFNBQVNELFVBQVU3QixTQUFTbUg7UUFDbEMsTUFBTTRCLGdCQUFnQjdMLGtEQUFZQSxDQUNoQyxDQUFDLEVBQUVtSyxRQUFRLEVBQUVRLFNBQVMsRUFBRTtZQUN0QixNQUFNNUUsVUFBVUQsV0FBV2hEO1lBQzNCLE1BQU0rSCxNQUFNLGFBQWEsR0FBRyxJQUFJQztZQUNoQyxNQUFNZ0IsYUFBYSxFQUFFO1lBQ3JCLEtBQUssTUFBTXpFLFVBQVV0QixRQUFTO2dCQUM1QixJQUFJc0IsT0FBT2xCLEVBQUUsS0FBS2dFLFVBQVU7b0JBQzFCLE1BQU1rQixZQUFZO3dCQUNoQixHQUFHaEUsTUFBTTt3QkFDVGlCLFVBQVVqQixPQUFPaUIsUUFBUSxDQUFDN0IsR0FBRyxDQUMzQixDQUFDK0UsVUFBWUEsUUFBUXJGLEVBQUUsS0FBS3dFLFlBQVk7Z0NBQ3RDLEdBQUdhLE9BQU87Z0NBQ1ZPLFdBQVdsQjtnQ0FDWEosTUFBTSxLQUFLOzRCQUNiLElBQUllO29CQUVSO29CQUNBLElBQUlILFVBQVUvQyxRQUFRLENBQUMwRCxJQUFJLENBQ3pCLENBQUNSLFVBQVlBLFFBQVFPLFNBQVMsS0FBSyxLQUFLLElBQ3ZDO3dCQUNERCxXQUFXRyxJQUFJLENBQUNaO29CQUNsQjtnQkFDRixPQUFPO29CQUNMUyxXQUFXRyxJQUFJLENBQUM1RTtnQkFDbEI7WUFDRjtZQUNBekMsT0FBT3FCLEtBQUs0RixhQUFhLENBQUM7Z0JBQUUxQjtnQkFBVVE7WUFBVSxJQUFJO2dCQUNsRHpGLGdCQUFnQjRHO1lBQ2xCLEdBQUcxQixLQUFLLENBQUMsQ0FBQzVGO2dCQUNSLElBQUksQ0FBRUEsQ0FBQUEsZUFBZTdFLDhEQUFlLEdBQUk7b0JBQ3RDLE1BQU02RTtnQkFDUjtnQkFDQSxNQUFNVyxRQUFRa0YsdUJBQXVCN0Y7Z0JBQ3JDaUIsaUJBQWlCNkUsTUFBTSxDQUNyQixJQUFJekosbUJBQW1Cc0UsT0FBTztvQkFDNUI0RSxRQUFROUQsS0FBS0UsRUFBRTtvQkFDZmdFO29CQUNBUTtnQkFDRjtZQUVKO1FBQ0YsR0FDQTtZQUFDMUU7WUFBTXJCO1lBQVE5QjtTQUFRO1FBRXpCLE9BQU8rSTtJQUNUO0lBQ0EsU0FBU0ssZUFBZWpHLElBQUk7UUFDMUIsTUFBTW5ELFVBQVUyRjtRQUNoQixNQUFNMUYsVUFBVWtHO1FBQ2hCLE1BQU1nQixhQUFhcEgsbUJBQW1CQyxTQUFTQztRQUMvQyxNQUFNNkIsU0FBU0QsVUFBVTdCLFNBQVNtSDtRQUNsQyxNQUFNc0IsZ0JBQWdCdkwsa0RBQVlBLENBQ2hDLENBQUMsRUFBRW1LLFFBQVEsRUFBRVEsU0FBUyxFQUFFd0IsS0FBSyxFQUFFO1lBQzdCLE1BQU1wRyxVQUFVRCxXQUFXaEQ7WUFDM0IsTUFBTStILE1BQU0sYUFBYSxHQUFHLElBQUlDO1lBQ2hDLE1BQU1JLFNBQVNDLGlCQUFpQmxGO1lBQ2hDLE1BQU1mLGlCQUFpQmEsUUFBUVUsR0FBRyxDQUNoQyxDQUFDWSxTQUFXQSxPQUFPbEIsRUFBRSxLQUFLZ0UsV0FBVztvQkFDbkMsR0FBRzlDLE1BQU07b0JBQ1RpQixVQUFVakIsT0FBT2lCLFFBQVEsQ0FBQzdCLEdBQUcsQ0FBQyxDQUFDK0U7d0JBQzdCLElBQUlBLFFBQVFyRixFQUFFLEtBQUt3RSxXQUFXOzRCQUM1QixPQUFPYTt3QkFDVDt3QkFDQSxJQUFJSjt3QkFDSixJQUFJSSxRQUFRSixTQUFTLENBQUNZLElBQUksQ0FDeEIsQ0FBQ0ksV0FBYUEsU0FBU0QsS0FBSyxLQUFLQSxRQUNoQzs0QkFDRGYsWUFBWUksUUFBUUosU0FBUyxDQUFDM0UsR0FBRyxDQUMvQixDQUFDMkYsV0FBYUEsU0FBU0QsS0FBSyxLQUFLQSxRQUFRO29DQUN2QyxHQUFHQyxRQUFRO29DQUNYQyxPQUFPOzJDQUFJRCxTQUFTQyxLQUFLO3dDQUFFOzRDQUFFbEcsSUFBSStFO3dDQUFPO3FDQUFFO2dDQUM1QyxJQUFJa0I7d0JBRVIsT0FBTzs0QkFDTGhCLFlBQVk7bUNBQ1BJLFFBQVFKLFNBQVM7Z0NBQ3BCO29DQUNFZTtvQ0FDQW5CLFdBQVdIO29DQUNYd0IsT0FBTzt3Q0FBQzs0Q0FBRWxHLElBQUkrRTt3Q0FBTztxQ0FBRTtnQ0FDekI7NkJBQ0Q7d0JBQ0g7d0JBQ0EsT0FBTzs0QkFDTCxHQUFHTSxPQUFPOzRCQUNWSjt3QkFDRjtvQkFDRjtnQkFDRixJQUFJL0Q7WUFFTnpDLE9BQU9xQixLQUFLcUcsV0FBVyxDQUFDO2dCQUFFbkM7Z0JBQVVRO2dCQUFXd0I7WUFBTSxJQUFJO2dCQUN2RGpIO1lBQ0YsR0FBR2tGLEtBQUssQ0FBQyxDQUFDNUY7Z0JBQ1IsSUFBSSxDQUFFQSxDQUFBQSxlQUFlN0UsOERBQWUsR0FBSTtvQkFDdEMsTUFBTTZFO2dCQUNSO2dCQUNBLE1BQU1XLFFBQVFrRix1QkFBdUI3RjtnQkFDckNpQixpQkFBaUI2RSxNQUFNLENBQ3JCLElBQUl4SixpQkFBaUJxRSxPQUFPO29CQUMxQjRFLFFBQVE5RCxLQUFLRSxFQUFFO29CQUNmZ0U7b0JBQ0FRO29CQUNBd0I7Z0JBQ0Y7WUFFSjtRQUNGLEdBQ0E7WUFBQ2xHO1lBQU1yQjtZQUFROUI7U0FBUTtRQUV6QixPQUFPeUk7SUFDVDtJQUNBLFNBQVNnQixrQkFBa0J0RyxJQUFJO1FBQzdCLE1BQU1uRCxVQUFVMkY7UUFDaEIsTUFBTTFGLFVBQVVrRztRQUNoQixNQUFNZ0IsYUFBYXBILG1CQUFtQkMsU0FBU0M7UUFDL0MsTUFBTTZCLFNBQVNELFVBQVU3QixTQUFTbUg7UUFDbEMsTUFBTXNCLGdCQUFnQnZMLGtEQUFZQSxDQUNoQyxDQUFDLEVBQUVtSyxRQUFRLEVBQUVRLFNBQVMsRUFBRXdCLEtBQUssRUFBRTtZQUM3QixNQUFNcEcsVUFBVUQsV0FBV2hEO1lBQzNCLE1BQU1vSSxTQUFTQyxpQkFBaUJsRjtZQUNoQyxNQUFNZixpQkFBaUJhLFFBQVFVLEdBQUcsQ0FDaEMsQ0FBQ1ksU0FBV0EsT0FBT2xCLEVBQUUsS0FBS2dFLFdBQVc7b0JBQ25DLEdBQUc5QyxNQUFNO29CQUNUaUIsVUFBVWpCLE9BQU9pQixRQUFRLENBQUM3QixHQUFHLENBQUMsQ0FBQytFO3dCQUM3QixJQUFJQSxRQUFRckYsRUFBRSxLQUFLd0UsV0FBVzs0QkFDNUIsT0FBT2E7d0JBQ1Q7d0JBQ0EsTUFBTWdCLGdCQUFnQmhCLFFBQVFKLFNBQVMsQ0FBQ3FCLFNBQVMsQ0FDL0MsQ0FBQ0wsV0FBYUEsU0FBU0QsS0FBSyxLQUFLQTt3QkFFbkMsSUFBSWYsWUFBWUksUUFBUUosU0FBUzt3QkFDakMsSUFBSW9CLGlCQUFpQixLQUFLaEIsUUFBUUosU0FBUyxDQUFDb0IsY0FBYyxDQUFDSCxLQUFLLENBQUNMLElBQUksQ0FDbkUsQ0FBQ1UsT0FBU0EsS0FBS3ZHLEVBQUUsS0FBSytFLFNBQ3JCOzRCQUNELElBQUlNLFFBQVFKLFNBQVMsQ0FBQ29CLGNBQWMsQ0FBQ0gsS0FBSyxDQUFDTSxNQUFNLElBQUksR0FBRztnQ0FDdER2QixZQUFZO3VDQUFJSSxRQUFRSixTQUFTO2lDQUFDO2dDQUNsQ0EsVUFBVXdCLE1BQU0sQ0FBQ0osZUFBZTs0QkFDbEMsT0FBTztnQ0FDTHBCLFNBQVMsQ0FBQ29CLGNBQWMsR0FBRztvQ0FDekIsR0FBR3BCLFNBQVMsQ0FBQ29CLGNBQWM7b0NBQzNCSCxPQUFPakIsU0FBUyxDQUFDb0IsY0FBYyxDQUFDSCxLQUFLLENBQUMvRixNQUFNLENBQzFDLENBQUNvRyxPQUFTQSxLQUFLdkcsRUFBRSxLQUFLK0U7Z0NBRTFCOzRCQUNGO3dCQUNGO3dCQUNBLE9BQU87NEJBQ0wsR0FBR00sT0FBTzs0QkFDVko7d0JBQ0Y7b0JBQ0Y7Z0JBQ0YsSUFBSS9EO1lBRU56QyxPQUFPcUIsS0FBSzRHLGNBQWMsQ0FBQztnQkFBRTFDO2dCQUFVUTtnQkFBV3dCO1lBQU0sSUFBSTtnQkFDMURqSDtZQUNGLEdBQUdrRixLQUFLLENBQUMsQ0FBQzVGO2dCQUNSLElBQUksQ0FBRUEsQ0FBQUEsZUFBZTdFLDhEQUFlLEdBQUk7b0JBQ3RDLE1BQU02RTtnQkFDUjtnQkFDQSxNQUFNVyxRQUFRa0YsdUJBQXVCN0Y7Z0JBQ3JDaUIsaUJBQWlCNkUsTUFBTSxDQUNyQixJQUFJdkosb0JBQW9Cb0UsT0FBTztvQkFDN0I0RSxRQUFROUQsS0FBS0UsRUFBRTtvQkFDZmdFO29CQUNBUTtvQkFDQXdCO2dCQUNGO1lBRUo7UUFDRixHQUNBO1lBQUNsRztZQUFNckI7WUFBUTlCO1NBQVE7UUFFekIsT0FBT3lJO0lBQ1Q7SUFDQSxPQUFPO1FBQ0x2RjtRQUNBa0Q7UUFDQU87UUFDQU87UUFDQU87UUFDQWU7UUFDQUc7UUFDQUc7UUFDQU07UUFDQUs7SUFDRjtBQUNGO0FBQ0EsU0FBU08sbUJBQW1CQyxNQUFNO0lBQ2hDLE9BQU8sQ0FBQyxFQUFFQSxPQUFPLENBQUMsRUFBRW5OLDhDQUFNQSxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTOEs7SUFDUCxPQUFPb0MsbUJBQW1CMUg7QUFDNUI7QUFDQSxTQUFTd0Y7SUFDUCxPQUFPa0MsbUJBQW1Cekg7QUFDNUI7QUFDQSxTQUFTOEYsaUJBQWlCbEYsSUFBSTtJQUM1QixNQUFNK0csT0FBTy9HLEtBQUtnSCxPQUFPO0lBQ3pCLElBQUlELFNBQVMsUUFBUUEsS0FBSzdHLEVBQUUsS0FBSyxLQUFLLEdBQUc7UUFDdkMsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPNkcsS0FBSzdHLEVBQUU7SUFDaEI7QUFDRjtBQUNBLFNBQVNrRSx1QkFBdUI3RixHQUFHO0lBQ2pDLE1BQU0wSSxVQUFVLENBQUMsMkJBQTJCLEVBQUUxSSxJQUFJK0MsTUFBTSxDQUFDLEVBQUUsRUFBRS9DLElBQUkwSSxPQUFPLENBQUMsQ0FBQztJQUMxRSxJQUFJMUksSUFBSTJJLE9BQU8sRUFBRWhJLFVBQVUsYUFBYTtRQUN0QyxNQUFNaUksa0JBQWtCO1lBQUNGO1lBQVMxSSxJQUFJMkksT0FBTyxDQUFDRSxVQUFVO1lBQUU3SSxJQUFJMkksT0FBTyxDQUFDRyxJQUFJO1NBQUMsQ0FBQ2hILE1BQU0sQ0FBQ2lILFNBQVNDLElBQUksQ0FBQztRQUNqR0MsUUFBUXRJLEtBQUssQ0FBQ2lJO0lBQ2hCO0lBQ0EsT0FBTyxJQUFJL00sTUFBTTZNO0FBQ25CO0FBQ0EsU0FBU2hILDhCQUE4QjZELE1BQU0sRUFBRSxFQUM3QzlFLFFBQVEsRUFDUlYsUUFBUSxFQUNUO0lBQ0MsSUFBSW1KO0lBQ0osSUFBSXZJO0lBQ0osSUFBSXdJO0lBQ0osTUFBTUMsK0JBQStCLGFBQWEsR0FBRyxJQUFJekc7SUFDekQsTUFBTTBHLDBCQUEwQixhQUFhLEdBQUcsSUFBSTFHO0lBQ3BELE9BQU87UUFDTCxRQUFRO1FBQ1JsQztZQUNFLE1BQU1jLFVBQVVkO1lBQ2hCLE1BQU02RSxXQUFXL0QsUUFBUU8sTUFBTSxDQUFDLENBQUNlLFNBQVdBLE9BQU8wQyxNQUFNLEtBQUtBO1lBQzlELE9BQU9EO1FBQ1Q7UUFDQXZGLFVBQVNpRSxLQUFLO1lBQ1osS0FBSyxNQUFNakMsT0FBT3FILDZCQUE2QkUsSUFBSSxHQUFJO2dCQUNyRCxJQUFJRCx3QkFBd0JFLEdBQUcsQ0FBQ3hILFNBQVMsR0FBRztvQkFDMUNxSCw2QkFBNkJJLE1BQU0sQ0FBQ3pIO29CQUNwQ3NILHdCQUF3QkcsTUFBTSxDQUFDekg7Z0JBQ2pDO1lBQ0Y7WUFDQSxNQUFNMEgsU0FBU3pGLE1BQU0wRixJQUFJLENBQ3ZCLENBQUNDLEdBQUdDLElBQU0sSUFBSXRELEtBQUtxRCxFQUFFbkQsU0FBUyxFQUFFcUQsT0FBTyxLQUFLLElBQUl2RCxLQUFLc0QsRUFBRXBELFNBQVMsRUFBRXFELE9BQU87WUFFM0UsTUFBTXRJLFVBQVVkO1lBQ2hCLE1BQU02RyxhQUFhL0YsUUFBUU8sTUFBTSxDQUFDLENBQUNlLFNBQVdBLE9BQU8wQyxNQUFNLEtBQUtBLFFBQVF1RSxNQUFNLENBQUNMO1lBQy9FMUosU0FBU3VIO1FBQ1g7UUFDQSxVQUFVO1FBQ1ZySTtZQUNFLE9BQU9pSztRQUNUO1FBQ0E5SixZQUFXNEUsS0FBSztZQUNka0YsVUFBVWxGO1FBQ1o7UUFDQSxRQUFRO1FBQ1JSO1lBQ0UsT0FBTzdDO1FBQ1Q7UUFDQVYsVUFBU0QsR0FBRztZQUNWVyxRQUFRWDtRQUNWO1FBQ0EsV0FBVztRQUNYSjtZQUNFLE9BQU91SjtRQUNUO1FBQ0E1SSxhQUFZd0osSUFBSTtZQUNkWixXQUFXWTtRQUNiO1FBQ0FsSTtZQUNFLE9BQU9ZLE1BQU1DLElBQUksQ0FBQzBHLDZCQUE2QlksT0FBTztRQUN4RDtRQUNBM0Ysd0JBQXVCdEMsR0FBRztZQUN4QixPQUFPcUgsNkJBQTZCRyxHQUFHLENBQUN4SDtRQUMxQztRQUNBeUMsd0JBQXVCekMsR0FBRyxFQUFFekQsT0FBTztZQUNqQzhLLDZCQUE2QmEsR0FBRyxDQUFDbEksS0FBS3pEO1FBQ3hDO1FBQ0FtRjtZQUNFLE9BQU9oQixNQUFNQyxJQUFJLENBQUMyRyx3QkFBd0J2RyxNQUFNLElBQUlvSCxNQUFNLENBQ3hELENBQUNDLEtBQUtDLFFBQVVELE1BQU1DLE9BQ3RCO1FBRUo7UUFDQXZGLHlCQUF3QjlDLEdBQUc7WUFDekIsTUFBTXFJLFFBQVFmLHdCQUF3QkUsR0FBRyxDQUFDeEgsUUFBUTtZQUNsRHNILHdCQUF3QlksR0FBRyxDQUFDbEksS0FBS3FJLFFBQVE7UUFDM0M7UUFDQXRGLHlCQUF3Qi9DLEdBQUc7WUFDekIsTUFBTXFJLFFBQVFmLHdCQUF3QkUsR0FBRyxDQUFDeEgsUUFBUTtZQUNsRHNILHdCQUF3QlksR0FBRyxDQUFDbEksS0FBS3FJLFFBQVE7UUFDM0M7UUFDQXBJLG1CQUFrQkQsR0FBRztZQUNuQixPQUFPc0gsd0JBQXdCRSxHQUFHLENBQUN4SCxRQUFRO1FBQzdDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNaO0lBQ1AsSUFBSUksVUFBVSxFQUFFO0lBQ2hCLE1BQU04SSxxQkFBcUJ6UCxpRUFBZUE7SUFDMUMsT0FBTztRQUNMMEc7WUFDRSxPQUFPQztRQUNUO1FBQ0FLLFlBQVdvQyxLQUFLO1lBQ2R6QyxVQUFVeUM7WUFDVnFHLG1CQUFtQnZFLE1BQU0sQ0FBQ3ZFO1FBQzVCO1FBQ0F4RSxXQUFVdU4sUUFBUTtZQUNoQixPQUFPRCxtQkFBbUJ0TixTQUFTLENBQUN1TjtRQUN0QztJQUNGO0FBQ0Y7QUFDQSxTQUFTL0Ysb0NBQW9DL0YsT0FBTyxFQUFFRixPQUFPO0lBQzNELElBQUk0RyxZQUFZO0lBQ2hCLElBQUlnRTtJQUNKLElBQUl2STtJQUNKLE9BQU87UUFDTCxRQUFRO1FBQ1JGO1lBQ0UsT0FBTyxLQUFLO1FBQ2Q7UUFDQVYsVUFBU2lFLEtBQUs7WUFDWixNQUFNZSxRQUFRLElBQUlwQyxJQUNoQixDQUFDckUsUUFBUW1DLFFBQVEsTUFBTSxFQUFFLEVBQUV3QixHQUFHLENBQUMsQ0FBQ1ksU0FBVztvQkFBQ0EsT0FBT2xCLEVBQUU7b0JBQUVrQjtpQkFBTztZQUVoRSxLQUFLLE1BQU1BLFVBQVVtQixNQUFPO2dCQUMxQmUsTUFBTWtGLEdBQUcsQ0FBQ3BILE9BQU9sQixFQUFFLEVBQUVrQjtZQUN2QjtZQUNBdkUsUUFBUXlCLFFBQVEsQ0FBQzBDLE1BQU1DLElBQUksQ0FBQ3FDLE1BQU1qQyxNQUFNO1lBQ3hDb0MsWUFBWTtRQUNkO1FBQ0EsVUFBVTtRQUNWakc7WUFDRSxPQUFPaUs7UUFDVDtRQUNBOUosWUFBVzRFLEtBQUs7WUFDZGtGLFVBQVVsRjtRQUNaO1FBQ0EsUUFBUTtRQUNSUjtZQUNFLE9BQU83QztRQUNUO1FBQ0FWLFVBQVNELEdBQUc7WUFDVlcsUUFBUVg7WUFDUmtGLFlBQVk7WUFDWixNQUFNSCxRQUFRekcsUUFBUW1DLFFBQVE7WUFDOUJuQyxRQUFReUIsUUFBUSxDQUFDZ0Y7UUFDbkI7UUFDQSxXQUFXO1FBQ1huRjtZQUNFLE9BQU8sS0FBSztRQUNkO1FBQ0FXLGFBQVkyQixDQUFDO1lBQ1g7UUFDRjtRQUNBRTtZQUNFLE9BQU81RDtRQUNUO1FBQ0E0RztZQUNFLE9BQU9GO1FBQ1Q7UUFDQXFGLGNBQWF2RyxLQUFLO1lBQ2hCa0IsWUFBWWxCO1FBQ2Q7SUFDRjtBQUNGO0FBQ0EsU0FBU1gsbUJBQW1CbUgsZUFBZSxFQUFFckgsaUJBQWlCLEVBQUVzSCxlQUFlO0lBQzdFLElBQUksQ0FBQ0QsbUJBQW1CLENBQUNySCxtQkFDdkI7SUFDRixJQUFJc0gsaUJBQ0YsT0FBTzNKO0lBQ1QsT0FBT0M7QUFDVDtBQUVBLG1DQUFtQztBQUN1RDtBQUMxRixJQUFJOEosZ0JBQWdCO0FBQ3BCLFNBQVNDLFlBQVk5RyxLQUFLLEVBQUUrRyxRQUFRRixhQUFhO0lBQy9DLE1BQU12TCxVQUFVcUwsNkNBQU9BO0lBQ3ZCLE1BQU0sQ0FBQ0ssZ0JBQWdCQyxrQkFBa0IsR0FBR0wsK0NBQVNBLENBQUM1RztJQUN0RDBHLGdEQUFVQSxDQUFDO1FBQ1QsSUFBSUssVUFBVSxPQUFPO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJekwsUUFBUTFCLE9BQU8sS0FBSyxLQUFLLEdBQUc7WUFDOUJxTixrQkFBa0JqSDtRQUNwQjtRQUNBMUUsUUFBUTFCLE9BQU8sR0FBR0UsT0FBTzJCLFVBQVUsQ0FBQztZQUNsQ3dMLGtCQUFrQmpIO1lBQ2xCMUUsUUFBUTFCLE9BQU8sR0FBRyxLQUFLO1FBQ3pCLEdBQUdtTjtRQUNILE9BQU87WUFDTGpOLE9BQU82RixZQUFZLENBQUNyRSxRQUFRMUIsT0FBTztRQUNyQztJQUNGLEdBQUc7UUFBQ29HO1FBQU8rRztLQUFNO0lBQ2pCLE9BQU9DO0FBQ1Q7QUFFQSw2QkFBNkI7QUFDd0Y7QUFDZjtBQUV0Ryx5QkFBeUI7QUFDcUI7QUFDOUMsU0FBU1EsV0FBV3hILEtBQUs7SUFDdkIsT0FBT3VILCtDQUFTQSxDQUFDdkgsTUFBTSxDQUFDLEVBQUU7QUFDNUI7QUFFQSw2QkFBNkI7QUFDN0IsSUFBSXlILHNCQUFzQjtJQUN4QnZHLFdBQVc7SUFDWDdFLE1BQU0sS0FBSztJQUNYTSxPQUFPLEtBQUs7QUFDZDtBQUNBLElBQUkrSyxPQUFPLEtBQ1g7QUFDQSxTQUFTQyxjQUFjNUcsS0FBSyxFQUFFaEQsR0FBRyxFQUFFdkQsT0FBTztJQUN4QyxNQUFNb04sZ0JBQWdCSixXQUFXaE47SUFDakMsTUFBTXFOLFlBQVlULDhDQUFRQSxDQUFDO1FBQ3pCLElBQUlySixRQUFRLFFBQVEsQ0FBQ2dELE9BQU87WUFDMUIsT0FBTztRQUNUO1FBQ0EsTUFBTStHLGFBQWEvRyxNQUFNZ0gsTUFBTSxDQUFDaEs7UUFDaEMsS0FBSytKLFdBQVd2QyxHQUFHO1FBQ25CLE9BQU91QztJQUNULEdBQUc7UUFBQy9HO1FBQU9oRDtLQUFJO0lBQ2YsTUFBTXJFLGFBQWF3TixrREFBWUEsQ0FDN0IsQ0FBQ1osV0FBYXVCLFdBQVc5TyxVQUFVdU4sYUFBYW9CLE1BQ2hEO1FBQUNHO0tBQVU7SUFFYixNQUFNRyxXQUFXZCxrREFBWUEsQ0FDM0IsSUFBTVcsV0FBV0csY0FBY1AscUJBQy9CO1FBQUNJO0tBQVU7SUFFYixNQUFNcEcsYUFBYXlGLGtEQUFZQSxDQUFDLElBQU1XLFdBQVdwRyxjQUFjO1FBQUNvRztLQUFVO0lBQzFFLE1BQU0xRyxRQUFRbUcsMkZBQXFCQSxDQUFDNU4sWUFBWXNPLFVBQVVBO0lBQzFELE1BQU1DLGVBQWVaLDZDQUFPQTtJQUM1QixJQUFJaEwsT0FBTzhFLE1BQU05RSxJQUFJO0lBQ3JCOEssZ0RBQVVBLENBQUM7UUFDVGMsYUFBYXJPLE9BQU8sR0FBRztZQUFFbUU7WUFBSzFCLE1BQU04RSxNQUFNOUUsSUFBSTtRQUFDO0lBQ2pELEdBQUc7UUFBQzBCO1FBQUtvRCxNQUFNOUUsSUFBSTtLQUFDO0lBQ3BCLElBQUksQ0FBQ3dMLFdBQVc7UUFDZCxPQUFPO1lBQ0wzRyxXQUFXO1lBQ1g3RSxNQUFNLEtBQUs7WUFDWE0sT0FBTyxLQUFLO1lBQ1pxTDtZQUNBdkc7UUFDRjtJQUNGO0lBQ0EsSUFBSW1HLGVBQWVNLFVBQVU7UUFDM0IsTUFBTXZMLFFBQVFxTCxXQUFXckwsS0FBSztRQUM5QixJQUFJQSxPQUFPO1lBQ1QsTUFBTUE7UUFDUixPQUFPLElBQUlxTCxXQUFXOUcsU0FBUyxFQUFFO1lBQy9CLE1BQU0sSUFBSTVDLFFBQVEsQ0FBQzZKO2dCQUNqQk4sVUFBVU8sYUFBYSxDQUFDLENBQUNDO29CQUN2QixJQUFJLENBQUNBLE9BQU9uSCxTQUFTLEVBQUU7d0JBQ3JCaUg7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxJQUFJaEgsTUFBTUQsU0FBUyxJQUFJMEcsZUFBZVUsZ0NBQWdDLE9BQU9uSCxNQUFNOUUsSUFBSSxLQUFLLGVBQWU0TCxhQUFhck8sT0FBTyxFQUFFbUUsUUFBUUEsT0FBTyxPQUFPa0ssYUFBYXJPLE9BQU8sRUFBRXlDLFNBQVMsYUFBYTtRQUNqTUEsT0FBTzRMLGFBQWFyTyxPQUFPLENBQUN5QyxJQUFJO0lBQ2xDO0lBQ0EsT0FBTztRQUNMNkUsV0FBV0MsTUFBTUQsU0FBUztRQUMxQjdFO1FBQ0FNLE9BQU93RSxNQUFNeEUsS0FBSztRQUNsQnFMO1FBQ0F2RztJQUNGO0FBQ0Y7QUFFQSx3QkFBd0I7QUFDMkM7QUFDbkUsU0FBU2dILFVBQVV6SSxLQUFLO0lBQ3RCLE1BQU0wSSxNQUFNRiw2Q0FBT0EsQ0FBQ3hJO0lBQ3BCdUksZ0RBQVVBLENBQUM7UUFDVEcsSUFBSTlPLE9BQU8sR0FBR29HO0lBQ2hCLEdBQUc7UUFBQ0E7S0FBTTtJQUNWLE9BQU8wSTtBQUNUO0FBRUEsMEJBQTBCO0FBQ1M7QUFDbkMsU0FBU0U7SUFDUCxNQUFNLEdBQUdDLE9BQU8sR0FBR0YsaURBQVVBLENBQzNCLDJFQUEyRTtJQUMzRSwwRUFBMEU7SUFDMUUsd0NBQXdDO0lBQ3hDLENBQUNHLElBQU1BLElBQUksR0FDWDtJQUVGLE9BQU9EO0FBQ1Q7QUFFQSxrQkFBa0I7QUFDbEIsSUFBSUUsUUFBUSxLQUNaO0FBQ0EsSUFBSUMsV0FBVyxDQUFDRixJQUFNQTtBQUN0QixJQUFJRyxrQ0FBa0MsQ0FBQ0MsY0FBYzNILFNBQVcsQ0FBQyxtQ0FBbUMsRUFBRTJILGFBQWE7Ozs7cUJBSTlGLEVBQUVDLEtBQUtyUyxTQUFTLENBQ25DeUssUUFDQTs7OztpSEFJK0csQ0FBQztBQUNsSCxJQUFJNkgsc0NBQXNDO0FBQzFDLFNBQVNwSyxzQkFBc0JxSyxDQUFDLEVBQUVDLEVBQUUsRUFBRUMsR0FBRztJQUN2QyxPQUFPclMsK0dBQWlDQSxDQUFDbVMsR0FBR0MsSUFBSUMsS0FBS1A7QUFDdkQ7QUFDQSxJQUFJUSxvQkFBb0JDLE9BQU9DLE1BQU0sQ0FBQyxFQUFFO0FBQ3hDLFNBQVNDO0lBQ1AsT0FBT0g7QUFDVDtBQUNBLFNBQVNJO0lBQ1AsT0FBTztBQUNUO0FBQ0EsU0FBU0Msb0JBQW9CcE0sSUFBSTtJQUMvQixNQUFNcU0sU0FBUztJQUNmLE9BQU87UUFDTCxJQUFJQyxXQUFVO1lBQ1osTUFBTUMsY0FBY3ZNLEtBQUt3TSxrQkFBa0I7WUFDM0MsSUFBSUQsZ0JBQWdCLE1BQU07Z0JBQ3hCLE1BQU0sSUFBSW5TLE1BQU1pUztZQUNsQjtZQUNBLE9BQU9FO1FBQ1Q7UUFDQSxJQUFJeEYsUUFBTztZQUNULE1BQU1BLE9BQU8vRyxLQUFLZ0gsT0FBTztZQUN6QixJQUFJRCxTQUFTLE1BQU07Z0JBQ2pCLE1BQU0sSUFBSTNNLE1BQU1pUztZQUNsQjtZQUNBLE9BQU90RjtRQUNUO1FBQ0EsSUFBSTBGLFVBQVM7WUFDWCxNQUFNQSxTQUFTek0sS0FBSzBNLFNBQVM7WUFDN0IsSUFBSTFNLEtBQUtnSCxPQUFPLE9BQU8sTUFBTTtnQkFDM0IsTUFBTSxJQUFJNU0sTUFBTWlTO1lBQ2xCO1lBQ0EsT0FBT0k7UUFDVDtRQUNBRSxlQUFlM00sS0FBSzRNLGNBQWM7SUFDcEM7QUFDRjtBQUNBLElBQUlDLDRCQUE0QjtBQUNoQyxTQUFTQyxxQkFBcUJDLFVBQVU7SUFDdEMsSUFBSSxDQUFDRiw2QkFBNkIsQ0FBQ0UsY0FBY0Msa0JBQXlCLGNBQWM7UUFDdEZ4RixRQUFReUYsSUFBSSxDQUNWO1FBRUZKLDRCQUE0QjtJQUM5QjtBQUNGO0FBQ0EsSUFBSUssOEJBQWdCM1QsZ0RBQW9CLENBQUM7QUFDekMsU0FBUzRUO0lBQ1AsTUFBTUMsU0FBUzdULDZDQUFpQixDQUFDMlQ7SUFDakMsSUFBSUUsV0FBVyxNQUFNO1FBQ25CLE1BQU0sSUFBSWhULE1BQU07SUFDbEI7SUFDQSxPQUFPZ1Q7QUFDVDtBQUNBLFNBQVNDLGtCQUFrQkMsTUFBTSxFQUFFdlEsT0FBTztJQUN4QyxNQUFNd1EsNEJBQWNoVSxnREFBb0IsQ0FBQztJQUN6QyxNQUFNaVUsMkJBQTJCcFUsaUVBQWdCQTtJQUNqRCxNQUFNLEVBQUUyRyxvQkFBb0IsRUFBRSxHQUFHME4sY0FBYyxHQUFHbE8sbUJBQW1CaU87SUFDckUsU0FBU0Usa0JBQWtCclYsS0FBSztRQUM5QixNQUFNLENBQUNpTCxNQUFNLEdBQUcvSiwyQ0FBZSxDQUM3QixJQUFNLGFBQWEsR0FBRyxJQUFJMkg7UUFFNUIsTUFBTXlNLGtCQUFrQnBVLDhDQUFrQixDQUN4QyxDQUFDdUssUUFBUUY7WUFDUCxNQUFNZ0ssU0FBU3RLLE1BQU13RSxHQUFHLENBQUNoRTtZQUN6QixJQUFJOEosUUFDRixPQUFPQTtZQUNULE1BQU1DLEtBQUtQLE9BQU9RLFNBQVMsQ0FDekJoSyxRQUNBRjtZQUVGLE1BQU1tSyxZQUFZRixHQUFHRyxLQUFLO1lBQzFCSCxHQUFHRyxLQUFLLEdBQUc7Z0JBQ1REO2dCQUNBekssTUFBTXlFLE1BQU0sQ0FBQ2pFO1lBQ2Y7WUFDQVIsTUFBTWtGLEdBQUcsQ0FBQzFFLFFBQVErSjtZQUNsQixPQUFPQTtRQUNULEdBQ0E7WUFBQ3ZLO1NBQU07UUFFVCxPQUFPLGFBQWEsaUJBQUcvSixnREFBb0IsQ0FBQzBVLG1CQUFtQjtZQUFFLEdBQUc1VixLQUFLO1lBQUVzVjtRQUFnQjtJQUM3RjtJQUNBLFNBQVNNLGtCQUFrQjVWLEtBQUs7UUFDOUIsTUFBTSxFQUFFNkgsSUFBSTRELE1BQU0sRUFBRTZKLGVBQWUsRUFBRSxHQUFHdFY7UUFDeEMsSUFBSTJVLElBQXFDLEVBQUU7WUFDekMsSUFBSSxDQUFDbEosUUFBUTtnQkFDWCxNQUFNLElBQUkxSixNQUNSO1lBRUo7WUFDQSxJQUFJLE9BQU8wSixXQUFXLFVBQVU7Z0JBQzlCLE1BQU0sSUFBSTFKLE1BQU07WUFDbEI7WUFDQSxNQUFNOFQsb0JBQW9CQyxTQUFTNVUsMENBQWMsS0FBSztZQUN0RCxNQUFNOFUsa0JBQWtCSCxvQkFBb0I7WUFDNUNqVix5REFBT0EsQ0FDTG9WLG1CQUFtQmhXLE1BQU1pVyx1QkFBdUIsS0FBSyxLQUFLLEdBQzFEOUMsZ0NBQWdDMEMsbUJBQW1CcEs7WUFFckQ5Syw2REFBV0EsQ0FDVCxDQUFDcVYsbUJBQW1CaFcsTUFBTWlXLHVCQUF1QixLQUFLLEtBQUssR0FDM0QzQztRQUVKO1FBQ0EsTUFBTTRDLGNBQWN4RSxXQUFXO1lBQzdCeUUsaUJBQWlCblcsTUFBTW1XLGVBQWU7WUFDdENDLGdCQUFnQnBXLE1BQU1vVyxjQUFjO1lBQ3BDSCx5QkFBeUJqVyxNQUFNaVcsdUJBQXVCO1lBQ3RESSxhQUFhclcsTUFBTXFXLFdBQVcsSUFBSXJXLE1BQU1zVyxzQkFBc0IsSUFBSSxnQkFBa0I7UUFDdEY7UUFDQSxNQUFNLENBQUMsRUFBRTNPLElBQUksRUFBRSxFQUFFNE8saUJBQWlCLEdBQUdyViwyQ0FBZSxDQUNsRCxJQUFNb1UsZ0JBQWdCN0osUUFBUTtnQkFDNUIsR0FBR3lLLFdBQVc7Z0JBQ2RHLGFBQWE7WUFFZjtRQUVGblYsNENBQWdCLENBQUM7WUFDZixNQUFNc1YsT0FBT2xCLGdCQUFnQjdKLFFBQVF5SztZQUNyQ0ssaUJBQWlCQztZQUNqQixNQUFNLEVBQUU3TyxNQUFNOE8sS0FBSyxFQUFFZCxLQUFLLEVBQUUsR0FBR2E7WUFDL0IsSUFBSU4sWUFBWUcsV0FBVyxFQUFFO2dCQUMzQkksTUFBTUMsT0FBTztZQUNmO1lBQ0EsT0FBTztnQkFDTGY7WUFDRjtRQUNGLEdBQUc7WUFBQ2xLO1lBQVF5SztZQUFhWjtTQUFnQjtRQUN6QyxPQUFPLGFBQWEsaUJBQUdwVSxnREFBb0IsQ0FBQ2dVLFlBQVlqTCxRQUFRLEVBQUU7WUFBRUMsT0FBT3ZDO1FBQUssR0FBRyxhQUFhLGlCQUFHekcsZ0RBQW9CLENBQUN3RyxzQkFBc0I7WUFBRUM7UUFBSyxHQUFHLGFBQWEsaUJBQUd6RyxnREFBb0IsQ0FDMUwyVCxjQUFjNUssUUFBUSxFQUN0QjtZQUNFQyxPQUFPeU07UUFDVCxHQUNBM1csTUFBTVEsUUFBUTtJQUVsQjtJQUNBLFNBQVNvVyxxQkFBcUJ4QyxNQUFNO1FBQ2xDLE9BQU9BLE9BQU9qTSxHQUFHLENBQUMsQ0FBQ2lHLE9BQVNBLEtBQUt5SSxZQUFZO0lBQy9DO0lBQ0EsU0FBU0M7UUFDUCxNQUFNblAsT0FBT3pHLDZDQUFpQixDQUFDZ1U7UUFDL0IsSUFBSXZOLFNBQVMsTUFBTTtZQUNqQixNQUFNLElBQUk1RixNQUFNO1FBQ2xCO1FBQ0EsT0FBTzRGO0lBQ1Q7SUFDQSxTQUFTb1A7UUFDUCxNQUFNcFAsT0FBT21QO1FBQ2IsTUFBTWxULGFBQWErRCxLQUFLd0IsTUFBTSxDQUFDRixNQUFNLENBQUNoRyxTQUFTO1FBQy9DLE1BQU1nQixlQUFlMEQsS0FBS3lCLFNBQVM7UUFDbkMsTUFBTTROLG9CQUFvQnJQLEtBQUt5QixTQUFTO1FBQ3hDLE9BQU9GLHNCQUFzQnRGLFlBQVlLLGNBQWMrUztJQUN6RDtJQUNBLFNBQVNDO1FBQ1AsTUFBTXRQLE9BQU9tUDtRQUNiLE1BQU1sVCxhQUFhK0QsS0FBS3dCLE1BQU0sQ0FBQytOLFVBQVUsQ0FBQ2pVLFNBQVM7UUFDbkQsTUFBTWdCLGVBQWUwRCxLQUFLd1AsV0FBVztRQUNyQyxNQUFNQyxXQUFXbE8sc0JBQXNCdEYsWUFBWUssY0FBY0E7UUFDakUsTUFBTW9ULGNBQWMxUCxLQUFLNE0sY0FBYztRQUN2QyxPQUFPO1lBQUM2QztZQUFVQztTQUFZO0lBQ2hDO0lBQ0EsU0FBU0M7UUFDUCxPQUFPUixVQUFVdkMsY0FBYztJQUNqQztJQUNBLFNBQVNnRCxVQUFVQyxRQUFRLEVBQUVDLE9BQU87UUFDbEMsTUFBTTlQLE9BQU9tUDtRQUNiLE1BQU1sVCxhQUFhK0QsS0FBS3dCLE1BQU0sQ0FBQ2lMLE1BQU0sQ0FBQ25SLFNBQVM7UUFDL0MsTUFBTWdCLGVBQWUwRCxLQUFLME0sU0FBUztRQUNuQyxNQUFNMkMsb0JBQW9CbkQ7UUFDMUIsT0FBT3pTLCtHQUFpQ0EsQ0FDdEN3QyxZQUNBSyxjQUNBK1MsbUJBQ0FRLFlBQVl0RSxVQUNadUU7SUFFSjtJQUNBLFNBQVNDO1FBQ1AsT0FBT0gsVUFBVVgsc0JBQXNCblcscURBQU9BO0lBQ2hEO0lBQ0EsU0FBU2tYLGdCQUFnQkMsWUFBWSxFQUFFQyxXQUFXO1FBQ2hELE1BQU1DLGtCQUFrQjVXLDhDQUFrQixDQUN4QyxDQUFDa1QsU0FBV0EsT0FBT2pNLEdBQUcsQ0FDcEIsQ0FBQzRQLFFBQVU7b0JBQUNBLE1BQU1sQixZQUFZO29CQUFFZSxhQUFhRztpQkFBTyxHQUV0RDtZQUFDSDtTQUFhO1FBRWhCLE1BQU1JLGlCQUFpQjlXLDhDQUFrQixDQUN2QyxDQUFDMk8sR0FBR0M7WUFDRixNQUFNbUksS0FBS0osZUFBZWxFLE9BQU91RSxFQUFFO1lBQ25DLE9BQU9ySSxFQUFFeEIsTUFBTSxLQUFLeUIsRUFBRXpCLE1BQU0sSUFBSXdCLEVBQUVzSSxLQUFLLENBQUMsQ0FBQ0MsUUFBUUM7Z0JBQy9DLE1BQU1DLFNBQVN4SSxDQUFDLENBQUN1SSxNQUFNO2dCQUN2QixPQUFPRCxNQUFNLENBQUMsRUFBRSxLQUFLRSxNQUFNLENBQUMsRUFBRSxJQUFJTCxHQUFHRyxNQUFNLENBQUMsRUFBRSxFQUFFRSxNQUFNLENBQUMsRUFBRTtZQUMzRDtRQUNGLEdBQ0E7WUFBQ1Q7U0FBWTtRQUVmLE9BQU9OLFVBQVVPLGlCQUFpQkU7SUFDcEM7SUFDQSxNQUFNTyxZQUFZQztJQUNsQixTQUFTQyxTQUFTNUIsWUFBWSxFQUFFVyxRQUFRLEVBQUVDLE9BQU87UUFDL0MsTUFBTUssa0JBQWtCNVcsOENBQWtCLENBQ3hDLENBQUNrVDtZQUNDLE1BQU1zRSxTQUFTdEUsT0FBT3VFLElBQUksQ0FDeEIsQ0FBQ0MsU0FBV0EsT0FBTy9CLFlBQVksS0FBS0E7WUFFdEMsT0FBTzZCLFdBQVcsS0FBSyxJQUFJbEIsU0FBU2tCLFVBQVVIO1FBQ2hELEdBQ0E7WUFBQzFCO1lBQWNXO1NBQVM7UUFFMUIsTUFBTVEsaUJBQWlCOVcsOENBQWtCLENBQ3ZDLENBQUMyWCxNQUFNQztZQUNMLElBQUlELFNBQVNOLGFBQWFPLFNBQVNQLFdBQVc7Z0JBQzVDLE9BQU9NLFNBQVNDO1lBQ2xCO1lBQ0EsTUFBTWIsS0FBS1IsV0FBVzlELE9BQU91RSxFQUFFO1lBQy9CLE9BQU9ELEdBQUdZLE1BQU1DO1FBQ2xCLEdBQ0E7WUFBQ3JCO1NBQVE7UUFFWCxNQUFNTSxRQUFRUixVQUFVTyxpQkFBaUJFO1FBQ3pDLElBQUlELFVBQVVRLFdBQVc7WUFDdkIsTUFBTSxJQUFJeFcsTUFDUixDQUFDLHNDQUFzQyxFQUFFOFUsYUFBYSxPQUFPLENBQUM7UUFFbEU7UUFDQSxPQUFPa0I7SUFDVDtJQUNBLFNBQVNnQjtRQUNQLE1BQU1wUixPQUFPbVA7UUFDYixPQUFPNVYsOENBQWtCLENBQ3ZCLENBQUM4WCxPQUFPek4sV0FBVztZQUFFME4sNEJBQTRCO1FBQU0sQ0FBQztZQUN0RHRSLEtBQUt1UixjQUFjLENBQUNGLE9BQU96TjtRQUM3QixHQUNBO1lBQUM1RDtTQUFLO0lBRVY7SUFDQSxTQUFTd1Isa0JBQWtCM0ksUUFBUTtRQUNqQyxNQUFNN0ksT0FBT21QO1FBQ2IsTUFBTXNDLGdCQUFnQnpHLFVBQVVuQztRQUNoQ3RQLDRDQUFnQixDQUNkLElBQU15RyxLQUFLd0IsTUFBTSxDQUFDaUwsTUFBTSxDQUFDblIsU0FBUyxDQUFDLENBQUMrVixRQUFVSSxjQUFjdFYsT0FBTyxDQUFDa1YsU0FDcEU7WUFBQ3JSO1lBQU15UjtTQUFjO0lBRXpCO0lBQ0EsU0FBU0MsMEJBQTBCN0ksUUFBUTtRQUN6QyxNQUFNN0ksT0FBT21QO1FBQ2IsTUFBTXNDLGdCQUFnQnpHLFVBQVVuQztRQUNoQ3RQLDRDQUFnQixDQUNkLElBQU15RyxLQUFLd0IsTUFBTSxDQUFDbVEsY0FBYyxDQUFDclcsU0FBUyxDQUN4QyxDQUFDK1YsUUFBVUksY0FBY3RWLE9BQU8sQ0FBQ2tWLFNBRW5DO1lBQUNyUjtZQUFNeVI7U0FBYztJQUV6QjtJQUNBLFNBQVNHLGlCQUFpQi9JLFFBQVE7UUFDaEMsTUFBTTdJLE9BQU9tUDtRQUNiLE1BQU1zQyxnQkFBZ0J6RyxVQUFVbkM7UUFDaEN0UCw0Q0FBZ0IsQ0FDZCxJQUFNeUcsS0FBS3dCLE1BQU0sQ0FBQ3RDLEtBQUssQ0FBQzVELFNBQVMsQ0FBQyxDQUFDdVcsSUFBTUosY0FBY3RWLE9BQU8sQ0FBQzBWLEtBQy9EO1lBQUM3UjtZQUFNeVI7U0FBYztJQUV6QjtJQUNBLFNBQVNLLGlCQUFpQmpKLFFBQVE7UUFDaEMsTUFBTTdJLE9BQU9tUDtRQUNiLE1BQU1zQyxnQkFBZ0J6RyxVQUFVbkM7UUFDaEN0UCw0Q0FBZ0IsQ0FBQztZQUNmLE1BQU13WSxXQUFXLENBQUNDO2dCQUNoQlAsY0FBY3RWLE9BQU8sQ0FBQzZWO1lBQ3hCO1lBQ0EsT0FBT2hTLEtBQUt3QixNQUFNLENBQUN5USxXQUFXLENBQUMzVyxTQUFTLENBQUN5VztRQUMzQyxHQUFHO1lBQUMvUjtZQUFNeVI7U0FBYztJQUMxQjtJQUNBLFNBQVNTLFFBQVFDLGFBQWEsRUFBRXJDLE9BQU87UUFDckMsTUFBTTlQLE9BQU9tUDtRQUNiLE1BQU1sVCxhQUFhK0QsS0FBS3dCLE1BQU0sQ0FBQ3VGLElBQUksQ0FBQ3pMLFNBQVM7UUFDN0MsTUFBTWdCLGVBQWUwRCxLQUFLZ0gsT0FBTztRQUNqQyxNQUFNNkksV0FBV3NDLGlCQUFpQjVHO1FBQ2xDLE1BQU00RSxrQkFBa0I1Vyw4Q0FBa0IsQ0FDeEMsQ0FBQzZZLEtBQU9BLE9BQU8sT0FBT3ZDLFNBQVN1QyxNQUFNLE1BQ3JDO1lBQUN2QztTQUFTO1FBRVosTUFBTVIsb0JBQW9CbEQ7UUFDMUIsT0FBTzFTLCtHQUFpQ0EsQ0FDdEN3QyxZQUNBSyxjQUNBK1MsbUJBQ0FjLGlCQUNBTDtJQUVKO0lBQ0EsU0FBU3VDO1FBQ1AsTUFBTXJTLE9BQU9tUDtRQUNiLE1BQU1sVCxhQUFhK0QsS0FBS3dCLE1BQU0sQ0FBQzhRLGNBQWMsQ0FBQzNILGFBQWE7UUFDM0QsTUFBTXJPLGVBQWUwRCxLQUFLd00sa0JBQWtCO1FBQzVDLE1BQU02QyxvQkFBb0JsRDtRQUMxQixPQUFPNUssc0JBQXNCdEYsWUFBWUssY0FBYytTO0lBQ3pEO0lBQ0EsU0FBU2tEO1FBQ1AsT0FBTztZQUFDRjtTQUF3QjtJQUNsQztJQUNBLFNBQVNHO1FBQ1AsT0FBT3JELFVBQVVzRCxPQUFPO0lBQzFCO0lBQ0EsU0FBU0M7UUFDUCxPQUFPRixhQUFhRyxJQUFJO0lBQzFCO0lBQ0EsU0FBU0M7UUFDUCxPQUFPSixhQUFhSyxJQUFJO0lBQzFCO0lBQ0EsU0FBU0M7UUFDUCxNQUFNOVMsT0FBT21QO1FBQ2IsTUFBTWxULGFBQWErRCxLQUFLd0IsTUFBTSxDQUFDaVIsT0FBTyxDQUFDblgsU0FBUztRQUNoRCxNQUFNeVgsVUFBVS9TLEtBQUt5UyxPQUFPLENBQUNNLE9BQU87UUFDcEMsT0FBT3hSLHNCQUFzQnRGLFlBQVk4VyxTQUFTQTtJQUNwRDtJQUNBLFNBQVNDO1FBQ1AsTUFBTWhULE9BQU9tUDtRQUNiLE1BQU1sVCxhQUFhK0QsS0FBS3dCLE1BQU0sQ0FBQ2lSLE9BQU8sQ0FBQ25YLFNBQVM7UUFDaEQsTUFBTTJYLFVBQVVqVCxLQUFLeVMsT0FBTyxDQUFDUSxPQUFPO1FBQ3BDLE9BQU8xUixzQkFBc0J0RixZQUFZZ1gsU0FBU0E7SUFDcEQ7SUFDQSxTQUFTQztRQUNQLE9BQU8vRCxVQUFVZ0UsS0FBSztJQUN4QjtJQUNBLFNBQVNDLGFBQWE5UyxHQUFHO1FBQ3ZCLE1BQU1OLE9BQU9tUDtRQUNiLE1BQU1rRSxhQUFhaEI7UUFDbkIsTUFBTWlCLFdBQVduSTtRQUNqQjVSLDRDQUFnQixDQUFDO1lBQ2YsSUFBSThaLGVBQWUsTUFBTTtnQkFDdkI7WUFDRjtZQUNBLE1BQU1FLE9BQU9GO1lBQ2IsSUFBSUc7WUFDSixJQUFJckMsT0FBT29DLEtBQUt6TCxHQUFHLENBQUN4SDtZQUNwQixTQUFTbVQ7Z0JBQ1BELFlBQVl0YSw0REFBVUEsQ0FBQ2lZLFFBQVFuUixLQUFLMUUsU0FBUyxDQUFDNlYsTUFBTW1DLFlBQVksS0FBSztZQUN2RTtZQUNBLFNBQVNJO2dCQUNQLE1BQU1DLFdBQVdKLEtBQUt6TCxHQUFHLENBQUN4SDtnQkFDMUIsSUFBSXFULGFBQWF4QyxNQUFNO29CQUNyQnFDO29CQUNBckMsT0FBT3dDO29CQUNQRjtvQkFDQUg7Z0JBQ0Y7WUFDRjtZQUNBRztZQUNBSDtZQUNBLE1BQU1NLGtCQUFrQjVULEtBQUsxRSxTQUFTLENBQUNpWSxNQUFNRztZQUM3QyxPQUFPO2dCQUNMRTtnQkFDQUo7WUFDRjtRQUNGLEdBQUc7WUFBQ0g7WUFBWXJUO1lBQU1NO1lBQUtnVDtTQUFTO1FBQ3BDLElBQUlELGVBQWUsTUFBTTtZQUN2QixPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU9BLFdBQVd2TCxHQUFHLENBQUN4SDtRQUN4QjtJQUNGO0lBQ0EsU0FBU3VULFdBQVdoRSxRQUFRLEVBQUVDLE9BQU87UUFDbkMsTUFBTTlQLE9BQU9tUDtRQUNiLE1BQU1rRSxhQUFhaEI7UUFDbkIsTUFBTWxDLGtCQUFrQjVXLDhDQUFrQixDQUN4QyxDQUFDdWEsY0FBZ0JBLGdCQUFnQixPQUFPakUsU0FBU2lFLGVBQWUsTUFDaEU7WUFBQ2pFO1NBQVM7UUFFWixNQUFNNVQsYUFBYTFDLDhDQUFrQixDQUNuQyxDQUFDaUMsZ0JBQWtCNlgsZUFBZSxPQUFPclQsS0FBSzFFLFNBQVMsQ0FBQytYLFlBQVk3WCxlQUFlO2dCQUFFdVksUUFBUTtZQUFLLEtBQUt6SSxPQUN2RztZQUFDdEw7WUFBTXFUO1NBQVc7UUFFcEIsTUFBTS9XLGVBQWUvQyw4Q0FBa0IsQ0FBQztZQUN0QyxJQUFJOFosZUFBZSxNQUFNO2dCQUN2QixPQUFPO1lBQ1QsT0FBTztnQkFDTCxNQUFNRSxPQUFPRjtnQkFDYixNQUFNVyxNQUFNVCxLQUFLVSxXQUFXO2dCQUM1QixPQUFPRDtZQUNUO1FBQ0YsR0FBRztZQUFDWDtTQUFXO1FBQ2YsTUFBTWhFLG9CQUFvQmxEO1FBQzFCLE9BQU8xUywrR0FBaUNBLENBQ3RDd0MsWUFDQUssY0FDQStTLG1CQUNBYyxpQkFDQUw7SUFFSjtJQUNBLFNBQVNvRTtRQUNQLElBQUksSUFBNkIsRUFBRTtZQUNqQyxNQUFNLElBQUk5WixNQUNSO1FBRUo7SUFDRjtJQUNBLFNBQVMrWjtRQUNQLE1BQU1uVSxPQUFPbVA7UUFDYixJQUFJblAsS0FBS3dNLGtCQUFrQixPQUFPLE1BQU07WUFDdEM7UUFDRjtRQUNBMEg7UUFDQSxNQUFNLElBQUlyVCxRQUFRLENBQUN1VDtZQUNqQnBVLEtBQUt3QixNQUFNLENBQUM4USxjQUFjLENBQUMzSCxhQUFhLENBQUMsSUFBTXlKO1FBQ2pEO0lBQ0Y7SUFDQSxTQUFTQztRQUNQLE1BQU1yVSxPQUFPbVA7UUFDYixJQUFJblAsS0FBS2dILE9BQU8sT0FBTyxNQUFNO1lBQzNCO1FBQ0Y7UUFDQWtOO1FBQ0EsTUFBTSxJQUFJclQsUUFBUSxDQUFDdVQ7WUFDakJwVSxLQUFLd0IsTUFBTSxDQUFDdUYsSUFBSSxDQUFDNEQsYUFBYSxDQUFDLElBQU15SjtZQUNyQ3BVLEtBQUt3QixNQUFNLENBQUNGLE1BQU0sQ0FBQ3FKLGFBQWEsQ0FBQyxJQUFNeUo7UUFDekM7SUFDRjtJQUNBLFNBQVNFLFlBQVl6TCxRQUFRLEVBQUUwTCxJQUFJO1FBQ2pDLE1BQU12VSxPQUFPbVA7UUFDYixPQUFPNVYsMENBQWMsQ0FDbkI7WUFDRSxPQUFPLENBQUMsR0FBR2liLE9BQ1QsK0RBQStEO2dCQUMvRHhVLEtBQUttVCxLQUFLLENBQ1IsSUFDRSwrREFBK0Q7b0JBQy9EdEssU0FDRXVELG9CQUFvQnBNLFVBQ2pCd1U7UUFLYixHQUNBLHVEQUF1RDtRQUN2RDtZQUFDeFU7ZUFBU3VVO1NBQUs7SUFFbkI7SUFDQSxTQUFTRSxtQkFBbUI1RSxRQUFRLEVBQUVDLE9BQU87UUFDM0NxRTtRQUNBLE9BQU9OLFdBQ0xoRSxVQUNBQztJQUVKO0lBQ0EsU0FBUzRFLGdCQUFnQjdFLFFBQVEsRUFBRUMsT0FBTztRQUN4Q3VFO1FBQ0EsT0FBT25DLFFBQ0xyQyxVQUNBQztJQUVKO0lBQ0EsU0FBUzZFLGtCQUFrQjlFLFFBQVEsRUFBRUMsT0FBTztRQUMxQ3VFO1FBQ0EsT0FBT3pFLFVBQ0xDLFVBQ0FDO0lBRUo7SUFDQSxTQUFTOEU7UUFDUFA7UUFDQSxPQUFPdEU7SUFDVDtJQUNBLFNBQVM4RSx3QkFBd0I1RSxZQUFZLEVBQUVDLFdBQVc7UUFDeERtRTtRQUNBLE9BQU9yRSxnQkFBZ0JDLGNBQWNDO0lBQ3ZDO0lBQ0EsU0FBUzRFLGlCQUFpQjVGLFlBQVksRUFBRVcsUUFBUSxFQUFFQyxPQUFPO1FBQ3ZEdUU7UUFDQSxPQUFPdkQsU0FBUzVCLGNBQWNXLFVBQVVDO0lBQzFDO0lBQ0EsU0FBU2lGLHFCQUFxQnpVLEdBQUc7UUFDL0I2VDtRQUNBLE9BQU9mLGFBQWE5UztJQUN0QjtJQUNBLFNBQVMyQyxXQUFXVyxRQUFRO1FBQzFCLE1BQU01RCxPQUFPbVA7UUFDYixPQUFPMUIsYUFBYXhLLFVBQVUsQ0FBQ2pELE1BQU00RDtJQUN2QztJQUNBLFNBQVNKLG1CQUFtQkksUUFBUTtRQUNsQyxNQUFNNUQsT0FBT21QO1FBQ2IsT0FBTzFCLGFBQWFqSyxrQkFBa0IsQ0FBQ3hELE1BQU00RDtJQUMvQztJQUNBLFNBQVNVO1FBQ1AsTUFBTXRFLE9BQU9tUDtRQUNiLE9BQU8xQixhQUFhbkosZUFBZSxDQUFDdEU7SUFDdEM7SUFDQSxTQUFTK0Q7UUFDUCxNQUFNL0QsT0FBT21QO1FBQ2IsT0FBTzFCLGFBQWExSixxQkFBcUIsQ0FBQy9EO0lBQzVDO0lBQ0EsU0FBU2lHO1FBQ1AsTUFBTWpHLE9BQU9tUDtRQUNiLE9BQU8xQixhQUFheEgsY0FBYyxDQUFDakc7SUFDckM7SUFDQSxTQUFTc0c7UUFDUCxNQUFNdEcsT0FBT21QO1FBQ2IsT0FBTzFCLGFBQWFuSCxpQkFBaUIsQ0FBQ3RHO0lBQ3hDO0lBQ0EsU0FBU3FGO1FBQ1AsTUFBTXJGLE9BQU9tUDtRQUNiLE9BQU8xQixhQUFhcEksZ0JBQWdCLENBQUNyRjtJQUN2QztJQUNBLFNBQVN3RjtRQUNQLE1BQU14RixPQUFPbVA7UUFDYixPQUFPMUIsYUFBYWpJLGNBQWMsQ0FBQ3hGO0lBQ3JDO0lBQ0EsU0FBUzJGO1FBQ1AsTUFBTTNGLE9BQU9tUDtRQUNiLE9BQU8xQixhQUFhOUgsZ0JBQWdCLENBQUMzRjtJQUN2QztJQUNBLE1BQU0sRUFBRWdWLFlBQVksRUFBRUMseUJBQXlCLEVBQUUsR0FBR2xZLFdBQVcsQ0FBQztJQUNoRSxNQUFNZ1EsYUFBYWlJLGVBQWVqYyxrRUFBZ0JBLENBQUMsT0FBT21jO1FBQ3hELE1BQU05TyxRQUFRLE1BQU00TyxhQUNsQnRKLEtBQUt5SixLQUFLLENBQUNEO1FBRWIsT0FBTzlPLE9BQU8sQ0FBQyxFQUFFO0lBQ25CLEtBQUssS0FBSztJQUNWLFNBQVNnUCxRQUFRblEsTUFBTTtRQUNyQixNQUFNakYsT0FBT21QO1FBQ2IsTUFBTWtHLGNBQWM5YiwwQ0FBYyxDQUNoQyxJQUFNRCwyREFBVUEsQ0FBQztnQkFBRWdjLFNBQVM7b0JBQUNyUTtpQkFBTztnQkFBRW5CLFFBQVE5RCxLQUFLRSxFQUFFO1lBQUMsSUFDdEQ7WUFBQytFO1lBQVFqRixLQUFLRSxFQUFFO1NBQUM7UUFFbkIsTUFBTXdELFFBQVF3RyxjQUFjNkMsWUFBWXNJO1FBQ3hDOWIsNENBQWdCLENBQUMsSUFBTXVULHFCQUFxQkMsYUFBYSxFQUFFO1FBQzNELElBQUlySixNQUFNRCxTQUFTLEVBQUU7WUFDbkIsT0FBTztnQkFDTEEsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE9BQU87Z0JBQ0xnRCxNQUFNL0MsTUFBTTlFLElBQUk7Z0JBQ2hCTSxPQUFPd0UsTUFBTXhFLEtBQUs7Z0JBQ2xCdUUsV0FBVztZQUNiO1FBQ0Y7SUFDRjtJQUNBLFNBQVM4UixnQkFBZ0J0USxNQUFNO1FBQzdCLE1BQU1qRixPQUFPbVA7UUFDYixNQUFNa0csY0FBYzliLDBDQUFjLENBQ2hDLElBQU1ELDJEQUFVQSxDQUFDO2dCQUFFZ2MsU0FBUztvQkFBQ3JRO2lCQUFPO2dCQUFFbkIsUUFBUTlELEtBQUtFLEVBQUU7WUFBQyxJQUN0RDtZQUFDK0U7WUFBUWpGLEtBQUtFLEVBQUU7U0FBQztRQUVuQixNQUFNd0QsUUFBUXdHLGNBQWM2QyxZQUFZc0ksYUFBYTtZQUNuRDVLLFVBQVU7UUFDWjtRQUNBbFIsNENBQWdCLENBQUMsSUFBTXVULHFCQUFxQkMsYUFBYSxFQUFFO1FBQzNELE9BQU87WUFDTHRHLE1BQU0vQyxNQUFNOUUsSUFBSTtZQUNoQjZFLFdBQVc7UUFDYjtJQUNGO0lBQ0EsTUFBTStSLDBCQUEwQnpjLGtFQUFnQkEsQ0FDOUNrYyw0QkFBNEIsQ0FBQ0M7UUFDM0IsT0FBT0QsMEJBQ0x2SixLQUFLeUosS0FBSyxDQUFDRDtJQUVmLElBQUksSUFBTXJVLFFBQVE2SixPQUFPLENBQUMsRUFBRTtJQUU5QixTQUFTK0ssc0JBQXNCQyxNQUFNO1FBQ25DLE1BQU0xVixPQUFPbVA7UUFDYixNQUFNd0csa0JBQWtCdE0sWUFBWXFNLFFBQVE7UUFDNUMsTUFBTUwsY0FBYzliLDBDQUFjLENBQ2hDLElBQU1vYyxvQkFBb0IsS0FBSyxJQUFJcmMsMkRBQVVBLENBQUM7Z0JBQUVzYyxNQUFNRDtnQkFBaUI3UixRQUFROUQsS0FBS0UsRUFBRTtZQUFDLEtBQUssTUFDNUY7WUFBQ3lWO1lBQWlCM1YsS0FBS0UsRUFBRTtTQUFDO1FBRTVCLE1BQU0sRUFBRXRCLElBQUksRUFBRSxHQUFHc0wsY0FBY3NMLHlCQUF5QkgsYUFBYTtZQUNuRXhLLDhCQUE4QjtRQUNoQztRQUNBLE9BQU9qTTtJQUNUO0lBQ0EsTUFBTXdPLFNBQVM7UUFDYkc7UUFDQXNJLGNBQWNuSTtRQUNkeUI7UUFDQUM7UUFDQThEO1FBQ0E5QjtRQUNBSTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBVTtRQUNBRTtRQUNBRTtRQUNBSTtRQUNBRjtRQUNBLDZFQUE2RTtRQUM3RWdELFNBQVMxQztRQUNUMkMsUUFBUTNDO1FBQ1I0QyxXQUFXNUM7UUFDWGI7UUFDQXNCO1FBQ0EzQjtRQUNBNUM7UUFDQUs7UUFDQUM7UUFDQUk7UUFDQUQ7UUFDQWU7UUFDQXdEO1FBQ0FyUjtRQUNBbVM7UUFDQTlRO1FBQ0FQO1FBQ0FzQjtRQUNBRztRQUNBRztRQUNBTTtRQUNBSztRQUNBbUUsVUFBVTtZQUNSOEM7WUFDQXNJLGNBQWNuSTtZQUNkeUI7WUFDQUM7WUFDQThEO1lBQ0E5QjtZQUNBSTtZQUNBRTtZQUNBRTtZQUNBRTtZQUNBVTtZQUNBRTtZQUNBRTtZQUNBSTtZQUNBRjtZQUNBLGVBQWU7WUFDZmdELFNBQVNmO1lBQ1RnQixRQUFRaEI7WUFDUmlCLFdBQVdqQjtZQUNYeEM7WUFDQXNCLFlBQVlZO1lBQ1p2QyxTQUFTd0M7WUFDVHBGO1lBQ0FLO1lBQ0FDLFdBQVcrRTtZQUNYM0UsaUJBQWlCNkU7WUFDakI5RSx3QkFBd0I2RTtZQUN4QjlELFVBQVVnRTtZQUNWUjtZQUNBclIsWUFBWU87WUFDWjRSLFNBQVNHO1lBQ1RqUjtZQUNBUDtZQUNBc0I7WUFDQUc7WUFDQUc7WUFDQU07WUFDQUs7UUFDRjtJQUNGO0lBQ0EsTUFBTTBJLGlCQUFpQjtRQUNyQixHQUFHNUIsTUFBTTtRQUNUNkksOEJBQThCaEIsOEJBQThCLEtBQUs7UUFDakVRO0lBQ0Y7SUFDQSxPQUFPckk7QUFDVDtBQUVBLGVBQWU7QUFDMEM7QUFDekRyViw2REFBV0EsQ0FBQ0MsVUFBVUMsYUFBYUM7QUFNakMsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNpZ24tZW5naW5lZXIvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanM/Y2QzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBkZXRlY3REdXBlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjEuOS43XCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9DbGllbnRTaWRlU3VzcGVuc2UudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIENsaWVudFNpZGVTdXNwZW5zZShwcm9wcykge1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHsgZmFsbGJhY2s6IHByb3BzLmZhbGxiYWNrIH0sIG1vdW50ZWQgPyBwcm9wcy5jaGlsZHJlbigpIDogcHJvcHMuZmFsbGJhY2spO1xufVxuXG4vLyBzcmMvZmFjdG9yeS50c3hcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBjcmVhdGVBc3luY0NhY2hlLFxuICBkZXByZWNhdGVJZixcbiAgZXJyb3JJZixcbiAgaXNMaXZlTm9kZSxcbiAgbWFrZUV2ZW50U291cmNlIGFzIG1ha2VFdmVudFNvdXJjZTIsXG4gIHN0cmluZ2lmeSBhcyBzdHJpbmdpZnkyXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgKiBhcyBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9Db21tZW50c1Jvb20udHN4XG5pbXBvcnQgeyBDb21tZW50c0FwaUVycm9yLCBtYWtlRXZlbnRTb3VyY2UsIHN0cmluZ2lmeSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tIFwibmFub2lkXCI7XG5pbXBvcnQgUmVhY3QyLCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsXG4gIHVzZU1lbW9cbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanNcIjtcblxuLy8gc3JjL2NvbW1lbnRzL2Vycm9ycy50c1xudmFyIENyZWF0ZVRocmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgdGhyZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDcmVhdGVUaHJlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJFZGl0IHRocmVhZCBtZXRhZGF0YSBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdFRocmVhZE1ldGFkYXRhRXJyb3JcIjtcbiAgfVxufTtcbnZhciBDcmVhdGVDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkNyZWF0ZSBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDcmVhdGVDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0Q29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJFZGl0IGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBEZWxldGVDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkRlbGV0ZSBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJEZWxldGVDb21tZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBBZGRSZWFjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJBZGQgcmVhY3Rpb24gZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkFkZFJlYWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBSZW1vdmVSZWFjdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJSZW1vdmUgcmVhY3Rpb24gZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIlJlbW92ZVJlYWN0aW9uRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9yZXZhbGlkYXRpb24udHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiBhcyB1c2VSZWYyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21tZW50cy9saWIvdXNlLWlzLWRvY3VtZW50LXZpc2libGUudHNcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcbmZ1bmN0aW9uIHVzZUlzRG9jdW1lbnRWaXNpYmxlKCkge1xuICBjb25zdCBpc1Zpc2libGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gIHJldHVybiBpc1Zpc2libGU7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUob25TdG9yZUNoYW5nZSkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblN0b3JlQ2hhbmdlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblN0b3JlQ2hhbmdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBzaG90KCkge1xuICBjb25zdCBpc0RvY3VtZW50RGVmaW5lZCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgcmV0dXJuIGlzRG9jdW1lbnREZWZpbmVkID8gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIiA6IHRydWU7XG59XG5cbi8vIHNyYy9jb21tZW50cy9saWIvdXNlLWlzLW9ubGluZS50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcbmZ1bmN0aW9uIHVzZUlzT25saW5lKCkge1xuICBjb25zdCBpc09ubGluZVJlZiA9IHVzZVJlZih0cnVlKTtcbiAgY29uc3Qgc3Vic2NyaWJlMiA9IHVzZUNhbGxiYWNrKChvblN0b3JlQ2hhbmdlKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICBpc09ubGluZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG9uU3RvcmVDaGFuZ2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPZmZsaW5lKCkge1xuICAgICAgaXNPbmxpbmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgb25TdG9yZUNoYW5nZSgpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZUlzT2ZmbGluZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVJc09mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0U25hcHNob3QyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBpc09ubGluZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IGlzT25saW5lID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZTIsIGdldFNuYXBzaG90MiwgZ2V0U25hcHNob3QyKTtcbiAgcmV0dXJuIGlzT25saW5lO1xufVxuXG4vLyBzcmMvY29tbWVudHMvbGliL3JldmFsaWRhdGlvbi50c1xudmFyIERFRkFVTFRfRVJST1JfUkVUUllfSU5URVJWQUwgPSA1ZTM7XG52YXIgREVGQVVMVF9NQVhfRVJST1JfUkVUUllfQ09VTlQgPSA1O1xudmFyIERFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwgPSAyZTM7XG52YXIgdGltZXN0YW1wID0gMDtcbmZ1bmN0aW9uIHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaXNPbmxpbmVSZWYgPSB1c2VSZWYyKHRydWUpO1xuICBjb25zdCB7XG4gICAgZGVkdXBpbmdJbnRlcnZhbCA9IERFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwsXG4gICAgZXJyb3JSZXRyeUludGVydmFsID0gREVGQVVMVF9FUlJPUl9SRVRSWV9JTlRFUlZBTCxcbiAgICBlcnJvclJldHJ5Q291bnQgPSBERUZBVUxUX01BWF9FUlJPUl9SRVRSWV9DT1VOVFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgX3JldmFsaWRhdGVDYWNoZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAoe1xuICAgICAgc2hvdWxkRGVkdXBlLFxuICAgICAgcmV0cnlDb3VudCA9IDBcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhcnRBdDtcbiAgICAgIGNvbnN0IHNob3VsZFN0YXJ0UmVxdWVzdCA9ICFtYW5hZ2VyLmdldFJlcXVlc3QoKSB8fCAhc2hvdWxkRGVkdXBlO1xuICAgICAgZnVuY3Rpb24gZGVsZXRlQWN0aXZlUmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlUmVxdWVzdCA9IG1hbmFnZXIuZ2V0UmVxdWVzdCgpO1xuICAgICAgICBpZiAoIWFjdGl2ZVJlcXVlc3QpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdC50aW1lc3RhbXAgIT09IHN0YXJ0QXQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VyLnNldFJlcXVlc3Qodm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKHJldHJ5Q291bnQgPCA4ID8gcmV0cnlDb3VudCA6IDgpKSkgKiBlcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgICAgIGlmIChyZXRyeUNvdW50ID4gZXJyb3JSZXRyeUNvdW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdm9pZCBfcmV2YWxpZGF0ZUNhY2hlKHtcbiAgICAgICAgICAgIHNob3VsZERlZHVwZTogZmFsc2UsXG4gICAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRTdGFydFJlcXVlc3QpIHtcbiAgICAgICAgbWFuYWdlci5zZXRSZXF1ZXN0KHtcbiAgICAgICAgICBmZXRjaGVyOiBmZXRjaGVyKCksXG4gICAgICAgICAgdGltZXN0YW1wOiArK3RpbWVzdGFtcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBhY3RpdmVSZXF1ZXN0ID0gbWFuYWdlci5nZXRSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghYWN0aXZlUmVxdWVzdClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXJ0QXQgPSBhY3RpdmVSZXF1ZXN0LnRpbWVzdGFtcDtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IGF3YWl0IGFjdGl2ZVJlcXVlc3QuZmV0Y2hlcjtcbiAgICAgICAgaWYgKHNob3VsZFN0YXJ0UmVxdWVzdCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZGVsZXRlQWN0aXZlUmVxdWVzdCwgZGVkdXBpbmdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUmVxdWVzdCA9IG1hbmFnZXIuZ2V0UmVxdWVzdCgpO1xuICAgICAgICBpZiAoIWFjdGl2ZVJlcXVlc3QgfHwgYWN0aXZlUmVxdWVzdC50aW1lc3RhbXAgIT09IHN0YXJ0QXQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhY3RpdmVNdXRhdGlvbiA9IG1hbmFnZXIuZ2V0TXV0YXRpb24oKTtcbiAgICAgICAgaWYgKGFjdGl2ZU11dGF0aW9uICYmIChhY3RpdmVNdXRhdGlvbi5zdGFydFRpbWUgPiBzdGFydEF0IHx8IGFjdGl2ZU11dGF0aW9uLmVuZFRpbWUgPiBzdGFydEF0IHx8IGFjdGl2ZU11dGF0aW9uLmVuZFRpbWUgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hbmFnZXIuc2V0Q2FjaGUobmV3RGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVsZXRlQWN0aXZlUmVxdWVzdCgpO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiO1xuICAgICAgICBjb25zdCBpc09ubGluZSA9IGlzT25saW5lUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChzaG91bGRTdGFydFJlcXVlc3QgJiYgaXNWaXNpYmxlICYmIGlzT25saW5lKVxuICAgICAgICAgIGhhbmRsZUVycm9yKCk7XG4gICAgICAgIG1hbmFnZXIuc2V0RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIFttYW5hZ2VyLCBmZXRjaGVyLCBkZWR1cGluZ0ludGVydmFsLCBlcnJvclJldHJ5SW50ZXJ2YWwsIGVycm9yUmV0cnlDb3VudF1cbiAgKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICBpc09ubGluZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSXNPZmZsaW5lKCkge1xuICAgICAgaXNPbmxpbmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZUlzT2ZmbGluZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZUlzT25saW5lKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVJc09mZmxpbmUpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmV2YWxpZGF0ZUNhY2hlID0gdXNlQ2FsbGJhY2syKFxuICAgICh7IHNob3VsZERlZHVwZSB9KSA9PiB7XG4gICAgICByZXR1cm4gX3JldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZSwgcmV0cnlDb3VudDogMCB9KTtcbiAgICB9LFxuICAgIFtfcmV2YWxpZGF0ZUNhY2hlXVxuICApO1xuICByZXR1cm4gcmV2YWxpZGF0ZUNhY2hlO1xufVxuZnVuY3Rpb24gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGVDYWNoZSkge1xuICBjb25zdCBtdXRhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJlZm9yZU11dGF0aW9uVGltZXN0YW1wID0gKyt0aW1lc3RhbXA7XG4gICAgICBtYW5hZ2VyLnNldE11dGF0aW9uKHtcbiAgICAgICAgc3RhcnRUaW1lOiBiZWZvcmVNdXRhdGlvblRpbWVzdGFtcCxcbiAgICAgICAgZW5kVGltZTogMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBjdXJyZW50Q2FjaGUgPSBtYW5hZ2VyLmdldENhY2hlKCk7XG4gICAgICBtYW5hZ2VyLnNldENhY2hlKG9wdGlvbnMub3B0aW1pc3RpY0RhdGEpO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGF0YTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGl2ZU11dGF0aW9uID0gbWFuYWdlci5nZXRNdXRhdGlvbigpO1xuICAgICAgaWYgKGFjdGl2ZU11dGF0aW9uICYmIGJlZm9yZU11dGF0aW9uVGltZXN0YW1wICE9PSBhY3RpdmVNdXRhdGlvbi5zdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbWFuYWdlci5zZXRDYWNoZShjdXJyZW50Q2FjaGUpO1xuICAgICAgfVxuICAgICAgbWFuYWdlci5zZXRNdXRhdGlvbih7XG4gICAgICAgIHN0YXJ0VGltZTogYmVmb3JlTXV0YXRpb25UaW1lc3RhbXAsXG4gICAgICAgIGVuZFRpbWU6ICsrdGltZXN0YW1wXG4gICAgICB9KTtcbiAgICAgIG1hbmFnZXIuc2V0UmVxdWVzdCh2b2lkIDApO1xuICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IGZhbHNlIH0pO1xuICAgICAgaWYgKGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9LFxuICAgIFttYW5hZ2VyLCByZXZhbGlkYXRlQ2FjaGVdXG4gICk7XG4gIHJldHVybiBtdXRhdGU7XG59XG5cbi8vIHNyYy9jb21tZW50cy9Db21tZW50c1Jvb20udHN4XG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBQT0xMSU5HX0lOVEVSVkFMX1JFQUxUSU1FID0gM2U0O1xudmFyIFBPTExJTkdfSU5URVJWQUwgPSA1ZTM7XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50c1Jvb20oZXJyb3JFdmVudFNvdXJjZSkge1xuICBjb25zdCBzdG9yZSA9IGNyZWF0ZUNsaWVudENhY2hlU3RvcmUoKTtcbiAgY29uc3QgRmV0Y2hlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuICBjb25zdCBSb29tTWFuYWdlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuICBmdW5jdGlvbiBnZXRUaHJlYWRzKG1hbmFnZXIpIHtcbiAgICBjb25zdCB0aHJlYWRzID0gbWFuYWdlci5nZXRDYWNoZSgpO1xuICAgIGlmICghdGhyZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCB1cGRhdGUgdGhyZWFkcyBvciBjb21tZW50cyBiZWZvcmUgdGhleSBhcmUgbG9hZGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhyZWFkcztcbiAgfVxuICBmdW5jdGlvbiBDb21tZW50c1Jvb21Qcm92aWRlcih7XG4gICAgcm9vbSxcbiAgICBjaGlsZHJlblxuICB9KSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJvb21SZXZhbGlkYXRpb25NYW5hZ2VyKHJvb20uaWQsIHtcbiAgICAgICAgZ2V0Q2FjaGU6IHN0b3JlLmdldFRocmVhZHMsXG4gICAgICAgIHNldENhY2hlOiBzdG9yZS5zZXRUaHJlYWRzXG4gICAgICB9KTtcbiAgICB9LCBbcm9vbS5pZF0pO1xuICAgIGNvbnN0IGZldGNoZXIgPSBSZWFjdDIudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IG1hbmFnZXIuZ2V0UmV2YWxpZGF0aW9uTWFuYWdlcnMoKS5maWx0ZXIoKFtrZXldKSA9PiBtYW5hZ2VyLmdldFJlZmVyZW5jZUNvdW50KGtleSkgPiAwKS5tYXAoKFtfLCBtYW5hZ2VyMl0pID0+IG1hbmFnZXIyLmdldE9wdGlvbnMoKSk7XG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgb3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCByb29tLmdldFRocmVhZHMob3B0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCB0aHJlYWRzID0gQXJyYXkuZnJvbShcbiAgICAgICAgbmV3IE1hcChyZXNwb25zZXMuZmxhdCgpLm1hcCgodGhyZWFkKSA9PiBbdGhyZWFkLmlkLCB0aHJlYWRdKSkudmFsdWVzKClcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhyZWFkcztcbiAgICB9LCBbcm9vbSwgbWFuYWdlcl0pO1xuICAgIGNvbnN0IHJldmFsaWRhdGVDYWNoZSA9IHVzZVJldmFsaWRhdGVDYWNoZShtYW5hZ2VyLCBmZXRjaGVyKTtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoXG4gICAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlLFxuICAgICAgcm9vbS5nZXRTdGF0dXMsXG4gICAgICByb29tLmdldFN0YXR1c1xuICAgICk7XG4gICAgY29uc3QgaXNPbmxpbmUgPSB1c2VJc09ubGluZSgpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnRWaXNpYmxlID0gdXNlSXNEb2N1bWVudFZpc2libGUoKTtcbiAgICBjb25zdCByZWZyZXNoSW50ZXJ2YWwgPSBnZXRQb2xsaW5nSW50ZXJ2YWwoXG4gICAgICBpc09ubGluZSxcbiAgICAgIGlzRG9jdW1lbnRWaXNpYmxlLFxuICAgICAgc3RhdHVzID09PSBcImNvbm5lY3RlZFwiXG4gICAgKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIGxldCByZXZhbGlkYXRpb25UaW1lcklkO1xuICAgICAgZnVuY3Rpb24gc2NoZWR1bGVSZXZhbGlkYXRpb24oKSB7XG4gICAgICAgIGlmIChyZWZyZXNoSW50ZXJ2YWwgPT09IDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXZhbGlkYXRpb25UaW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChpc09ubGluZSAmJiBpc0RvY3VtZW50VmlzaWJsZSAmJiAhbWFuYWdlci5nZXRFcnJvcigpICYmIG1hbmFnZXIuZ2V0VG90YWxSZWZlcmVuY2VDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgdm9pZCByZXZhbGlkYXRlQ2FjaGUoeyBzaG91bGREZWR1cGU6IHRydWUgfSkudGhlbihcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXZhbGlkYXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjaGVkdWxlUmV2YWxpZGF0aW9uKCk7XG4gICAgICAgIH0sIHJlZnJlc2hJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICBzY2hlZHVsZVJldmFsaWRhdGlvbigpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyZXZhbGlkYXRpb25UaW1lcklkKTtcbiAgICAgIH07XG4gICAgfSwgW1xuICAgICAgcmV2YWxpZGF0ZUNhY2hlLFxuICAgICAgcmVmcmVzaEludGVydmFsLFxuICAgICAgaXNPbmxpbmUsXG4gICAgICBpc0RvY3VtZW50VmlzaWJsZSxcbiAgICAgIG1hbmFnZXJcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUlzT25saW5lKCkge1xuICAgICAgICBpZiAoaXNEb2N1bWVudFZpc2libGUpIHtcbiAgICAgICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgfTtcbiAgICB9LCBbcmV2YWxpZGF0ZUNhY2hlLCBpc0RvY3VtZW50VmlzaWJsZV0pO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIjtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBpc09ubGluZSkge1xuICAgICAgICAgIHZvaWQgcmV2YWxpZGF0ZUNhY2hlKHsgc2hvdWxkRGVkdXBlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsXG4gICAgICAgICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9LCBbcmV2YWxpZGF0ZUNhY2hlLCBpc09ubGluZV0pO1xuICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSByb29tLmV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogZmFsc2UgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tLCByZXZhbGlkYXRlQ2FjaGVdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KEZldGNoZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmZXRjaGVyIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb29tTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1hbmFnZXIgfSwgY2hpbGRyZW4pKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tTWFuYWdlcigpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlQ29udGV4dChSb29tTWFuYWdlckNvbnRleHQpO1xuICAgIGlmIChtYW5hZ2VyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50c1Jvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFuYWdlcjtcbiAgfVxuICBmdW5jdGlvbiBnZXRVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihvcHRpb25zLCByb29tTWFuYWdlcikge1xuICAgIGNvbnN0IGtleSA9IHN0cmluZ2lmeShvcHRpb25zKTtcbiAgICBjb25zdCByZXZhbGlkYXRpb25NYW5hZ2VyID0gcm9vbU1hbmFnZXIuZ2V0UmV2YWxpZGF0aW9uTWFuYWdlcihrZXkpO1xuICAgIGlmICghcmV2YWxpZGF0aW9uTWFuYWdlcikge1xuICAgICAgY29uc3QgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIgPSBjcmVhdGVVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlcihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcm9vbU1hbmFnZXJcbiAgICAgICk7XG4gICAgICByb29tTWFuYWdlci5zZXRSZXZhbGlkYXRpb25tYW5hZ2VyKGtleSwgdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIpO1xuICAgICAgcmV0dXJuIHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gcmV2YWxpZGF0aW9uTWFuYWdlcjtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzRmV0Y2hlcigpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlQ29udGV4dChGZXRjaGVyQ29udGV4dCk7XG4gICAgaWYgKGZldGNoZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1lbnRzUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHMocm9vbSwgb3B0aW9ucyA9IHsgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH0gfSkge1xuICAgIGNvbnN0IGtleSA9IHVzZU1lbW8oKCkgPT4gc3RyaW5naWZ5KG9wdGlvbnMpLCBbb3B0aW9uc10pO1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyID0gZ2V0VXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIoXG4gICAgICBvcHRpb25zLFxuICAgICAgbWFuYWdlclxuICAgICk7XG4gICAgY29uc3QgZmV0Y2hlciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJvb20uZ2V0VGhyZWFkcyhvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFRoZSBtaXNzaW5nIGRlcGVuZGVuY3kgaXMgYG9wdGlvbnNgIGJ1dCBga2V5YCBhbmQgYG5vcm1hbGl6ZWRgIGFyZSBhbmFsb2dvdXMsIHNvIHdlIG9ubHkgaW5jbHVkZSBga2V5YCBhcyBkZXBlbmRlbmN5LiBUaGlzIGhlbHBzIG1pbmltaXplIHRoZSBudW1iZXIgb2YgcmUtcmVuZGVycyBhcyBgb3B0aW9uc2AgY2FuIGNoYW5nZSBvbiBlYWNoIHJlbmRlclxuICAgICAgW2tleSwgcm9vbV1cbiAgICApO1xuICAgIGNvbnN0IHJldmFsaWRhdGVDYWNoZSA9IHVzZVJldmFsaWRhdGVDYWNoZShcbiAgICAgIHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyLFxuICAgICAgZmV0Y2hlclxuICAgICk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogdHJ1ZSB9KTtcbiAgICB9LCBbcmV2YWxpZGF0ZUNhY2hlXSk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBtYW5hZ2VyLmluY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBtYW5hZ2VyLmRlY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSk7XG4gICAgICB9O1xuICAgIH0sIFttYW5hZ2VyLCBrZXldKTtcbiAgICBjb25zdCBjYWNoZSA9IF91c2VUaHJlYWRzKHJvb20sIG9wdGlvbnMpO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzU3VzcGVuc2Uocm9vbSwgb3B0aW9ucyA9IHsgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH0gfSkge1xuICAgIGNvbnN0IGtleSA9IHVzZU1lbW8oKCkgPT4gc3RyaW5naWZ5KG9wdGlvbnMpLCBbb3B0aW9uc10pO1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyID0gZ2V0VXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIoXG4gICAgICBvcHRpb25zLFxuICAgICAgbWFuYWdlclxuICAgICk7XG4gICAgY29uc3QgZmV0Y2hlciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJvb20uZ2V0VGhyZWFkcyhvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFRoZSBtaXNzaW5nIGRlcGVuZGVuY3kgaXMgYG9wdGlvbnNgIGJ1dCBga2V5YCBhbmQgYG5vcm1hbGl6ZWRgIGFyZSBhbmFsb2dvdXMsIHNvIHdlIG9ubHkgaW5jbHVkZSBga2V5YCBhcyBkZXBlbmRlbmN5LiBUaGlzIGhlbHBzIG1pbmltaXplIHRoZSBudW1iZXIgb2YgcmUtcmVuZGVycyBhcyBgb3B0aW9uc2AgY2FuIGNoYW5nZSBvbiBlYWNoIHJlbmRlclxuICAgICAgW2tleSwgcm9vbV1cbiAgICApO1xuICAgIGNvbnN0IHJldmFsaWRhdGVDYWNoZSA9IHVzZVJldmFsaWRhdGVDYWNoZShcbiAgICAgIHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyLFxuICAgICAgZmV0Y2hlclxuICAgICk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICB2b2lkIHJldmFsaWRhdGVDYWNoZSh7IHNob3VsZERlZHVwZTogdHJ1ZSB9KTtcbiAgICB9LCBbcmV2YWxpZGF0ZUNhY2hlXSk7XG4gICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICBtYW5hZ2VyLmluY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBtYW5hZ2VyLmRlY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSk7XG4gICAgICB9O1xuICAgIH0sIFttYW5hZ2VyLCBrZXldKTtcbiAgICBjb25zdCBjYWNoZSA9IF91c2VUaHJlYWRzKHJvb20sIG9wdGlvbnMpO1xuICAgIGlmIChjYWNoZS5lcnJvcikge1xuICAgICAgdGhyb3cgY2FjaGUuZXJyb3I7XG4gICAgfVxuICAgIGlmIChjYWNoZS5pc0xvYWRpbmcgfHwgIWNhY2hlLnRocmVhZHMpIHtcbiAgICAgIHRocm93IHJldmFsaWRhdGVDYWNoZSh7XG4gICAgICAgIHNob3VsZERlZHVwZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdGhyZWFkczogY2FjaGUudGhyZWFkcyxcbiAgICAgIGVycm9yOiBjYWNoZS5lcnJvclxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX3VzZVRocmVhZHMocm9vbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyID0gZ2V0VXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIoXG4gICAgICBvcHRpb25zLFxuICAgICAgbWFuYWdlclxuICAgICk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgKCkgPT4gc3RvcmUuZ2V0VGhyZWFkcygpLFxuICAgICAgKCkgPT4gc3RvcmUuZ2V0VGhyZWFkcygpLFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTG9hZGluZyA9IHVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyLmdldElzTG9hZGluZygpO1xuICAgICAgICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9uczIgPSB1c2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlci5nZXRPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBzdGF0ZS5maWx0ZXIoKHRocmVhZCkgPT4ge1xuICAgICAgICAgIGlmICh0aHJlYWQucm9vbUlkICE9PSByb29tLmlkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gb3B0aW9uczIucXVlcnkgPz8ge307XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcXVlcnkubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aHJlYWQubWV0YWRhdGFba2V5XSAhPT0gcXVlcnkubWV0YWRhdGFba2V5XSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIHRocmVhZHM6IGZpbHRlcmVkLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0VGhyZWFkTWV0YWRhdGEocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGVkaXRUaHJlYWRNZXRhZGF0YSA9IHVzZUNhbGxiYWNrMyhcbiAgICAgIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9ucy50aHJlYWRJZDtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBcIm1ldGFkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWV0YWRhdGEgOiB7fTtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNEYXRhID0gdGhyZWFkcy5tYXAoXG4gICAgICAgICAgKHRocmVhZCkgPT4gdGhyZWFkLmlkID09PSB0aHJlYWRJZCA/IHtcbiAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgIC4uLnRocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDogdGhyZWFkXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShyb29tLmVkaXRUaHJlYWRNZXRhZGF0YSh7IG1ldGFkYXRhLCB0aHJlYWRJZCB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGVkaXRUaHJlYWRNZXRhZGF0YTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGNyZWF0ZVRocmVhZCA9IHVzZUNhbGxiYWNrMyhcbiAgICAgIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gXCJtZXRhZGF0YVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLm1ldGFkYXRhIDoge307XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGNyZWF0ZVRocmVhZElkKCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgbmV3Q29tbWVudCA9IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZWFjdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgICAgdHlwZTogXCJ0aHJlYWRcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgY29tbWVudHM6IFtuZXdDb21tZW50XVxuICAgICAgICB9O1xuICAgICAgICBtdXRhdGUocm9vbS5jcmVhdGVUaHJlYWQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBtZXRhZGF0YSB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhOiBbLi4udGhyZWFkcywgbmV3VGhyZWFkXVxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVDb21tZW50c0FwaUVycm9yKGVycik7XG4gICAgICAgICAgZXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoXG4gICAgICAgICAgICBuZXcgQ3JlYXRlVGhyZWFkRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1RocmVhZDtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZVRocmVhZDtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBjcmVhdGVDb21tZW50ID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHsgdGhyZWFkSWQsIGJvZHkgfSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlYWN0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0RhdGEgPSB0aHJlYWRzLm1hcChcbiAgICAgICAgICAodGhyZWFkKSA9PiB0aHJlYWQuaWQgPT09IHRocmVhZElkID8ge1xuICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgY29tbWVudHM6IFsuLi50aHJlYWQuY29tbWVudHMsIGNvbW1lbnRdXG4gICAgICAgICAgfSA6IHRocmVhZFxuICAgICAgICApO1xuICAgICAgICBtdXRhdGUocm9vbS5jcmVhdGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBDcmVhdGVDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdENvbW1lbnQocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGVkaXRDb21tZW50ID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY0RhdGEgPSB0aHJlYWRzLm1hcChcbiAgICAgICAgICAodGhyZWFkKSA9PiB0aHJlYWQuaWQgPT09IHRocmVhZElkID8ge1xuICAgICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgICAgY29tbWVudHM6IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAgICAgICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICAgICAgICBlZGl0ZWRBdDogbm93LFxuICAgICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgICAgfSA6IGNvbW1lbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IDogdGhyZWFkXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShyb29tLmVkaXRDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBFZGl0Q29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGVkaXRDb21tZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGRlbGV0ZUNvbW1lbnQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkcyA9IGdldFRocmVhZHMobWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBuZXdUaHJlYWRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdGhyZWFkIG9mIHRocmVhZHMpIHtcbiAgICAgICAgICBpZiAodGhyZWFkLmlkID09PSB0aHJlYWRJZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRzOiB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgICAgICAgICAgICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAgICAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEF0OiBub3csXG4gICAgICAgICAgICAgICAgICBib2R5OiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9IDogY29tbWVudFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG5ld1RocmVhZC5jb21tZW50cy5zb21lKFxuICAgICAgICAgICAgICAoY29tbWVudCkgPT4gY29tbWVudC5kZWxldGVkQXQgPT09IHZvaWQgMFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBuZXdUaHJlYWRzLnB1c2gobmV3VGhyZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGhyZWFkcy5wdXNoKHRocmVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG11dGF0ZShyb29tLmRlbGV0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGE6IG5ld1RocmVhZHNcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IERlbGV0ZUNvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBkZWxldGVDb21tZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKHJvb20pIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlUm9vbU1hbmFnZXIoKTtcbiAgICBjb25zdCBmZXRjaGVyID0gdXNlVGhyZWFkc0ZldGNoZXIoKTtcbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlUmV2YWxpZGF0ZUNhY2hlKG1hbmFnZXIsIGZldGNoZXIpO1xuICAgIGNvbnN0IG11dGF0ZSA9IHVzZU11dGF0ZShtYW5hZ2VyLCByZXZhbGlkYXRlKTtcbiAgICBjb25zdCBjcmVhdGVDb21tZW50ID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgICBjb25zdCB0aHJlYWRzID0gZ2V0VGhyZWFkcyhtYW5hZ2VyKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNEYXRhID0gdGhyZWFkcy5tYXAoXG4gICAgICAgICAgKHRocmVhZCkgPT4gdGhyZWFkLmlkID09PSB0aHJlYWRJZCA/IHtcbiAgICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICAgIGNvbW1lbnRzOiB0aHJlYWQuY29tbWVudHMubWFwKChjb21tZW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50LmlkICE9PSBjb21tZW50SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgcmVhY3Rpb25zO1xuICAgICAgICAgICAgICBpZiAoY29tbWVudC5yZWFjdGlvbnMuc29tZShcbiAgICAgICAgICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb25zID0gY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAgICAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICB1c2VyczogWy4uLnJlYWN0aW9uLnVzZXJzLCB7IGlkOiB1c2VySWQgfV1cbiAgICAgICAgICAgICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgICAgLi4uY29tbWVudC5yZWFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcnM6IFt7IGlkOiB1c2VySWQgfV1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICAgICAgICByZWFjdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSA6IHRocmVhZFxuICAgICAgICApO1xuICAgICAgICBtdXRhdGUocm9vbS5hZGRSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLCB7XG4gICAgICAgICAgb3B0aW1pc3RpY0RhdGFcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQ29tbWVudHNBcGlFcnJvcihlcnIpO1xuICAgICAgICAgIGVycm9yRXZlbnRTb3VyY2Uubm90aWZ5KFxuICAgICAgICAgICAgbmV3IEFkZFJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBlbW9qaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgbXV0YXRlLCBtYW5hZ2VyXVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24ocm9vbSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VSb29tTWFuYWdlcigpO1xuICAgIGNvbnN0IGZldGNoZXIgPSB1c2VUaHJlYWRzRmV0Y2hlcigpO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VSZXZhbGlkYXRlQ2FjaGUobWFuYWdlciwgZmV0Y2hlcik7XG4gICAgY29uc3QgbXV0YXRlID0gdXNlTXV0YXRlKG1hbmFnZXIsIHJldmFsaWRhdGUpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbW1lbnQgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRUaHJlYWRzKG1hbmFnZXIpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljRGF0YSA9IHRocmVhZHMubWFwKFxuICAgICAgICAgICh0aHJlYWQpID0+IHRocmVhZC5pZCA9PT0gdGhyZWFkSWQgPyB7XG4gICAgICAgICAgICAuLi50aHJlYWQsXG4gICAgICAgICAgICBjb21tZW50czogdGhyZWFkLmNvbW1lbnRzLm1hcCgoY29tbWVudCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29tbWVudC5pZCAhPT0gY29tbWVudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVhY3Rpb25JbmRleCA9IGNvbW1lbnQucmVhY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgcmVhY3Rpb25zID0gY29tbWVudC5yZWFjdGlvbnM7XG4gICAgICAgICAgICAgIGlmIChyZWFjdGlvbkluZGV4ID49IDAgJiYgY29tbWVudC5yZWFjdGlvbnNbcmVhY3Rpb25JbmRleF0udXNlcnMuc29tZShcbiAgICAgICAgICAgICAgICAodXNlcikgPT4gdXNlci5pZCA9PT0gdXNlcklkXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yZWFjdGlvbnNbcmVhY3Rpb25JbmRleF0udXNlcnMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0aW9ucyA9IFsuLi5jb21tZW50LnJlYWN0aW9uc107XG4gICAgICAgICAgICAgICAgICByZWFjdGlvbnMuc3BsaWNlKHJlYWN0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWFjdGlvbnNbcmVhY3Rpb25JbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgdXNlcnM6IHJlYWN0aW9uc1tyZWFjdGlvbkluZGV4XS51c2Vycy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgKHVzZXIpID0+IHVzZXIuaWQgIT09IHVzZXJJZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgcmVhY3Rpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gOiB0aHJlYWRcbiAgICAgICAgKTtcbiAgICAgICAgbXV0YXRlKHJvb20ucmVtb3ZlUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSwge1xuICAgICAgICAgIG9wdGltaXN0aWNEYXRhXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBDb21tZW50c0FwaUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKTtcbiAgICAgICAgICBlcnJvckV2ZW50U291cmNlLm5vdGlmeShcbiAgICAgICAgICAgIG5ldyBSZW1vdmVSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgW3Jvb20sIG11dGF0ZSwgbWFuYWdlcl1cbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVDb21tZW50O1xuICB9XG4gIHJldHVybiB7XG4gICAgQ29tbWVudHNSb29tUHJvdmlkZXIsXG4gICAgdXNlVGhyZWFkcyxcbiAgICB1c2VUaHJlYWRzU3VzcGVuc2UsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9wdGltaXN0aWNJZChwcmVmaXgpIHtcbiAgcmV0dXJuIGAke3ByZWZpeH1fJHtuYW5vaWQoKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlVGhyZWFkSWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoVEhSRUFEX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChyb29tKSB7XG4gIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgaWYgKHNlbGYgPT09IG51bGwgfHwgc2VsZi5pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlbGYuaWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRzQXBpRXJyb3IoZXJyKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtlcnIuc3RhdHVzfTogJHtlcnIubWVzc2FnZX1gO1xuICBpZiAoZXJyLmRldGFpbHM/LmVycm9yID09PSBcIkZPUkJJRERFTlwiKSB7XG4gICAgY29uc3QgZGV0YWlsZWRNZXNzYWdlID0gW21lc3NhZ2UsIGVyci5kZXRhaWxzLnN1Z2dlc3Rpb24sIGVyci5kZXRhaWxzLmRvY3NdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoZGV0YWlsZWRNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbVJldmFsaWRhdGlvbk1hbmFnZXIocm9vbUlkLCB7XG4gIGdldENhY2hlLFxuICBzZXRDYWNoZVxufSkge1xuICBsZXQgcmVxdWVzdDtcbiAgbGV0IGVycm9yO1xuICBsZXQgbXV0YXRpb247XG4gIGNvbnN0IHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgLy8gQ2FjaGVcbiAgICBnZXRDYWNoZSgpIHtcbiAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRDYWNoZSgpO1xuICAgICAgY29uc3QgZmlsdGVyZWQgPSB0aHJlYWRzLmZpbHRlcigodGhyZWFkKSA9PiB0aHJlYWQucm9vbUlkID09PSByb29tSWQpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgIH0sXG4gICAgc2V0Q2FjaGUodmFsdWUpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMua2V5cygpKSB7XG4gICAgICAgIGlmIChyZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5nZXQoa2V5KSA9PT0gMCkge1xuICAgICAgICAgIHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvcnRlZCA9IHZhbHVlLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PiBuZXcgRGF0ZShhLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRocmVhZHMgPSBnZXRDYWNoZSgpO1xuICAgICAgY29uc3QgbmV3VGhyZWFkcyA9IHRocmVhZHMuZmlsdGVyKCh0aHJlYWQpID0+IHRocmVhZC5yb29tSWQgIT09IHJvb21JZCkuY29uY2F0KHNvcnRlZCk7XG4gICAgICBzZXRDYWNoZShuZXdUaHJlYWRzKTtcbiAgICB9LFxuICAgIC8vIFJlcXVlc3RcbiAgICBnZXRSZXF1ZXN0KCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSxcbiAgICBzZXRSZXF1ZXN0KHZhbHVlKSB7XG4gICAgICByZXF1ZXN0ID0gdmFsdWU7XG4gICAgfSxcbiAgICAvLyBFcnJvclxuICAgIGdldEVycm9yKCkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG4gICAgc2V0RXJyb3IoZXJyKSB7XG4gICAgICBlcnJvciA9IGVycjtcbiAgICB9LFxuICAgIC8vIE11dGF0aW9uXG4gICAgZ2V0TXV0YXRpb24oKSB7XG4gICAgICByZXR1cm4gbXV0YXRpb247XG4gICAgfSxcbiAgICBzZXRNdXRhdGlvbihpbmZvKSB7XG4gICAgICBtdXRhdGlvbiA9IGluZm87XG4gICAgfSxcbiAgICBnZXRSZXZhbGlkYXRpb25NYW5hZ2VycygpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHJldmFsaWRhdGlvbk1hbmFnZXJCeU9wdGlvbnMuZW50cmllcygpKTtcbiAgICB9LFxuICAgIGdldFJldmFsaWRhdGlvbk1hbmFnZXIoa2V5KSB7XG4gICAgICByZXR1cm4gcmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucy5nZXQoa2V5KTtcbiAgICB9LFxuICAgIHNldFJldmFsaWRhdGlvbm1hbmFnZXIoa2V5LCBtYW5hZ2VyKSB7XG4gICAgICByZXZhbGlkYXRpb25NYW5hZ2VyQnlPcHRpb25zLnNldChrZXksIG1hbmFnZXIpO1xuICAgIH0sXG4gICAgZ2V0VG90YWxSZWZlcmVuY2VDb3VudCgpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLnZhbHVlcygpKS5yZWR1Y2UoXG4gICAgICAgIChhY2MsIGNvdW50KSA9PiBhY2MgKyBjb3VudCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9LFxuICAgIGluY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSkge1xuICAgICAgY29uc3QgY291bnQgPSByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5nZXQoa2V5KSA/PyAwO1xuICAgICAgcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuc2V0KGtleSwgY291bnQgKyAxKTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFJlZmVyZW5jZUNvdW50KGtleSkge1xuICAgICAgY29uc3QgY291bnQgPSByZWZlcmVuY2VDb3VudEJ5T3B0aW9ucy5nZXQoa2V5KSA/PyAwO1xuICAgICAgcmVmZXJlbmNlQ291bnRCeU9wdGlvbnMuc2V0KGtleSwgY291bnQgLSAxKTtcbiAgICB9LFxuICAgIGdldFJlZmVyZW5jZUNvdW50KGtleSkge1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZUNvdW50QnlPcHRpb25zLmdldChrZXkpID8/IDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Q2FjaGVTdG9yZSgpIHtcbiAgbGV0IHRocmVhZHMgPSBbXTtcbiAgY29uc3QgdGhyZWFkc0V2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIHJldHVybiB7XG4gICAgZ2V0VGhyZWFkcygpIHtcbiAgICAgIHJldHVybiB0aHJlYWRzO1xuICAgIH0sXG4gICAgc2V0VGhyZWFkcyh2YWx1ZSkge1xuICAgICAgdGhyZWFkcyA9IHZhbHVlO1xuICAgICAgdGhyZWFkc0V2ZW50U291cmNlLm5vdGlmeSh0aHJlYWRzKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRocmVhZHNFdmVudFNvdXJjZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVVzZVRocmVhZHNSZXZhbGlkYXRpb25NYW5hZ2VyKG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgbGV0IGlzTG9hZGluZyA9IHRydWU7XG4gIGxldCByZXF1ZXN0O1xuICBsZXQgZXJyb3I7XG4gIHJldHVybiB7XG4gICAgLy8gQ2FjaGVcbiAgICBnZXRDYWNoZSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzZXRDYWNoZSh2YWx1ZSkge1xuICAgICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKFxuICAgICAgICAobWFuYWdlci5nZXRDYWNoZSgpID8/IFtdKS5tYXAoKHRocmVhZCkgPT4gW3RocmVhZC5pZCwgdGhyZWFkXSlcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiB2YWx1ZSkge1xuICAgICAgICBjYWNoZS5zZXQodGhyZWFkLmlkLCB0aHJlYWQpO1xuICAgICAgfVxuICAgICAgbWFuYWdlci5zZXRDYWNoZShBcnJheS5mcm9tKGNhY2hlLnZhbHVlcygpKSk7XG4gICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8vIFJlcXVlc3RcbiAgICBnZXRSZXF1ZXN0KCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSxcbiAgICBzZXRSZXF1ZXN0KHZhbHVlKSB7XG4gICAgICByZXF1ZXN0ID0gdmFsdWU7XG4gICAgfSxcbiAgICAvLyBFcnJvclxuICAgIGdldEVycm9yKCkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG4gICAgc2V0RXJyb3IoZXJyKSB7XG4gICAgICBlcnJvciA9IGVycjtcbiAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgY2FjaGUgPSBtYW5hZ2VyLmdldENhY2hlKCk7XG4gICAgICBtYW5hZ2VyLnNldENhY2hlKGNhY2hlKTtcbiAgICB9LFxuICAgIC8vIE11dGF0aW9uXG4gICAgZ2V0TXV0YXRpb24oKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0sXG4gICAgc2V0TXV0YXRpb24oXykge1xuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgZ2V0SXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIGlzTG9hZGluZztcbiAgICB9LFxuICAgIHNldElzTG9hZGluZyh2YWx1ZSkge1xuICAgICAgaXNMb2FkaW5nID0gdmFsdWU7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UG9sbGluZ0ludGVydmFsKGlzQnJvd3Nlck9ubGluZSwgaXNEb2N1bWVudFZpc2libGUsIGlzUm9vbUNvbm5lY3RlZCkge1xuICBpZiAoIWlzQnJvd3Nlck9ubGluZSB8fCAhaXNEb2N1bWVudFZpc2libGUpXG4gICAgcmV0dXJuO1xuICBpZiAoaXNSb29tQ29ubmVjdGVkKVxuICAgIHJldHVybiBQT0xMSU5HX0lOVEVSVkFMX1JFQUxUSU1FO1xuICByZXR1cm4gUE9MTElOR19JTlRFUlZBTDtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi91c2UtZGVib3VuY2UudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LCB1c2VSZWYgYXMgdXNlUmVmMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgREVGQVVMVF9ERUxBWSA9IDUwMDtcbmZ1bmN0aW9uIHVzZURlYm91bmNlKHZhbHVlLCBkZWxheSA9IERFRkFVTFRfREVMQVkpIHtcbiAgY29uc3QgdGltZW91dCA9IHVzZVJlZjMoKTtcbiAgY29uc3QgW2RlYm91bmNlZFZhbHVlLCBzZXREZWJvdW5jZWRWYWx1ZV0gPSB1c2VTdGF0ZTIodmFsdWUpO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoZGVsYXkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aW1lb3V0LmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgc2V0RGVib3VuY2VkVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICB0aW1lb3V0LmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXREZWJvdW5jZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICB0aW1lb3V0LmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgfSwgZGVsYXkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW3ZhbHVlLCBkZWxheV0pO1xuICByZXR1cm4gZGVib3VuY2VkVmFsdWU7XG59XG5cbi8vIHNyYy9saWIvdXNlLWFzeW5jLWNhY2hlLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1LCB1c2VNZW1vIGFzIHVzZU1lbW8yLCB1c2VSZWYgYXMgdXNlUmVmNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmU0IH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xuaW1wb3J0IHsgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VJbml0aWFsKHZhbHVlKSB7XG4gIHJldHVybiB1c2VTdGF0ZTModmFsdWUpWzBdO1xufVxuXG4vLyBzcmMvbGliL3VzZS1hc3luYy1jYWNoZS50c1xudmFyIElOSVRJQUxfQVNZTkNfU1RBVEUgPSB7XG4gIGlzTG9hZGluZzogZmFsc2UsXG4gIGRhdGE6IHZvaWQgMCxcbiAgZXJyb3I6IHZvaWQgMFxufTtcbnZhciBub29wID0gKCkgPT4ge1xufTtcbmZ1bmN0aW9uIHVzZUFzeW5jQ2FjaGUoY2FjaGUsIGtleSwgb3B0aW9ucykge1xuICBjb25zdCBmcm96ZW5PcHRpb25zID0gdXNlSW5pdGlhbChvcHRpb25zKTtcbiAgY29uc3QgY2FjaGVJdGVtID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgIWNhY2hlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVJdGVtMiA9IGNhY2hlLmNyZWF0ZShrZXkpO1xuICAgIHZvaWQgY2FjaGVJdGVtMi5nZXQoKTtcbiAgICByZXR1cm4gY2FjaGVJdGVtMjtcbiAgfSwgW2NhY2hlLCBrZXldKTtcbiAgY29uc3Qgc3Vic2NyaWJlMiA9IHVzZUNhbGxiYWNrNChcbiAgICAoY2FsbGJhY2spID0+IGNhY2hlSXRlbT8uc3Vic2NyaWJlKGNhbGxiYWNrKSA/PyBub29wLFxuICAgIFtjYWNoZUl0ZW1dXG4gICk7XG4gIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2s0KFxuICAgICgpID0+IGNhY2hlSXRlbT8uZ2V0U3RhdGUoKSA/PyBJTklUSUFMX0FTWU5DX1NUQVRFLFxuICAgIFtjYWNoZUl0ZW1dXG4gICk7XG4gIGNvbnN0IHJldmFsaWRhdGUgPSB1c2VDYWxsYmFjazQoKCkgPT4gY2FjaGVJdGVtPy5yZXZhbGlkYXRlKCksIFtjYWNoZUl0ZW1dKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTQoc3Vic2NyaWJlMiwgZ2V0U3RhdGUsIGdldFN0YXRlKTtcbiAgY29uc3QgcHJldmlvdXNEYXRhID0gdXNlUmVmNCgpO1xuICBsZXQgZGF0YSA9IHN0YXRlLmRhdGE7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIHByZXZpb3VzRGF0YS5jdXJyZW50ID0geyBrZXksIGRhdGE6IHN0YXRlLmRhdGEgfTtcbiAgfSwgW2tleSwgc3RhdGUuZGF0YV0pO1xuICBpZiAoIWNhY2hlSXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgIGdldFN0YXRlLFxuICAgICAgcmV2YWxpZGF0ZVxuICAgIH07XG4gIH1cbiAgaWYgKGZyb3plbk9wdGlvbnM/LnN1c3BlbnNlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBnZXRTdGF0ZSgpLmVycm9yO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBlbHNlIGlmIChnZXRTdGF0ZSgpLmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY2FjaGVJdGVtLnN1YnNjcmliZU9uY2UoKHN0YXRlMikgPT4ge1xuICAgICAgICAgIGlmICghc3RhdGUyLmlzTG9hZGluZykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLmlzTG9hZGluZyAmJiBmcm96ZW5PcHRpb25zPy5rZWVwUHJldmlvdXNEYXRhV2hpbGVMb2FkaW5nICYmIHR5cGVvZiBzdGF0ZS5kYXRhID09PSBcInVuZGVmaW5lZFwiICYmIHByZXZpb3VzRGF0YS5jdXJyZW50Py5rZXkgIT09IGtleSAmJiB0eXBlb2YgcHJldmlvdXNEYXRhLmN1cnJlbnQ/LmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkYXRhID0gcHJldmlvdXNEYXRhLmN1cnJlbnQuZGF0YTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogc3RhdGUuaXNMb2FkaW5nLFxuICAgIGRhdGEsXG4gICAgZXJyb3I6IHN0YXRlLmVycm9yLFxuICAgIGdldFN0YXRlLFxuICAgIHJldmFsaWRhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi91c2UtbGF0ZXN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NiwgdXNlUmVmIGFzIHVzZVJlZjUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUxhdGVzdCh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWY1KHZhbHVlKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9saWIvdXNlLXJlcmVuZGVyLnRzXG5pbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VSZXJlbmRlcigpIHtcbiAgY29uc3QgWywgdXBkYXRlXSA9IHVzZVJlZHVjZXIoXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBieSBpbmNyZW1lbnRpbmcgYSBoaWRkZW4gY291bnRlciB2YWx1ZSB0aGF0IGlzXG4gICAgLy8gbmV2ZXIgY29uc3VtZWQuIFNpbXBseSBpbmNyZW1lbnRpbmcgdGhlIGNvdW50ZXIgY2hhbmdlcyB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBzdGF0ZSBhbmQsIHRodXMsIHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gICAgKHgpID0+IHggKyAxLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gc3JjL2ZhY3RvcnkudHN4XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGlkZW50aXR5ID0gKHgpID0+IHg7XG52YXIgbWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChyZWFjdFZlcnNpb24sIHJvb21JZCkgPT4gYFdlIG5vdGljZWQgeW91XFx1MjAxOXJlIHVzaW5nIFJlYWN0ICR7cmVhY3RWZXJzaW9ufS4gUGxlYXNlIHBhc3MgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXQgdGhlIFJvb21Qcm92aWRlciBsZXZlbCB1bnRpbCB5b3VcXHUyMDE5cmUgcmVhZHkgdG8gdXBncmFkZSB0byBSZWFjdCAxODpcblxuICAgIGltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiOyAgLy8gb3IgXCJyZWFjdC1uYXRpdmVcIlxuXG4gICAgPFJvb21Qcm92aWRlciBpZD0ke0pTT04uc3RyaW5naWZ5KFxuICByb29tSWRcbil9IC4uLiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz17dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXN9PlxuICAgICAgLi4uXG4gICAgPC9Sb29tUHJvdmlkZXI+XG5cbldoeT8gUGxlYXNlIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS90cm91Ymxlc2hvb3Rpbmcjc3RhbGUtcHJvcHMtem9tYmllLWNoaWxkIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbnZhciBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IFwiWW91IGRvblxcdTIwMTl0IG5lZWQgdG8gcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB0byBSb29tUHJvdmlkZXIgYW55bW9yZSwgc2luY2UgeW91XFx1MjAxOXJlIG9uIFJlYWN0IDE4KyBhbHJlYWR5LlwiO1xuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUzKHMsIGdzLCBnc3MpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihzLCBncywgZ3NzLCBpZGVudGl0eSk7XG59XG52YXIgU1RBQkxFX0VNUFRZX0xJU1QgPSBPYmplY3QuZnJlZXplKFtdKTtcbmZ1bmN0aW9uIGFsd2F5c0VtcHR5TGlzdCgpIHtcbiAgcmV0dXJuIFNUQUJMRV9FTVBUWV9MSVNUO1xufVxuZnVuY3Rpb24gYWx3YXlzTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pIHtcbiAgY29uc3QgZXJybXNnID0gXCJUaGlzIG11dGF0aW9uIGNhbm5vdCBiZSB1c2VkIHVudGlsIGNvbm5lY3RlZCB0byB0aGUgTGl2ZWJsb2NrcyByb29tXCI7XG4gIHJldHVybiB7XG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICBjb25zdCBtdXRhYmxlUm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gICAgICBpZiAobXV0YWJsZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXV0YWJsZVJvb3Q7XG4gICAgfSxcbiAgICBnZXQgc2VsZigpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgICAgIGlmIChzZWxmID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBnZXQgb3RoZXJzKCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gcm9vbS5nZXRPdGhlcnMoKTtcbiAgICAgIGlmIChyb29tLmdldFNlbGYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlcnM7XG4gICAgfSxcbiAgICBzZXRNeVByZXNlbmNlOiByb29tLnVwZGF0ZVByZXNlbmNlXG4gIH07XG59XG52YXIgaGFzV2FybmVkSWZOb1Jlc29sdmVVc2VycyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybklmTm9SZXNvbHZlVXNlcnModXNlcnNDYWNoZSkge1xuICBpZiAoIWhhc1dhcm5lZElmTm9SZXNvbHZlVXNlcnMgJiYgIXVzZXJzQ2FjaGUgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJTZXQgdGhlIHJlc29sdmVVc2VycyBvcHRpb24gaW4gY3JlYXRlUm9vbUNvbnRleHQgdG8gc3BlY2lmeSB1c2VyIGluZm8uXCJcbiAgICApO1xuICAgIGhhc1dhcm5lZElmTm9SZXNvbHZlVXNlcnMgPSB0cnVlO1xuICB9XG59XG52YXIgQ29udGV4dEJ1bmRsZSA9IFJlYWN0My5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlUm9vbUNvbnRleHRCdW5kbGUoKSB7XG4gIGNvbnN0IGJ1bmRsZSA9IFJlYWN0My51c2VDb250ZXh0KENvbnRleHRCdW5kbGUpO1xuICBpZiAoYnVuZGxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb21Db250ZXh0KGNsaWVudCwgb3B0aW9ucykge1xuICBjb25zdCBSb29tQ29udGV4dCA9IFJlYWN0My5jcmVhdGVDb250ZXh0KG51bGwpO1xuICBjb25zdCBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UyKCk7XG4gIGNvbnN0IHsgQ29tbWVudHNSb29tUHJvdmlkZXIsIC4uLmNvbW1lbnRzUm9vbSB9ID0gY3JlYXRlQ29tbWVudHNSb29tKGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSk7XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlck91dGVyKHByb3BzKSB7XG4gICAgY29uc3QgW2NhY2hlXSA9IFJlYWN0My51c2VTdGF0ZShcbiAgICAgICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICApO1xuICAgIGNvbnN0IHN0YWJsZUVudGVyUm9vbSA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChyb29tSWQsIG9wdGlvbnMyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChyb29tSWQpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGNvbnN0IHJ2ID0gY2xpZW50LmVudGVyUm9vbShcbiAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgb3B0aW9uczJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgb3JpZ0xlYXZlID0gcnYubGVhdmU7XG4gICAgICAgIHJ2LmxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIG9yaWdMZWF2ZSgpO1xuICAgICAgICAgIGNhY2hlLmRlbGV0ZShyb29tSWQpO1xuICAgICAgICB9O1xuICAgICAgICBjYWNoZS5zZXQocm9vbUlkLCBydik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0sXG4gICAgICBbY2FjaGVdXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJvb21Qcm92aWRlcklubmVyLCB7IC4uLnByb3BzLCBzdGFibGVFbnRlclJvb20gfSk7XG4gIH1cbiAgZnVuY3Rpb24gUm9vbVByb3ZpZGVySW5uZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkOiByb29tSWQsIHN0YWJsZUVudGVyUm9vbSB9ID0gcHJvcHM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFyb29tSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IGlzIHJlcXVpcmVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtcmVhY3QvUm9vbVByb3ZpZGVyLWlkLXByb3BlcnR5LWlzLXJlcXVpcmVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygcm9vbUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBzaG91bGQgYmUgYSBzdHJpbmcuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFqb3JSZWFjdFZlcnNpb24gPSBwYXJzZUludChSZWFjdDMudmVyc2lvbikgfHwgMTtcbiAgICAgIGNvbnN0IG9sZFJlYWN0VmVyc2lvbiA9IG1ham9yUmVhY3RWZXJzaW9uIDwgMTg7XG4gICAgICBlcnJvcklmKFxuICAgICAgICBvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPT09IHZvaWQgMCxcbiAgICAgICAgbWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhtYWpvclJlYWN0VmVyc2lvbiwgcm9vbUlkKVxuICAgICAgKTtcbiAgICAgIGRlcHJlY2F0ZUlmKFxuICAgICAgICAhb2xkUmVhY3RWZXJzaW9uICYmIHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzICE9PSB2b2lkIDAsXG4gICAgICAgIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBmcm96ZW5Qcm9wcyA9IHVzZUluaXRpYWwoe1xuICAgICAgaW5pdGlhbFByZXNlbmNlOiBwcm9wcy5pbml0aWFsUHJlc2VuY2UsXG4gICAgICBpbml0aWFsU3RvcmFnZTogcHJvcHMuaW5pdGlhbFN0b3JhZ2UsXG4gICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBhdXRvQ29ubmVjdDogcHJvcHMuYXV0b0Nvbm5lY3QgPz8gcHJvcHMuc2hvdWxkSW5pdGlhbGx5Q29ubmVjdCA/PyB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgfSk7XG4gICAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IFJlYWN0My51c2VTdGF0ZShcbiAgICAgICgpID0+IHN0YWJsZUVudGVyUm9vbShyb29tSWQsIHtcbiAgICAgICAgLi4uZnJvemVuUHJvcHMsXG4gICAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgdXNpbmcgZmFsc2UgaGVyZSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgYmVsb3dcbiAgICAgIH0pXG4gICAgKTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHBhaXIgPSBzdGFibGVFbnRlclJvb20ocm9vbUlkLCBmcm96ZW5Qcm9wcyk7XG4gICAgICBzZXRSb29tTGVhdmVQYWlyKHBhaXIpO1xuICAgICAgY29uc3QgeyByb29tOiByb29tMiwgbGVhdmUgfSA9IHBhaXI7XG4gICAgICBpZiAoZnJvemVuUHJvcHMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgICAgcm9vbTIuY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGVhdmUoKTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb21JZCwgZnJvemVuUHJvcHMsIHN0YWJsZUVudGVyUm9vbV0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUm9vbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJvb20gfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KENvbW1lbnRzUm9vbVByb3ZpZGVyLCB7IHJvb20gfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29udGV4dEJ1bmRsZS5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IGludGVybmFsQnVuZGxlXG4gICAgICB9LFxuICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICApKSk7XG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdGlvbklkU2VsZWN0b3Iob3RoZXJzKSB7XG4gICAgcmV0dXJuIG90aGVycy5tYXAoKHVzZXIpID0+IHVzZXIuY29ubmVjdGlvbklkKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tKCkge1xuICAgIGNvbnN0IHJvb20gPSBSZWFjdDMudXNlQ29udGV4dChSb29tQ29udGV4dCk7XG4gICAgaWYgKHJvb20gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vbTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSByb29tLmdldFN0YXR1cztcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlMiwgZ2V0U25hcHNob3QyLCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXlQcmVzZW5jZSgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSByb29tLmdldFByZXNlbmNlO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZTIsIGdldFNuYXBzaG90MiwgZ2V0U25hcHNob3QyKTtcbiAgICBjb25zdCBzZXRQcmVzZW5jZSA9IHJvb20udXBkYXRlUHJlc2VuY2U7XG4gICAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVwZGF0ZU15UHJlc2VuY2UoKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS51cGRhdGVQcmVzZW5jZTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnMoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90MiA9IHJvb20uZ2V0T3RoZXJzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzRW1wdHlMaXN0O1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdWJzY3JpYmUyLFxuICAgICAgZ2V0U25hcHNob3QyLFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvciA/PyBpZGVudGl0eSxcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHVzZU90aGVycyhjb25uZWN0aW9uSWRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKFxuICAgICAgICAob3RoZXIpID0+IFtvdGhlci5jb25uZWN0aW9uSWQsIGl0ZW1TZWxlY3RvcihvdGhlcildXG4gICAgICApLFxuICAgICAgW2l0ZW1TZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZXEgPSBpdGVtSXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoYXR1cGxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiBhdHVwbGVbMF0gPT09IGJ0dXBsZVswXSAmJiBlcShhdHVwbGVbMV0sIGJ0dXBsZVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtpdGVtSXNFcXVhbF1cbiAgICApO1xuICAgIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIH1cbiAgY29uc3QgTk9UX0ZPVU5EID0gU3ltYm9sKCk7XG4gIGZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKFxuICAgICAgICAgIChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgICAgfSxcbiAgICAgIFtjb25uZWN0aW9uSWQsIHNlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgICAocHJldiwgY3VycikgPT4ge1xuICAgICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICAgIHJldHVybiBwcmV2ID09PSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBlcShwcmV2LCBjdXJyKTtcbiAgICAgIH0sXG4gICAgICBbaXNFcXVhbF1cbiAgICApO1xuICAgIGNvbnN0IG90aGVyID0gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICAgIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBzdWNoIG90aGVyIHVzZXIgd2l0aCBjb25uZWN0aW9uIGlkICR7Y29ubmVjdGlvbklkfSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQnJvYWRjYXN0RXZlbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50LCBvcHRpb25zMiA9IHsgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgcm9vbS5icm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0My51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KSksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0My51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgIChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KVxuICAgICAgKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXJyb3JMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHJvb20uZXZlbnRzLmVycm9yLnN1YnNjcmliZSgoZSkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGUpKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudERhdGEpID0+IHtcbiAgICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50RGF0YSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfSwgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTZWxmKG1heWJlU2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZTIgPSByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSByb29tLmdldFNlbGY7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBtYXliZVNlbGVjdG9yID8/IGlkZW50aXR5O1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyBzZWxlY3RvcihtZSkgOiBudWxsLFxuICAgICAgW3NlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdWJzY3JpYmUyLFxuICAgICAgZ2V0U25hcHNob3QyLFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdDtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUyLCBnZXRTbmFwc2hvdDIsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlUm9vdCgpIHtcbiAgICByZXR1cm4gW3VzZU11dGFibGVTdG9yYWdlUm9vdCgpXTtcbiAgfVxuICBmdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICAgIHJldHVybiB1c2VSb29tKCkuaGlzdG9yeTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbmRvKCkge1xuICAgIHJldHVybiB1c2VIaXN0b3J5KCkudW5kbztcbiAgfVxuICBmdW5jdGlvbiB1c2VSZWRvKCkge1xuICAgIHJldHVybiB1c2VIaXN0b3J5KCkucmVkbztcbiAgfVxuICBmdW5jdGlvbiB1c2VDYW5VbmRvKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlMiA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGNhblVuZG8gPSByb29tLmhpc3RvcnkuY2FuVW5kbztcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZTIsIGNhblVuZG8sIGNhblVuZG8pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNhblJlZG8oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gICAgY29uc3QgY2FuUmVkbyA9IHJvb20uaGlzdG9yeS5jYW5SZWRvO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlMiwgY2FuUmVkbywgY2FuUmVkbyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS5iYXRjaDtcbiAgfVxuICBmdW5jdGlvbiB1c2VMZWdhY3lLZXkoa2V5KSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gICAgY29uc3QgcmVyZW5kZXIgPSB1c2VSZXJlbmRlcigpO1xuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdCA9IHJvb3RPck51bGw7XG4gICAgICBsZXQgdW5zdWJDdXJyO1xuICAgICAgbGV0IGN1cnIgPSByb290LmdldChrZXkpO1xuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9DdXJyKCkge1xuICAgICAgICB1bnN1YkN1cnIgPSBpc0xpdmVOb2RlKGN1cnIpID8gcm9vbS5zdWJzY3JpYmUoY3VyciwgcmVyZW5kZXIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Sb290Q2hhbmdlKCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJvb3QuZ2V0KGtleSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gY3Vycikge1xuICAgICAgICAgIHVuc3ViQ3Vycj8uKCk7XG4gICAgICAgICAgY3VyciA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHN1YnNjcmliZVRvQ3VycigpO1xuICAgICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZVRvQ3VycigpO1xuICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlUm9vdCA9IHJvb20uc3Vic2NyaWJlKHJvb3QsIG9uUm9vdENoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZVJvb3QoKTtcbiAgICAgICAgdW5zdWJDdXJyPy4oKTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb3RPck51bGwsIHJvb20sIGtleSwgcmVyZW5kZXJdKTtcbiAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290T3JOdWxsLmdldChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKHJvb3RPck51bGwyKSA9PiByb290T3JOdWxsMiAhPT0gbnVsbCA/IHNlbGVjdG9yKHJvb3RPck51bGwyKSA6IG51bGwsXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBzdWJzY3JpYmUyID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgICAgKG9uU3RvcmVDaGFuZ2UpID0+IHJvb3RPck51bGwgIT09IG51bGwgPyByb29tLnN1YnNjcmliZShyb290T3JOdWxsLCBvblN0b3JlQ2hhbmdlLCB7IGlzRGVlcDogdHJ1ZSB9KSA6IG5vb3AyLFxuICAgICAgW3Jvb20sIHJvb3RPck51bGxdXG4gICAgKTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdDIgPSBSZWFjdDMudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgICAgY29uc3QgaW1tID0gcm9vdC50b0ltbXV0YWJsZSgpO1xuICAgICAgICByZXR1cm4gaW1tO1xuICAgICAgfVxuICAgIH0sIFtyb290T3JOdWxsXSk7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdWJzY3JpYmUyLFxuICAgICAgZ2V0U25hcHNob3QyLFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IGNhbm5vdCB1c2UgdGhlIFN1c3BlbnNlIHZlcnNpb24gb2YgdGhpcyBob29rIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB0aGVtIG9uIHRoZSBjbGllbnQgc2lkZS5cXG5Gb3IgdGlwcywgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1yZWFjdCNzdXNwZW5zZS1hdm9pZC1zc3JcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGlmIChyb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGlmIChyb29tLmdldFNlbGYoKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gICAgdGhyb3cgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNdXRhdGlvbihjYWxsYmFjaywgZGVwcykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0My51c2VNZW1vKFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICByb29tLmJhdGNoKFxuICAgICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgW3Jvb20sIC4uLmRlcHNdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2UoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVNlbGZTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZVNlbGYoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc1N1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzKFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UoKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzQ29ubmVjdGlvbklkcygpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZFN1c3BlbnNlKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnNNYXBwZWQoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJTdXNwZW5zZShjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXIoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTGVnYWN5S2V5U3VzcGVuc2Uoa2V5KSB7XG4gICAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VMZWdhY3lLZXkoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gY29tbWVudHNSb29tLnVzZVRocmVhZHMocm9vbSwgb3B0aW9uczIpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zMikge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VUaHJlYWRzU3VzcGVuc2Uocm9vbSwgb3B0aW9uczIpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZVRocmVhZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlQ3JlYXRlVGhyZWFkKHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlRWRpdFRocmVhZE1ldGFkYXRhKHJvb20pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIGNvbW1lbnRzUm9vbS51c2VBZGRSZWFjdGlvbihyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSZW1vdmVSZWFjdGlvbigpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlUmVtb3ZlUmVhY3Rpb24ocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlQ3JlYXRlQ29tbWVudChyb29tKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0Q29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlRWRpdENvbW1lbnQocm9vbSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRGVsZXRlQ29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBjb21tZW50c1Jvb20udXNlRGVsZXRlQ29tbWVudChyb29tKTtcbiAgfVxuICBjb25zdCB7IHJlc29sdmVVc2VycywgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgdXNlcnNDYWNoZSA9IHJlc29sdmVVc2VycyA/IGNyZWF0ZUFzeW5jQ2FjaGUoYXN5bmMgKHN0cmluZ2lmaWVkT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzKFxuICAgICAgSlNPTi5wYXJzZShzdHJpbmdpZmllZE9wdGlvbnMpXG4gICAgKTtcbiAgICByZXR1cm4gdXNlcnM/LlswXTtcbiAgfSkgOiB2b2lkIDA7XG4gIGZ1bmN0aW9uIHVzZVVzZXIodXNlcklkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByZXNvbHZlcktleSA9IFJlYWN0My51c2VNZW1vKFxuICAgICAgKCkgPT4gc3RyaW5naWZ5Mih7IHVzZXJJZHM6IFt1c2VySWRdLCByb29tSWQ6IHJvb20uaWQgfSksXG4gICAgICBbdXNlcklkLCByb29tLmlkXVxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VBc3luY0NhY2hlKHVzZXJzQ2FjaGUsIHJlc29sdmVyS2V5KTtcbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHdhcm5JZk5vUmVzb2x2ZVVzZXJzKHVzZXJzQ2FjaGUpLCBbXSk7XG4gICAgaWYgKHN0YXRlLmlzTG9hZGluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgICAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZSh1c2VySWQpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJlc29sdmVyS2V5ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgICAoKSA9PiBzdHJpbmdpZnkyKHsgdXNlcklkczogW3VzZXJJZF0sIHJvb21JZDogcm9vbS5pZCB9KSxcbiAgICAgIFt1c2VySWQsIHJvb20uaWRdXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZUFzeW5jQ2FjaGUodXNlcnNDYWNoZSwgcmVzb2x2ZXJLZXksIHtcbiAgICAgIHN1c3BlbnNlOiB0cnVlXG4gICAgfSk7XG4gICAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB3YXJuSWZOb1Jlc29sdmVVc2Vycyh1c2Vyc0NhY2hlKSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyOiBzdGF0ZS5kYXRhLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUgPSBjcmVhdGVBc3luY0NhY2hlKFxuICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMgPyAoc3RyaW5naWZpZWRPcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyhcbiAgICAgICAgSlNPTi5wYXJzZShzdHJpbmdpZmllZE9wdGlvbnMpXG4gICAgICApO1xuICAgIH0gOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoW10pXG4gICk7XG4gIGZ1bmN0aW9uIHVzZU1lbnRpb25TdWdnZXN0aW9ucyhzZWFyY2gpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IGRlYm91bmNlZFNlYXJjaCA9IHVzZURlYm91bmNlKHNlYXJjaCwgNTAwKTtcbiAgICBjb25zdCByZXNvbHZlcktleSA9IFJlYWN0My51c2VNZW1vKFxuICAgICAgKCkgPT4gZGVib3VuY2VkU2VhcmNoICE9PSB2b2lkIDAgPyBzdHJpbmdpZnkyKHsgdGV4dDogZGVib3VuY2VkU2VhcmNoLCByb29tSWQ6IHJvb20uaWQgfSkgOiBudWxsLFxuICAgICAgW2RlYm91bmNlZFNlYXJjaCwgcm9vbS5pZF1cbiAgICApO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdXNlQXN5bmNDYWNoZShtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSwgcmVzb2x2ZXJLZXksIHtcbiAgICAgIGtlZXBQcmV2aW91c0RhdGFXaGlsZUxvYWRpbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCBidW5kbGUgPSB7XG4gICAgUm9vbUNvbnRleHQsXG4gICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJPdXRlcixcbiAgICB1c2VSb29tLFxuICAgIHVzZVN0YXR1cyxcbiAgICB1c2VCYXRjaCxcbiAgICB1c2VCcm9hZGNhc3RFdmVudCxcbiAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICB1c2VIaXN0b3J5LFxuICAgIHVzZVVuZG8sXG4gICAgdXNlUmVkbyxcbiAgICB1c2VDYW5SZWRvLFxuICAgIHVzZUNhblVuZG8sXG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgYWxpYXNlcy4gVGhlIHBhc3NlZC1pbiBrZXkgd2lsbCBkZWZpbmUgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAgICB1c2VMaXN0OiB1c2VMZWdhY3lLZXksXG4gICAgdXNlTWFwOiB1c2VMZWdhY3lLZXksXG4gICAgdXNlT2JqZWN0OiB1c2VMZWdhY3lLZXksXG4gICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgdXNlU3RvcmFnZSxcbiAgICB1c2VTZWxmLFxuICAgIHVzZU15UHJlc2VuY2UsXG4gICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICB1c2VPdGhlcnMsXG4gICAgdXNlT3RoZXJzTWFwcGVkLFxuICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMsXG4gICAgdXNlT3RoZXIsXG4gICAgdXNlTXV0YXRpb24sXG4gICAgdXNlVGhyZWFkcyxcbiAgICB1c2VVc2VyLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBSb29tQ29udGV4dCxcbiAgICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyT3V0ZXIsXG4gICAgICB1c2VSb29tLFxuICAgICAgdXNlU3RhdHVzLFxuICAgICAgdXNlQmF0Y2gsXG4gICAgICB1c2VCcm9hZGNhc3RFdmVudCxcbiAgICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgICAgdXNlSGlzdG9yeSxcbiAgICAgIHVzZVVuZG8sXG4gICAgICB1c2VSZWRvLFxuICAgICAgdXNlQ2FuUmVkbyxcbiAgICAgIHVzZUNhblVuZG8sXG4gICAgICAvLyBMZWdhY3kgaG9va3NcbiAgICAgIHVzZUxpc3Q6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlTWFwOiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZU9iamVjdDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICAgIHVzZVN0b3JhZ2U6IHVzZVN0b3JhZ2VTdXNwZW5zZSxcbiAgICAgIHVzZVNlbGY6IHVzZVNlbGZTdXNwZW5zZSxcbiAgICAgIHVzZU15UHJlc2VuY2UsXG4gICAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgICAgdXNlT3RoZXJzOiB1c2VPdGhlcnNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc01hcHBlZDogdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzOiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcjogdXNlT3RoZXJTdXNwZW5zZSxcbiAgICAgIHVzZU11dGF0aW9uLFxuICAgICAgdXNlVGhyZWFkczogdXNlVGhyZWFkc1N1c3BlbnNlLFxuICAgICAgdXNlVXNlcjogdXNlVXNlclN1c3BlbnNlLFxuICAgICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICAgIHVzZUVkaXRDb21tZW50LFxuICAgICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgICAgdXNlUmVtb3ZlUmVhY3Rpb25cbiAgICB9XG4gIH07XG4gIGNvbnN0IGludGVybmFsQnVuZGxlID0ge1xuICAgIC4uLmJ1bmRsZSxcbiAgICBoYXNSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zICE9PSB2b2lkIDAsXG4gICAgdXNlTWVudGlvblN1Z2dlc3Rpb25zXG4gIH07XG4gIHJldHVybiBidW5kbGU7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgc2hhbGxvdyBhcyBzaGFsbG93MiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRTaWRlU3VzcGVuc2UsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBzaGFsbG93MiBhcyBzaGFsbG93LFxuICB1c2VSb29tQ29udGV4dEJ1bmRsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiZGV0ZWN0RHVwZXMiLCJQS0dfTkFNRSIsIlBLR19WRVJTSU9OIiwiUEtHX0ZPUk1BVCIsIlJlYWN0IiwiQ2xpZW50U2lkZVN1c3BlbnNlIiwicHJvcHMiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJjaGlsZHJlbiIsInNoYWxsb3ciLCJjcmVhdGVBc3luY0NhY2hlIiwiZGVwcmVjYXRlSWYiLCJlcnJvcklmIiwiaXNMaXZlTm9kZSIsIm1ha2VFdmVudFNvdXJjZSIsIm1ha2VFdmVudFNvdXJjZTIiLCJzdHJpbmdpZnkiLCJzdHJpbmdpZnkyIiwiUmVhY3QzIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIiLCJDb21tZW50c0FwaUVycm9yIiwibmFub2lkIiwiUmVhY3QyIiwiY3JlYXRlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwidXNlQ2FsbGJhY2szIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdDMiLCJ1c2VNZW1vIiwiQ3JlYXRlVGhyZWFkRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY2F1c2UiLCJjb250ZXh0IiwibmFtZSIsIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yIiwiQ3JlYXRlQ29tbWVudEVycm9yIiwiRWRpdENvbW1lbnRFcnJvciIsIkRlbGV0ZUNvbW1lbnRFcnJvciIsIkFkZFJlYWN0aW9uRXJyb3IiLCJSZW1vdmVSZWFjdGlvbkVycm9yIiwidXNlQ2FsbGJhY2syIiwidXNlRWZmZWN0MiIsInVzZVJlZiIsInVzZVJlZjIiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlzRG9jdW1lbnRWaXNpYmxlIiwiaXNWaXNpYmxlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJvblN0b3JlQ2hhbmdlIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzRG9jdW1lbnREZWZpbmVkIiwidmlzaWJpbGl0eVN0YXRlIiwidXNlU3luY0V4dGVybmFsU3RvcmUyIiwidXNlSXNPbmxpbmUiLCJpc09ubGluZVJlZiIsInN1YnNjcmliZTIiLCJoYW5kbGVJc09ubGluZSIsImN1cnJlbnQiLCJoYW5kbGVJc09mZmxpbmUiLCJ3aW5kb3ciLCJnZXRTbmFwc2hvdDIiLCJpc09ubGluZSIsIkRFRkFVTFRfRVJST1JfUkVUUllfSU5URVJWQUwiLCJERUZBVUxUX01BWF9FUlJPUl9SRVRSWV9DT1VOVCIsIkRFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwiLCJ0aW1lc3RhbXAiLCJ1c2VSZXZhbGlkYXRlQ2FjaGUiLCJtYW5hZ2VyIiwiZmV0Y2hlciIsIm9wdGlvbnMiLCJkZWR1cGluZ0ludGVydmFsIiwiZXJyb3JSZXRyeUludGVydmFsIiwiZXJyb3JSZXRyeUNvdW50IiwiX3JldmFsaWRhdGVDYWNoZSIsInNob3VsZERlZHVwZSIsInJldHJ5Q291bnQiLCJzdGFydEF0Iiwic2hvdWxkU3RhcnRSZXF1ZXN0IiwiZ2V0UmVxdWVzdCIsImRlbGV0ZUFjdGl2ZVJlcXVlc3QiLCJhY3RpdmVSZXF1ZXN0Iiwic2V0UmVxdWVzdCIsImhhbmRsZUVycm9yIiwidGltZW91dCIsIk1hdGgiLCJyYW5kb20iLCJzZXRUaW1lb3V0IiwibmV3RGF0YSIsImFjdGl2ZU11dGF0aW9uIiwiZ2V0TXV0YXRpb24iLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwic2V0Q2FjaGUiLCJlcnIiLCJzZXRFcnJvciIsInJldmFsaWRhdGVDYWNoZSIsInVzZU11dGF0ZSIsIm11dGF0ZSIsImRhdGEiLCJiZWZvcmVNdXRhdGlvblRpbWVzdGFtcCIsInNldE11dGF0aW9uIiwiY3VycmVudENhY2hlIiwiZ2V0Q2FjaGUiLCJvcHRpbWlzdGljRGF0YSIsImVycm9yIiwiVEhSRUFEX0lEX1BSRUZJWCIsIkNPTU1FTlRfSURfUFJFRklYIiwiUE9MTElOR19JTlRFUlZBTF9SRUFMVElNRSIsIlBPTExJTkdfSU5URVJWQUwiLCJjcmVhdGVDb21tZW50c1Jvb20iLCJlcnJvckV2ZW50U291cmNlIiwic3RvcmUiLCJjcmVhdGVDbGllbnRDYWNoZVN0b3JlIiwiRmV0Y2hlckNvbnRleHQiLCJSb29tTWFuYWdlckNvbnRleHQiLCJnZXRUaHJlYWRzIiwidGhyZWFkcyIsIkNvbW1lbnRzUm9vbVByb3ZpZGVyIiwicm9vbSIsImNyZWF0ZVJvb21SZXZhbGlkYXRpb25NYW5hZ2VyIiwiaWQiLCJzZXRUaHJlYWRzIiwiZ2V0UmV2YWxpZGF0aW9uTWFuYWdlcnMiLCJmaWx0ZXIiLCJrZXkiLCJnZXRSZWZlcmVuY2VDb3VudCIsIm1hcCIsIl8iLCJtYW5hZ2VyMiIsImdldE9wdGlvbnMiLCJyZXNwb25zZXMiLCJQcm9taXNlIiwiYWxsIiwib3B0aW9uIiwiQXJyYXkiLCJmcm9tIiwiTWFwIiwiZmxhdCIsInRocmVhZCIsInZhbHVlcyIsInN0YXR1cyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlMyIsImV2ZW50cyIsImdldFN0YXR1cyIsImlzRG9jdW1lbnRWaXNpYmxlIiwicmVmcmVzaEludGVydmFsIiwiZ2V0UG9sbGluZ0ludGVydmFsIiwicmV2YWxpZGF0aW9uVGltZXJJZCIsInNjaGVkdWxlUmV2YWxpZGF0aW9uIiwiZ2V0RXJyb3IiLCJnZXRUb3RhbFJlZmVyZW5jZUNvdW50IiwidGhlbiIsImNsZWFyVGltZW91dCIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJ1bnN1YnNjcmliZSIsImNvbW1lbnRzIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVJvb21NYW5hZ2VyIiwiZ2V0VXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIiLCJyb29tTWFuYWdlciIsInJldmFsaWRhdGlvbk1hbmFnZXIiLCJnZXRSZXZhbGlkYXRpb25NYW5hZ2VyIiwidXNlVGhyZWFkc1JldmFsaWRhdGlvbk1hbmFnZXIiLCJjcmVhdGVVc2VUaHJlYWRzUmV2YWxpZGF0aW9uTWFuYWdlciIsInNldFJldmFsaWRhdGlvbm1hbmFnZXIiLCJ1c2VUaHJlYWRzRmV0Y2hlciIsInVzZVRocmVhZHMiLCJxdWVyeSIsIm1ldGFkYXRhIiwiaW5jcmVtZW50UmVmZXJlbmNlQ291bnQiLCJkZWNyZW1lbnRSZWZlcmVuY2VDb3VudCIsImNhY2hlIiwiX3VzZVRocmVhZHMiLCJ1c2VUaHJlYWRzU3VzcGVuc2UiLCJpc0xvYWRpbmciLCJzdGF0ZSIsImdldElzTG9hZGluZyIsIm9wdGlvbnMyIiwiZmlsdGVyZWQiLCJyb29tSWQiLCJ1c2VFZGl0VGhyZWFkTWV0YWRhdGEiLCJyZXZhbGlkYXRlIiwiZWRpdFRocmVhZE1ldGFkYXRhIiwidGhyZWFkSWQiLCJjYXRjaCIsImhhbmRsZUNvbW1lbnRzQXBpRXJyb3IiLCJub3RpZnkiLCJ1c2VDcmVhdGVUaHJlYWQiLCJjcmVhdGVUaHJlYWQiLCJib2R5IiwiY3JlYXRlVGhyZWFkSWQiLCJjb21tZW50SWQiLCJjcmVhdGVDb21tZW50SWQiLCJub3ciLCJEYXRlIiwibmV3Q29tbWVudCIsImNyZWF0ZWRBdCIsInR5cGUiLCJ1c2VySWQiLCJnZXRDdXJyZW50VXNlcklkIiwicmVhY3Rpb25zIiwibmV3VGhyZWFkIiwidXNlQ3JlYXRlQ29tbWVudCIsImNyZWF0ZUNvbW1lbnQiLCJjb21tZW50IiwidXNlRWRpdENvbW1lbnQiLCJlZGl0Q29tbWVudCIsImVkaXRlZEF0IiwidXNlRGVsZXRlQ29tbWVudCIsImRlbGV0ZUNvbW1lbnQiLCJuZXdUaHJlYWRzIiwiZGVsZXRlZEF0Iiwic29tZSIsInB1c2giLCJ1c2VBZGRSZWFjdGlvbiIsImVtb2ppIiwicmVhY3Rpb24iLCJ1c2VycyIsImFkZFJlYWN0aW9uIiwidXNlUmVtb3ZlUmVhY3Rpb24iLCJyZWFjdGlvbkluZGV4IiwiZmluZEluZGV4IiwidXNlciIsImxlbmd0aCIsInNwbGljZSIsInJlbW92ZVJlYWN0aW9uIiwiY3JlYXRlT3B0aW1pc3RpY0lkIiwicHJlZml4Iiwic2VsZiIsImdldFNlbGYiLCJtZXNzYWdlIiwiZGV0YWlscyIsImRldGFpbGVkTWVzc2FnZSIsInN1Z2dlc3Rpb24iLCJkb2NzIiwiQm9vbGVhbiIsImpvaW4iLCJjb25zb2xlIiwicmVxdWVzdCIsIm11dGF0aW9uIiwicmV2YWxpZGF0aW9uTWFuYWdlckJ5T3B0aW9ucyIsInJlZmVyZW5jZUNvdW50QnlPcHRpb25zIiwia2V5cyIsImdldCIsImRlbGV0ZSIsInNvcnRlZCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJjb25jYXQiLCJpbmZvIiwiZW50cmllcyIsInNldCIsInJlZHVjZSIsImFjYyIsImNvdW50IiwidGhyZWFkc0V2ZW50U291cmNlIiwiY2FsbGJhY2siLCJzZXRJc0xvYWRpbmciLCJpc0Jyb3dzZXJPbmxpbmUiLCJpc1Jvb21Db25uZWN0ZWQiLCJ1c2VFZmZlY3Q0IiwidXNlUmVmMyIsInVzZVN0YXRlMiIsIkRFRkFVTFRfREVMQVkiLCJ1c2VEZWJvdW5jZSIsImRlbGF5IiwiZGVib3VuY2VkVmFsdWUiLCJzZXREZWJvdW5jZWRWYWx1ZSIsInVzZUNhbGxiYWNrNCIsInVzZUVmZmVjdDUiLCJ1c2VNZW1vMiIsInVzZVJlZjQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTQiLCJ1c2VTdGF0ZTMiLCJ1c2VJbml0aWFsIiwiSU5JVElBTF9BU1lOQ19TVEFURSIsIm5vb3AiLCJ1c2VBc3luY0NhY2hlIiwiZnJvemVuT3B0aW9ucyIsImNhY2hlSXRlbSIsImNhY2hlSXRlbTIiLCJjcmVhdGUiLCJnZXRTdGF0ZSIsInByZXZpb3VzRGF0YSIsInN1c3BlbnNlIiwicmVzb2x2ZSIsInN1YnNjcmliZU9uY2UiLCJzdGF0ZTIiLCJrZWVwUHJldmlvdXNEYXRhV2hpbGVMb2FkaW5nIiwidXNlRWZmZWN0NiIsInVzZVJlZjUiLCJ1c2VMYXRlc3QiLCJyZWYiLCJ1c2VSZWR1Y2VyIiwidXNlUmVyZW5kZXIiLCJ1cGRhdGUiLCJ4Iiwibm9vcDIiLCJpZGVudGl0eSIsIm1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJyZWFjdFZlcnNpb24iLCJKU09OIiwic3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJzIiwiZ3MiLCJnc3MiLCJTVEFCTEVfRU1QVFlfTElTVCIsIk9iamVjdCIsImZyZWV6ZSIsImFsd2F5c0VtcHR5TGlzdCIsImFsd2F5c051bGwiLCJtYWtlTXV0YXRpb25Db250ZXh0IiwiZXJybXNnIiwic3RvcmFnZSIsIm11dGFibGVSb290IiwiZ2V0U3RvcmFnZVNuYXBzaG90Iiwib3RoZXJzIiwiZ2V0T3RoZXJzIiwic2V0TXlQcmVzZW5jZSIsInVwZGF0ZVByZXNlbmNlIiwiaGFzV2FybmVkSWZOb1Jlc29sdmVVc2VycyIsIndhcm5JZk5vUmVzb2x2ZVVzZXJzIiwidXNlcnNDYWNoZSIsInByb2Nlc3MiLCJ3YXJuIiwiQ29udGV4dEJ1bmRsZSIsInVzZVJvb21Db250ZXh0QnVuZGxlIiwiYnVuZGxlIiwiY3JlYXRlUm9vbUNvbnRleHQiLCJjbGllbnQiLCJSb29tQ29udGV4dCIsImNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSIsImNvbW1lbnRzUm9vbSIsIlJvb21Qcm92aWRlck91dGVyIiwic3RhYmxlRW50ZXJSb29tIiwiY2FjaGVkIiwicnYiLCJlbnRlclJvb20iLCJvcmlnTGVhdmUiLCJsZWF2ZSIsIlJvb21Qcm92aWRlcklubmVyIiwibWFqb3JSZWFjdFZlcnNpb24iLCJwYXJzZUludCIsInZlcnNpb24iLCJvbGRSZWFjdFZlcnNpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImZyb3plblByb3BzIiwiaW5pdGlhbFByZXNlbmNlIiwiaW5pdGlhbFN0b3JhZ2UiLCJhdXRvQ29ubmVjdCIsInNob3VsZEluaXRpYWxseUNvbm5lY3QiLCJzZXRSb29tTGVhdmVQYWlyIiwicGFpciIsInJvb20yIiwiY29ubmVjdCIsImludGVybmFsQnVuZGxlIiwiY29ubmVjdGlvbklkU2VsZWN0b3IiLCJjb25uZWN0aW9uSWQiLCJ1c2VSb29tIiwidXNlU3RhdHVzIiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VNeVByZXNlbmNlIiwibXlQcmVzZW5jZSIsImdldFByZXNlbmNlIiwicHJlc2VuY2UiLCJzZXRQcmVzZW5jZSIsInVzZVVwZGF0ZU15UHJlc2VuY2UiLCJ1c2VPdGhlcnMiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJ1c2VPdGhlcnNDb25uZWN0aW9uSWRzIiwidXNlT3RoZXJzTWFwcGVkIiwiaXRlbVNlbGVjdG9yIiwiaXRlbUlzRXF1YWwiLCJ3cmFwcGVkU2VsZWN0b3IiLCJvdGhlciIsIndyYXBwZWRJc0VxdWFsIiwiZXEiLCJpcyIsImV2ZXJ5IiwiYXR1cGxlIiwiaW5kZXgiLCJidHVwbGUiLCJOT1RfRk9VTkQiLCJTeW1ib2wiLCJ1c2VPdGhlciIsIm90aGVyMiIsImZpbmQiLCJvdGhlcjMiLCJwcmV2IiwiY3VyciIsInVzZUJyb2FkY2FzdEV2ZW50IiwiZXZlbnQiLCJzaG91bGRRdWV1ZUV2ZW50SWZOb3RSZWFkeSIsImJyb2FkY2FzdEV2ZW50IiwidXNlT3RoZXJzTGlzdGVuZXIiLCJzYXZlZENhbGxiYWNrIiwidXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lciIsImxvc3RDb25uZWN0aW9uIiwidXNlRXJyb3JMaXN0ZW5lciIsImUiLCJ1c2VFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJldmVudERhdGEiLCJjdXN0b21FdmVudCIsInVzZVNlbGYiLCJtYXliZVNlbGVjdG9yIiwibWUiLCJ1c2VNdXRhYmxlU3RvcmFnZVJvb3QiLCJzdG9yYWdlRGlkTG9hZCIsInVzZVN0b3JhZ2VSb290IiwidXNlSGlzdG9yeSIsImhpc3RvcnkiLCJ1c2VVbmRvIiwidW5kbyIsInVzZVJlZG8iLCJyZWRvIiwidXNlQ2FuVW5kbyIsImNhblVuZG8iLCJ1c2VDYW5SZWRvIiwiY2FuUmVkbyIsInVzZUJhdGNoIiwiYmF0Y2giLCJ1c2VMZWdhY3lLZXkiLCJyb290T3JOdWxsIiwicmVyZW5kZXIiLCJyb290IiwidW5zdWJDdXJyIiwic3Vic2NyaWJlVG9DdXJyIiwib25Sb290Q2hhbmdlIiwibmV3VmFsdWUiLCJ1bnN1YnNjcmliZVJvb3QiLCJ1c2VTdG9yYWdlIiwicm9vdE9yTnVsbDIiLCJpc0RlZXAiLCJpbW0iLCJ0b0ltbXV0YWJsZSIsImVuc3VyZU5vdFNlcnZlclNpZGUiLCJ1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkIiwicmVzIiwidXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQiLCJ1c2VNdXRhdGlvbiIsImRlcHMiLCJhcmdzIiwidXNlU3RvcmFnZVN1c3BlbnNlIiwidXNlU2VsZlN1c3BlbnNlIiwidXNlT3RoZXJzU3VzcGVuc2UiLCJ1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UiLCJ1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSIsInVzZU90aGVyU3VzcGVuc2UiLCJ1c2VMZWdhY3lLZXlTdXNwZW5zZSIsInJlc29sdmVVc2VycyIsInJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJzdHJpbmdpZmllZE9wdGlvbnMiLCJwYXJzZSIsInVzZVVzZXIiLCJyZXNvbHZlcktleSIsInVzZXJJZHMiLCJ1c2VVc2VyU3VzcGVuc2UiLCJtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSIsInVzZU1lbnRpb25TdWdnZXN0aW9ucyIsInNlYXJjaCIsImRlYm91bmNlZFNlYXJjaCIsInRleHQiLCJSb29tUHJvdmlkZXIiLCJ1c2VMaXN0IiwidXNlTWFwIiwidXNlT2JqZWN0IiwiaGFzUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyIsInNoYWxsb3cyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/index.mjs\n");

/***/ })

};
;