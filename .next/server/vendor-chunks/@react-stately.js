"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    let isRequired = !!props.isRequired && selectedValues.length === 0;\n    let invalidValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValues\n    });\n    let isInvalid = validation.displayValidation.isInvalid;\n    var _props_validationState;\n    const state = {\n        ...validation,\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        setInvalid (value, v) {\n            let s = new Map(invalidValues.current);\n            if (v.isInvalid) s.set(value, v);\n            else s.delete(value);\n            invalidValues.current = s;\n            validation.updateValidation((0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.mergeValidation)(...s.values()));\n        },\n        validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? \"invalid\" : null,\n        isInvalid: isInvalid,\n        isRequired: isRequired\n    };\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUk7QUFDbEQ7QUFDdkM7QUFFOUM7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FHRCxTQUFTUSwwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksQ0FBQ0MsZ0JBQWdCQyxTQUFTLEdBQUcsQ0FBQyxHQUFHTixvRUFBd0IsRUFBR0ksTUFBTUcsS0FBSyxFQUFFSCxNQUFNSSxZQUFZLElBQUksRUFBRSxFQUFFSixNQUFNSyxRQUFRO0lBQ3JILElBQUlDLGFBQWEsQ0FBQyxDQUFDTixNQUFNTSxVQUFVLElBQUlMLGVBQWVNLE1BQU0sS0FBSztJQUNqRSxJQUFJQyxnQkFBZ0IsQ0FBQyxHQUFHVix5Q0FBWSxFQUFHLElBQUlXO0lBQzNDLElBQUlDLGFBQWEsQ0FBQyxHQUFHbEIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR1EsS0FBSztRQUNSRyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVUsWUFBWUQsV0FBV0UsaUJBQWlCLENBQUNELFNBQVM7SUFDdEQsSUFBSUU7SUFDSixNQUFNQyxRQUFRO1FBQ1YsR0FBR0osVUFBVTtRQUNiUCxPQUFPRjtRQUNQQyxVQUFVQyxLQUFLO1lBQ1gsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDZCxTQUFTQztRQUNiO1FBQ0FhLFlBQVloQixNQUFNZ0IsVUFBVSxJQUFJO1FBQ2hDRCxZQUFZZixNQUFNZSxVQUFVLElBQUk7UUFDaENFLFlBQVlkLEtBQUs7WUFDYixPQUFPRixlQUFlaUIsUUFBUSxDQUFDZjtRQUNuQztRQUNBZ0IsVUFBVWhCLEtBQUs7WUFDWCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDZixlQUFlaUIsUUFBUSxDQUFDZixRQUFRRCxTQUFTRCxlQUFlbUIsTUFBTSxDQUFDakI7UUFDeEU7UUFDQWtCLGFBQWFsQixLQUFLO1lBQ2QsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDLElBQUlmLGVBQWVpQixRQUFRLENBQUNmLFFBQVFELFNBQVNELGVBQWVxQixNQUFNLENBQUMsQ0FBQ0MsZ0JBQWdCQSxrQkFBa0JwQjtRQUMxRztRQUNBcUIsYUFBYXJCLEtBQUs7WUFDZCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSWYsZUFBZWlCLFFBQVEsQ0FBQ2YsUUFBUUQsU0FBU0QsZUFBZXFCLE1BQU0sQ0FBQyxDQUFDQyxnQkFBZ0JBLGtCQUFrQnBCO2lCQUNqR0QsU0FBU0QsZUFBZW1CLE1BQU0sQ0FBQ2pCO1FBQ3hDO1FBQ0FzQixZQUFZdEIsS0FBSyxFQUFFdUIsQ0FBQztZQUNoQixJQUFJQyxJQUFJLElBQUlsQixJQUFJRCxjQUFjb0IsT0FBTztZQUNyQyxJQUFJRixFQUFFZixTQUFTLEVBQUVnQixFQUFFRSxHQUFHLENBQUMxQixPQUFPdUI7aUJBQ3pCQyxFQUFFRyxNQUFNLENBQUMzQjtZQUNkSyxjQUFjb0IsT0FBTyxHQUFHRDtZQUN4QmpCLFdBQVdxQixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUdyQyxnRUFBcUIsS0FBTWlDLEVBQUVLLE1BQU07UUFDdkU7UUFDQUMsaUJBQWlCLENBQUNwQix5QkFBeUJiLE1BQU1pQyxlQUFlLE1BQU0sUUFBUXBCLDJCQUEyQixLQUFLLElBQUlBLHlCQUF5QkYsWUFBWSxZQUFZO1FBQ25LQSxXQUFXQTtRQUNYTCxZQUFZQTtJQUNoQjtJQUNBLE9BQU9RO0FBQ1g7QUFLNEUsQ0FDNUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2NoZWNrYm94L2Rpc3QvaW1wb3J0Lm1qcz9hOWEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlRm9ybVZhbGlkYXRpb25TdGF0ZSBhcyAkYjNudU8kdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSwgbWVyZ2VWYWxpZGF0aW9uIGFzICRiM251TyRtZXJnZVZhbGlkYXRpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9mb3JtXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkYjNudU8kdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlUmVmIGFzICRiM251TyR1c2VSZWZ9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICQ1ODdkM2FkNThiZTZkMzFmJGV4cG9ydCRkYWZmNmRhNTEwMzJhNDE1KHByb3BzID0ge30pIHtcbiAgICBsZXQgW3NlbGVjdGVkVmFsdWVzLCBzZXRWYWx1ZV0gPSAoMCwgJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBbXSwgcHJvcHMub25DaGFuZ2UpO1xuICAgIGxldCBpc1JlcXVpcmVkID0gISFwcm9wcy5pc1JlcXVpcmVkICYmIHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMDtcbiAgICBsZXQgaW52YWxpZFZhbHVlcyA9ICgwLCAkYjNudU8kdXNlUmVmKShuZXcgTWFwKCkpO1xuICAgIGxldCB2YWxpZGF0aW9uID0gKDAsICRiM251TyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXNcbiAgICB9KTtcbiAgICBsZXQgaXNJbnZhbGlkID0gdmFsaWRhdGlvbi5kaXNwbGF5VmFsaWRhdGlvbi5pc0ludmFsaWQ7XG4gICAgdmFyIF9wcm9wc192YWxpZGF0aW9uU3RhdGU7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIC4uLnZhbGlkYXRpb24sXG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgc2V0VmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZE9ubHk6IHByb3BzLmlzUmVhZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgIGlzU2VsZWN0ZWQgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5maWx0ZXIoKGV4aXN0aW5nVmFsdWUpPT5leGlzdGluZ1ZhbHVlICE9PSB2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVWYWx1ZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pc1JlYWRPbmx5IHx8IHByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmZpbHRlcigoZXhpc3RpbmdWYWx1ZSk9PmV4aXN0aW5nVmFsdWUgIT09IHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlIHNldFZhbHVlKHNlbGVjdGVkVmFsdWVzLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJbnZhbGlkICh2YWx1ZSwgdikge1xuICAgICAgICAgICAgbGV0IHMgPSBuZXcgTWFwKGludmFsaWRWYWx1ZXMuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAodi5pc0ludmFsaWQpIHMuc2V0KHZhbHVlLCB2KTtcbiAgICAgICAgICAgIGVsc2Ugcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgaW52YWxpZFZhbHVlcy5jdXJyZW50ID0gcztcbiAgICAgICAgICAgIHZhbGlkYXRpb24udXBkYXRlVmFsaWRhdGlvbigoMCwgJGIzbnVPJG1lcmdlVmFsaWRhdGlvbikoLi4ucy52YWx1ZXMoKSkpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IChfcHJvcHNfdmFsaWRhdGlvblN0YXRlID0gcHJvcHMudmFsaWRhdGlvblN0YXRlKSAhPT0gbnVsbCAmJiBfcHJvcHNfdmFsaWRhdGlvblN0YXRlICE9PSB2b2lkIDAgPyBfcHJvcHNfdmFsaWRhdGlvblN0YXRlIDogaXNJbnZhbGlkID8gXCJpbnZhbGlkXCIgOiBudWxsLFxuICAgICAgICBpc0ludmFsaWQ6IGlzSW52YWxpZCxcbiAgICAgICAgaXNSZXF1aXJlZDogaXNSZXF1aXJlZFxuICAgIH07XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG5cblxuXG5leHBvcnQgeyQ1ODdkM2FkNThiZTZkMzFmJGV4cG9ydCRkYWZmNmRhNTEwMzJhNDE1IGFzIHVzZUNoZWNrYm94R3JvdXBTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIiRiM251TyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwibWVyZ2VWYWxpZGF0aW9uIiwiJGIzbnVPJG1lcmdlVmFsaWRhdGlvbiIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRiM251TyR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VSZWYiLCIkYjNudU8kdXNlUmVmIiwiJDU4N2QzYWQ1OGJlNmQzMWYkZXhwb3J0JGRhZmY2ZGE1MTAzMmE0MTUiLCJwcm9wcyIsInNlbGVjdGVkVmFsdWVzIiwic2V0VmFsdWUiLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwiaXNSZXF1aXJlZCIsImxlbmd0aCIsImludmFsaWRWYWx1ZXMiLCJNYXAiLCJ2YWxpZGF0aW9uIiwiaXNJbnZhbGlkIiwiZGlzcGxheVZhbGlkYXRpb24iLCJfcHJvcHNfdmFsaWRhdGlvblN0YXRlIiwic3RhdGUiLCJpc1JlYWRPbmx5IiwiaXNEaXNhYmxlZCIsImlzU2VsZWN0ZWQiLCJpbmNsdWRlcyIsImFkZFZhbHVlIiwiY29uY2F0IiwicmVtb3ZlVmFsdWUiLCJmaWx0ZXIiLCJleGlzdGluZ1ZhbHVlIiwidG9nZ2xlVmFsdWUiLCJzZXRJbnZhbGlkIiwidiIsInMiLCJjdXJyZW50Iiwic2V0IiwiZGVsZXRlIiwidXBkYXRlVmFsaWRhdGlvbiIsInZhbHVlcyIsInZhbGlkYXRpb25TdGF0ZSIsInVzZUNoZWNrYm94R3JvdXBTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBRTlEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQU87QUFDWDtBQUNBRCwyQkFBMkJFLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSyxFQUFFRSxPQUFPO0lBQ3JGLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxPQUFPQSxLQUFLLEVBQUVDLFVBQVVBLFFBQVEsRUFBRSxHQUFHTDtJQUNuRSxJQUFJTSxXQUFXTixNQUFNSSxLQUFLLElBQUlKLE1BQU1LLFFBQVE7SUFDNUMsSUFBSUUsWUFBWVAsTUFBTU8sU0FBUyxJQUFLLFFBQU9ELGFBQWEsV0FBV0EsV0FBVyxFQUFDLEtBQU1OLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDNUcscUdBQXFHO0lBQ3JHLElBQUksQ0FBQ08sYUFBYSxDQUFFTCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUU0sd0JBQXdCLEdBQUdDLFFBQVFDLElBQUksQ0FBQztJQUN0SCxNQUFNO1FBQ0ZDLE1BQU07UUFDTlgsT0FBT0E7UUFDUE0sVUFBVUE7UUFDVkMsV0FBV0E7UUFDWCxjQUFjUCxLQUFLLENBQUMsYUFBYTtRQUNqQ1ksZUFBZUMsb0NBQW9DYjtRQUNuRCxDQUFDYztZQUNHLElBQUlYLFlBQVksS0FBSyxJQUFJWSxTQUFTWixXQUFXLE1BQU07Z0JBQy9DUSxNQUFNO2dCQUNOSyxPQUFPRDtZQUNYO2lCQUNLLElBQUlYLE9BQU87Z0JBQ1osSUFBSWEsUUFBUSxFQUFFO2dCQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7b0JBQzFDRSxNQUFNRyxJQUFJLENBQUM7d0JBQ1BULE1B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d2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9ucy9kaXN0L2ltcG9ydC5tanM/MWUwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJHR5VzZBJHJlYWN0LCB7dXNlTWVtbyBhcyAkdHlXNkEkdXNlTWVtb30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbShwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBjaGlsZEl0ZW1zOiBjaGlsZEl0ZW1zLCB0aXRsZTogdGl0bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgbGV0IHJlbmRlcmVkID0gcHJvcHMudGl0bGUgfHwgcHJvcHMuY2hpbGRyZW47XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIHJlbmRlcmVkID09PSBcInN0cmluZ1wiID8gcmVuZGVyZWQgOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcbiAgICAvLyBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcgaXMgdXNlZCBpbiBjb21wb25lbnRzIGxpa2UgVGFicywgd2hpY2ggZG9uJ3QgaGF2ZSB0eXBlIHRvIHNlbGVjdCBzdXBwb3J0LlxuICAgIGlmICghdGV4dFZhbHVlICYmICEoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN1cHByZXNzVGV4dFZhbHVlV2FybmluZykpIGNvbnNvbGUud2FybihcIjxJdGVtPiB3aXRoIG5vbi1wbGFpbiB0ZXh0IGNvbnRlbnRzIGlzIHVuc3VwcG9ydGVkIGJ5IHR5cGUgdG8gc2VsZWN0IGZvciBhY2Nlc3NpYmlsaXR5LiBQbGVhc2UgYWRkIGEgYHRleHRWYWx1ZWAgcHJvcC5cIik7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyhwcm9wcyksXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZEl0ZW1zKSBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZEl0ZW1zKXlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaGFzQ2hpbGRJdGVtcyAhPSBudWxsKSByZXR1cm4gcHJvcHMuaGFzQ2hpbGRJdGVtcztcbiAgICBpZiAocHJvcHMuY2hpbGRJdGVtcykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHByb3BzLnRpdGxlICYmICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJGMxZDdmYjJlYzkxYmFlNzEkZXhwb3J0JDZkMDg3NzNkMmU2NmY4ZjIgPSAkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkOWZjNDg1Mjc3MWQwNzllYiR2YXIkU2VjdGlvbihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24uZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIHRpdGxlOiB0aXRsZSwgaXRlbXM6IGl0ZW1zIH0gPSBwcm9wcztcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwic2VjdGlvblwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgIHJlbmRlcmVkOiB0aXRsZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICR0eVc2QSRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlID0gJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb247XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNsYXNzICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIHtcbiAgICBidWlsZChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGl0ZXJhYmxlKCgpPT50aGlzLml0ZXJhdGVDb2xsZWN0aW9uKHByb3BzKSk7XG4gICAgfVxuICAgICppdGVyYXRlQ29sbGVjdGlvbihwcm9wcykge1xuICAgICAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHByb3BzLml0ZW1zKXlpZWxkKiB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpe1xuICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IHRoaXMuZ2V0RnVsbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEtleShpdGVtLCBwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSkge1xuICAgICAgICBpZiAoaXRlbS5rZXkgIT0gbnVsbCkgcmV0dXJuIGl0ZW0ua2V5O1xuICAgICAgICBpZiAocGFydGlhbE5vZGUudHlwZSA9PT0gXCJjZWxsXCIgJiYgcGFydGlhbE5vZGUua2V5ICE9IG51bGwpIHJldHVybiBgJHtwYXJlbnRLZXl9JHtwYXJ0aWFsTm9kZS5rZXl9YDtcbiAgICAgICAgbGV0IHYgPSBwYXJ0aWFsTm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF92X2tleTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAoX3Zfa2V5ID0gdi5rZXkpICE9PSBudWxsICYmIF92X2tleSAhPT0gdm9pZCAwID8gX3Zfa2V5IDogdi5pZDtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8ga2V5IGZvdW5kIGZvciBpdGVtXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fS4ke3BhcnRpYWxOb2RlLmluZGV4fWAgOiBgJC4ke3BhcnRpYWxOb2RlLmluZGV4fWA7XG4gICAgfVxuICAgIGdldENoaWxkU3RhdGUoc3RhdGUsIHBhcnRpYWxOb2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXJlcjogcGFydGlhbE5vZGUucmVuZGVyZXIgfHwgc3RhdGUucmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmdldEZ1bGxOb2RlKHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSB2YWx1ZSBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgb24gdGhlIG5vZGUsIGFuZCBhIHBhcmVudCByZW5kZXJlciBmdW5jdGlvbiBpcyBhdmFpbGFibGUsXG4gICAgICAgIC8vIHVzZSBpdCB0byByZW5kZXIgYW4gZWxlbWVudCBmb3IgdGhlIHZhbHVlLlxuICAgICAgICBsZXQgZWxlbWVudCA9IHBhcnRpYWxOb2RlLmVsZW1lbnQ7XG4gICAgICAgIGlmICghZWxlbWVudCAmJiBwYXJ0aWFsTm9kZS52YWx1ZSAmJiBzdGF0ZSAmJiBzdGF0ZS5yZW5kZXJlcikge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuY2FjaGUuZ2V0KHBhcnRpYWxOb2RlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgKCFjYWNoZWQuc2hvdWxkSW52YWxpZGF0ZSB8fCAhY2FjaGVkLnNob3VsZEludmFsaWRhdGUodGhpcy5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWQuaW5kZXggPSBwYXJ0aWFsTm9kZS5pbmRleDtcbiAgICAgICAgICAgICAgICBjYWNoZWQucGFyZW50S2V5ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUua2V5IDogbnVsbDtcbiAgICAgICAgICAgICAgICB5aWVsZCBjYWNoZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IHN0YXRlLnJlbmRlcmVyKHBhcnRpYWxOb2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVsZW1lbnQgd2l0aCBhIGdldENvbGxlY3Rpb25Ob2RlIGZ1bmN0aW9uIG9uIGl0cyB0eXBlLCB0aGVuIGl0J3MgYSBzdXBwb3J0ZWQgY29tcG9uZW50LlxuICAgICAgICAvLyBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGEgcGFydGlhbCBub2RlLCBhbmQgcmVjdXJzaXZlbHkgYnVpbGQgYSBmdWxsIG5vZGUgZnJvbSB0aGVyZS5cbiAgICAgICAgaWYgKCgwLCAkdHlXNkEkcmVhY3QpLmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0eXBlLmdldENvbGxlY3Rpb25Ob2RlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnQudHlwZS5uYW1lIDogZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlbGVtZW50IDwke25hbWV9PiBpbiBjb2xsZWN0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB0eXBlLmdldENvbGxlY3Rpb25Ob2RlKGVsZW1lbnQucHJvcHMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJ0aWFsTm9kZS5pbmRleDtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjaGlsZE5vZGVzLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlKCFyZXN1bHQuZG9uZSAmJiByZXN1bHQudmFsdWUpe1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgcGFydGlhbE5vZGUuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUtleSA9IGNoaWxkTm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlS2V5KSBub2RlS2V5ID0gY2hpbGROb2RlLmVsZW1lbnQgPyBudWxsIDogdGhpcy5nZXRLZXkoZWxlbWVudCwgcGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IHRoaXMuZ2V0RnVsbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogbm9kZUtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZShwYXJ0aWFsTm9kZS53cmFwcGVyLCBjaGlsZE5vZGUud3JhcHBlcilcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmdldENoaWxkU3RhdGUoc3RhdGUsIGNoaWxkTm9kZSksIHBhcmVudEtleSA/IGAke3BhcmVudEtleX0ke2VsZW1lbnQua2V5fWAgOiBlbGVtZW50LmtleSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2Rlc1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZHJlbil7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBub2RlIGJhc2VkIG9uIGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gY2hpbGROb2RlLnZhbHVlIHx8IHBhcnRpYWxOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS52YWx1ZSkgdGhpcy5jYWNoZS5zZXQobm9kZS52YWx1ZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJ0aWFsIG5vZGUgbWF5IGhhdmUgc3BlY2lmaWVkIGEgdHlwZSBmb3IgdGhlIGNoaWxkIGluIG9yZGVyIHRvIHNwZWNpZnkgYSBjb25zdHJhaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgZnVsbCBub2RlIHRoYXQgd2FzIGJ1aWx0IHJlY3Vyc2l2ZWx5IG1hdGNoZXMgdGhpcyB0eXBlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGlhbE5vZGUudHlwZSAmJiBub2RlLnR5cGUgIT09IHBhcnRpYWxOb2RlLnR5cGUpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShub2RlLnR5cGUpfT4gaW4gPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUocGFyZW50Tm9kZS50eXBlKX0+LiBPbmx5IDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcnRpYWxOb2RlLnR5cGUpfT4gaXMgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGlsZE5vZGVzLm5leHQoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIGVsZW1lbnRzXG4gICAgICAgIGlmIChwYXJ0aWFsTm9kZS5rZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgZnVsbCBub2RlXG4gICAgICAgIGxldCBidWlsZGVyID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBwYXJ0aWFsTm9kZS50eXBlLFxuICAgICAgICAgICAgcHJvcHM6IHBhcnRpYWxOb2RlLnByb3BzLFxuICAgICAgICAgICAga2V5OiBwYXJ0aWFsTm9kZS5rZXksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGwsXG4gICAgICAgICAgICB2YWx1ZTogcGFydGlhbE5vZGUudmFsdWUsXG4gICAgICAgICAgICBsZXZlbDogcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUubGV2ZWwgKyAxIDogMCxcbiAgICAgICAgICAgIGluZGV4OiBwYXJ0aWFsTm9kZS5pbmRleCxcbiAgICAgICAgICAgIHJlbmRlcmVkOiBwYXJ0aWFsTm9kZS5yZW5kZXJlZCxcbiAgICAgICAgICAgIHRleHRWYWx1ZTogcGFydGlhbE5vZGUudGV4dFZhbHVlLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBhcnRpYWxOb2RlW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgICAgIHdyYXBwZXI6IHBhcnRpYWxOb2RlLndyYXBwZXIsXG4gICAgICAgICAgICBzaG91bGRJbnZhbGlkYXRlOiBwYXJ0aWFsTm9kZS5zaG91bGRJbnZhbGlkYXRlLFxuICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcyxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6ICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZShmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsTm9kZS5oYXNDaGlsZE5vZGVzKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBwYXJ0aWFsTm9kZS5jaGlsZE5vZGVzKCkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY2hpbGQga2V5cyBhcmUgZ2xvYmFsbHkgdW5pcXVlIGJ5IHByZXBlbmRpbmcgdGhlIHBhcmVudCBub2RlJ3Mga2V5XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbGluZSBlbnRpcmVseSBhbmQgZW5mb3JjZSB0aGF0IHVzZXJzIGFsd2F5cyBwcm92aWRlIHVuaXF1ZSBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgdGhpcyBsaW5lIHdpbGwgaGF2ZSBpc3N1ZXMgd2hlbiBhIHBhcmVudCBoYXMgYSBrZXkgYGFgIGFuZCBhIGNoaWxkIHdpdGgga2V5IGBiY2BcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGFub3RoZXIgcGFyZW50IGhhcyBrZXkgYGFiYCBhbmQgaXRzIGNoaWxkIGhhcyBhIGtleSBgY2AuIFRoZSBjb21iaW5lZCBrZXlzIHdvdWxkIHJlc3VsdCBpbiBib3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkcmVuIGhhdmluZyBhIGtleSBvZiBgYWJjYC5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQua2V5ID0gYCR7bm9kZS5rZXl9JHtjaGlsZC5rZXl9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5nZXRGdWxsTm9kZShjaGlsZCwgYnVpbGRlci5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZCksIG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHlpZWxkIG5vZGU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbn1cbi8vIFdyYXBzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIGFuIGl0ZXJhYmxlIG9iamVjdCwgYW5kIGNhY2hlcyB0aGUgcmVzdWx0cy5cbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZShpdGVyYXRvcikge1xuICAgIGxldCBjYWNoZSA9IFtdO1xuICAgIGxldCBpdGVyYWJsZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY2FjaGUpeWllbGQgaXRlbTtcbiAgICAgICAgICAgIGlmICghaXRlcmFibGUpIGl0ZXJhYmxlID0gaXRlcmF0b3IoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmFibGUpe1xuICAgICAgICAgICAgICAgIGNhY2hlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZShvdXRlciwgaW5uZXIpIHtcbiAgICBpZiAob3V0ZXIgJiYgaW5uZXIpIHJldHVybiAoZWxlbWVudCk9Pm91dGVyKGlubmVyKGVsZW1lbnQpKTtcbiAgICBpZiAob3V0ZXIpIHJldHVybiBvdXRlcjtcbiAgICBpZiAoaW5uZXIpIHJldHVybiBpbm5lcjtcbn1cbmZ1bmN0aW9uICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5cbmZ1bmN0aW9uICQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5KHByb3BzLCBmYWN0b3J5LCBjb250ZXh0KSB7XG4gICAgbGV0IGJ1aWxkZXIgPSAoMCwgJHR5VzZBJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxKSgpLCBbXSk7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24gfSA9IHByb3BzO1xuICAgIGxldCByZXN1bHQgPSAoMCwgJHR5VzZBJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRlci5idWlsZCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICBpdGVtczogaXRlbXNcbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KG5vZGVzKTtcbiAgICB9LCBbXG4gICAgICAgIGJ1aWxkZXIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZmFjdG9yeVxuICAgIF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyhub2RlLCBjb2xsZWN0aW9uKSB7XG4gICAgLy8gTmV3IEFQSTogY2FsbCBjb2xsZWN0aW9uLmdldENoaWxkcmVuIHdpdGggdGhlIG5vZGUga2V5LlxuICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29sbGVjdGlvbi5nZXRDaGlsZHJlbihub2RlLmtleSk7XG4gICAgLy8gT2xkIEFQSTogYWNjZXNzIGNoaWxkTm9kZXMgZGlyZWN0bHkuXG4gICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlcztcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCRmYmRlYWE2YTc2Njk0ZjcxKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyKGl0ZXJhYmxlLCAwKTtcbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyKGl0ZXJhYmxlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmFibGUpe1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHJldHVybiBpdGVtO1xuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDc0NzViMmM2NDUzOWU0Y2YoaXRlcmFibGUpIHtcbiAgICBsZXQgbGFzdEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpbGFzdEl0ZW0gPSB2YWx1ZTtcbiAgICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2KGNvbGxlY3Rpb24sIGEsIGIpIHtcbiAgICAvLyBJZiB0aGUgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50LCBjb21wYXJlIHRoZWlyIGluZGljZXMuXG4gICAgaWYgKGEucGFyZW50S2V5ID09PSBiLnBhcmVudEtleSkgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgIC8vIE90aGVyd2lzZSwgY29sbGVjdCBhbGwgb2YgdGhlIGFuY2VzdG9ycyBmcm9tIGVhY2ggbm9kZSwgYW5kIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGRvZXNuJ3QgbWF0Y2ggc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAvLyBJbmNsdWRlIHRoZSBiYXNlIG5vZGVzIGluIGNhc2Ugd2UgYXJlIGNvbXBhcmluZyBub2RlcyBvZiBkaWZmZXJlbnQgbGV2ZWxzIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgdGhlIGhpZ2hlciBub2RlIHRvIHRoZSBsb3dlciBsZXZlbCBub2RlJ3NcbiAgICAvLyBhbmNlc3RvciBvZiB0aGUgc2FtZSBsZXZlbFxuICAgIGxldCBhQW5jZXN0b3JzID0gW1xuICAgICAgICAuLi4kYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIGEpLFxuICAgICAgICBhXG4gICAgXTtcbiAgICBsZXQgYkFuY2VzdG9ycyA9IFtcbiAgICAgICAgLi4uJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBiKSxcbiAgICAgICAgYlxuICAgIF07XG4gICAgbGV0IGZpcnN0Tm9uTWF0Y2hpbmdBbmNlc3RvciA9IGFBbmNlc3RvcnMuc2xpY2UoMCwgYkFuY2VzdG9ycy5sZW5ndGgpLmZpbmRJbmRleCgoYSwgaSk9PmEgIT09IGJBbmNlc3RvcnNbaV0pO1xuICAgIGlmIChmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IgIT09IC0xKSB7XG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGluZGljZXMgb2YgdHdvIGNoaWxkcmVuIHdpdGhpbiB0aGUgY29tbW9uIGFuY2VzdG9yLlxuICAgICAgICBhID0gYUFuY2VzdG9yc1tmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3JdO1xuICAgICAgICBiID0gYkFuY2VzdG9yc1tmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3JdO1xuICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzbid0IGEgbm9uIG1hdGNoaW5nIGFuY2VzdG9yLCB3ZSBtaWdodCBiZSBpbiBhIGNhc2Ugd2hlcmUgb25lIG9mIHRoZSBub2RlcyBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIG90aGVyLlxuICAgIGlmIChhQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGIpID49IDApIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGJBbmNlc3RvcnMuZmluZEluZGV4KChub2RlKT0+bm9kZSA9PT0gYSkgPj0gMCkgcmV0dXJuIC0xO1xuICAgIC8vIPCfpLdcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiR2YXIkZ2V0QW5jZXN0b3JzKGNvbGxlY3Rpb24sIG5vZGUpIHtcbiAgICBsZXQgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUucGFyZW50S2V5KSAhPSBudWxsKXtcbiAgICAgICAgbm9kZSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShub2RlLnBhcmVudEtleSk7XG4gICAgICAgIHBhcmVudHMudW5zaGlmdChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cblxuY29uc3QgJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uICQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgY291bnQgPSAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUuZ2V0KGNvbGxlY3Rpb24pO1xuICAgIGlmIChjb3VudCAhPSBudWxsKSByZXR1cm4gY291bnQ7XG4gICAgY291bnQgPSAwO1xuICAgIGxldCBjb3VudEl0ZW1zID0gKGl0ZW1zKT0+e1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKWlmIChpdGVtLnR5cGUgPT09IFwic2VjdGlvblwiKSBjb3VudEl0ZW1zKCgwLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMykoaXRlbSwgY29sbGVjdGlvbikpO1xuICAgICAgICBlbHNlIGNvdW50Kys7XG4gICAgfTtcbiAgICBjb3VudEl0ZW1zKGNvbGxlY3Rpb24pO1xuICAgICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZS5zZXQoY29sbGVjdGlvbiwgY291bnQpO1xuICAgIHJldHVybiBjb3VudDtcbn1cblxuXG5cblxuXG5cbmV4cG9ydCB7JGMxZDdmYjJlYzkxYmFlNzEkZXhwb3J0JDZkMDg3NzNkMmU2NmY4ZjIgYXMgSXRlbSwgJDlmYzQ4NTI3NzFkMDc5ZWIkZXhwb3J0JDZlMmM4ZjA4MTFhNDc0Y2UgYXMgU2VjdGlvbiwgJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkgYXMgdXNlQ29sbGVjdGlvbiwgJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIgYXMgZ2V0SXRlbUNvdW50LCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyBhcyBnZXRDaGlsZE5vZGVzLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MSBhcyBnZXRGaXJzdEl0ZW0sICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmIGFzIGdldExhc3RJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMiBhcyBnZXROdGhJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2IGFzIGNvbXBhcmVOb2RlT3JkZXIsICRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIGFzIENvbGxlY3Rpb25CdWlsZGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyIkdHlXNkEkcmVhY3QiLCJ1c2VNZW1vIiwiJHR5VzZBJHVzZU1lbW8iLCIkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkSXRlbSIsInByb3BzIiwiZ2V0Q29sbGVjdGlvbk5vZGUiLCJjb250ZXh0IiwiY2hpbGRJdGVtcyIsInRpdGxlIiwiY2hpbGRyZW4iLCJyZW5kZXJlZCIsInRleHRWYWx1ZSIsInN1cHByZXNzVGV4dFZhbHVlV2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwidHlwZSIsImhhc0NoaWxkTm9kZXMiLCIkYzFkN2ZiMmVjOTFiYWU3MSR2YXIkaGFzQ2hpbGRJdGVtcyIsImNoaWxkTm9kZXMiLCJjaGlsZCIsInZhbHVlIiwiaXRlbXMiLCJDaGlsZHJlbiIsImZvckVhY2giLCJwdXNoIiwiZWxlbWVudCIsImhhc0NoaWxkSXRlbXMiLCJjb3VudCIsIiRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyIiwiJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24iLCJFcnJvciIsIml0ZW0iLCJyZW5kZXJlciIsIiQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlIiwiJGViMjI0MGZjMzlhNTdmYTUkZXhwb3J0JGJmNzg4ZGQzNTVlM2E0MDEiLCJidWlsZCIsIiRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZSIsIml0ZXJhdGVDb2xsZWN0aW9uIiwiZ2V0RnVsbE5vZGUiLCJpbmRleCIsIm5vZGVzIiwibm9kZSIsImdldEtleSIsInBhcnRpYWxOb2RlIiwic3RhdGUiLCJwYXJlbnRLZXkiLCJrZXkiLCJ2IiwiX3Zfa2V5IiwiaWQiLCJnZXRDaGlsZFN0YXRlIiwicGFyZW50Tm9kZSIsImNhY2hlZCIsImNhY2hlIiwiZ2V0Iiwic2hvdWxkSW52YWxpZGF0ZSIsImlzVmFsaWRFbGVtZW50IiwibmFtZSIsInJlc3VsdCIsIm5leHQiLCJkb25lIiwiY2hpbGROb2RlIiwibm9kZUtleSIsIndyYXBwZXIiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY29tcG9zZSIsInNldCIsIiRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplIiwiYnVpbGRlciIsImxldmVsIiwiY29uc3RydWN0b3IiLCJXZWFrTWFwIiwiaXRlcmF0b3IiLCJpdGVyYWJsZSIsIlN5bWJvbCIsIm91dGVyIiwiaW5uZXIiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiJDc2MTNiMTU5MmQ0MWIwOTIkZXhwb3J0JDZjZDI4ODE0ZDkyZmE5YzkiLCJmYWN0b3J5IiwiY29sbGVjdGlvbiIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQxMDA1NTMwZWRhMDE2YzEzIiwiZ2V0Q2hpbGRyZW4iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MSIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ1ZjMzOThmODczM2Y5MGUyIiwidW5kZWZpbmVkIiwiaSIsIiRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmIiwibGFzdEl0ZW0iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkOGM0MzRiM2E3YTRkYWQ2IiwiYSIsImIiLCJhQW5jZXN0b3JzIiwiJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyIsImJBbmNlc3RvcnMiLCJmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IiLCJsZW5ndGgiLCJmaW5kSW5kZXgiLCJwYXJlbnRzIiwiZ2V0SXRlbSIsInVuc2hpZnQiLCIkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUiLCIkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMiIsImNvdW50SXRlbXMiLCJJdGVtIiwiU2VjdGlvbiIsInVzZUNvbGxlY3Rpb24iLCJnZXRJdGVtQ291bnQiLCJnZXRDaGlsZE5vZGVzIiwiZ2V0Rmlyc3RJdGVtIiwiZ2V0TGFzdEl0ZW0iLCJnZXROdGhJdGVtIiwiY29tcGFyZU5vZGVPcmRlciIsIkNvbGxlY3Rpb25CdWlsZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/combobox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComboBoxState: () => (/* binding */ $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {\n    var _collection_getItem, _collection_getItem1;\n    let { defaultFilter: defaultFilter, menuTrigger: menuTrigger = \"input\", allowsEmptyCollection: allowsEmptyCollection = false, allowsCustomValue: allowsCustomValue, shouldCloseOnBlur: shouldCloseOnBlur = true } = props;\n    let [showAllItems, setShowAllItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocused, setFocusedState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let onSelectionChange = (key)=>{\n        if (props.onSelectionChange) props.onSelectionChange(key);\n        // If key is the same, reset the inputValue and close the menu\n        // (scenario: user clicks on already selected option)\n        if (key === selectedKey) {\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    var _props_items;\n    let { collection: collection, selectionManager: selectionManager, selectedKey: selectedKey, setSelectedKey: setSelectedKey, selectedItem: selectedItem, disabledKeys: disabledKeys } = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        onSelectionChange: onSelectionChange,\n        items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems\n    });\n    var _props_defaultInputValue, _ref;\n    let [inputValue, setInputValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : \"\", props.onInputChange);\n    // Preserve original collection so we can show all items on demand\n    let originalCollection = collection;\n    let filteredCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [\n        collection,\n        inputValue,\n        defaultFilter,\n        props.items\n    ]);\n    let [lastCollection, setLastCollection] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(filteredCollection);\n    // Track what action is attempting to open the menu\n    let menuOpenTrigger = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"focus\");\n    let onOpenChange = (open)=>{\n        if (props.onOpenChange) props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n        selectionManager.setFocused(open);\n        if (!open) selectionManager.setFocusedKey(null);\n    };\n    let triggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__.useOverlayTriggerState)({\n        ...props,\n        onOpenChange: onOpenChange,\n        isOpen: undefined,\n        defaultOpen: undefined\n    });\n    let open = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // Prevent open operations from triggering if there is nothing to display\n        // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n        // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n        if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {\n            if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n            menuOpenTrigger.current = trigger;\n            setFocusStrategy(focusStrategy);\n            triggerState.open();\n        }\n    };\n    let toggle = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n        if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;\n        if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n        // Only update the menuOpenTrigger if menu is currently closed\n        if (!triggerState.isOpen) menuOpenTrigger.current = trigger;\n        toggleMenu(focusStrategy);\n    };\n    let updateLastCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setLastCollection(showAllItems ? originalCollection : filteredCollection);\n    }, [\n        showAllItems,\n        originalCollection,\n        filteredCollection\n    ]);\n    // If menu is going to close, save the current collection so we can freeze the displayed collection when the\n    // user clicks outside the popover to close the menu. Prevents the menu contents from updating as the menu closes.\n    let toggleMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        if (triggerState.isOpen) updateLastCollection();\n        setFocusStrategy(focusStrategy);\n        triggerState.toggle();\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let closeMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (triggerState.isOpen) {\n            updateLastCollection();\n            triggerState.close();\n        }\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(inputValue);\n    let resetInputValue = ()=>{\n        var _collection_getItem;\n        var _collection_getItem_textValue;\n        let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        setLastValue(itemText);\n        setInputValue(itemText);\n    };\n    var _props_selectedKey, _ref1;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);\n    var _collection_getItem_textValue;\n    let lastSelectedKeyText = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\");\n    // intentional omit dependency array, want this to happen on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _collection_getItem;\n        // Open and close menu automatically when the input value changes if the input is focused,\n        // and there are items in the collection or allowEmptyCollection is true.\n        if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== \"manual\") open(null, \"input\");\n        // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n        // but we are currently showing all items via button press\n        if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();\n        // Close when an item is selected.\n        if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();\n        // Clear focused key when input value changes and display filtered collection again.\n        if (inputValue !== lastValue) {\n            selectionManager.setFocusedKey(null);\n            setShowAllItems(false);\n            // Set selectedKey to null when the user clears the input.\n            // If controlled, this is the application developer's responsibility.\n            if (inputValue === \"\" && (props.inputValue === undefined || props.selectedKey === undefined)) setSelectedKey(null);\n        }\n        // If the selectedKey changed, update the input value.\n        // Do nothing if both inputValue and selectedKey are controlled.\n        // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n        if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) resetInputValue();\n        else if (lastValue !== inputValue) setLastValue(inputValue);\n        var _collection_getItem_textValue;\n        // Update the inputValue if the selected item's text changes from its last tracked value.\n        // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n        // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n        // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n        let selectedItemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n            if (lastSelectedKeyText.current !== selectedItemText) {\n                setLastValue(selectedItemText);\n                setInputValue(selectedItemText);\n            }\n        }\n        lastSelectedKey.current = selectedKey;\n        lastSelectedKeyText.current = selectedItemText;\n    });\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_4__.useFormValidationState)({\n        ...props,\n        value: (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                inputValue: inputValue,\n                selectedKey: selectedKey\n            }), [\n            inputValue,\n            selectedKey\n        ])\n    });\n    // Revert input value and close menu\n    let revert = ()=>{\n        if (allowsCustomValue && selectedKey == null) commitCustomValue();\n        else commitSelection();\n    };\n    let commitCustomValue = ()=>{\n        lastSelectedKey.current = null;\n        setSelectedKey(null);\n        closeMenu();\n    };\n    let commitSelection = ()=>{\n        // If multiple things are controlled, call onSelectionChange\n        if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n            var _collection_getItem;\n            props.onSelectionChange(selectedKey);\n            var _collection_getItem_textValue;\n            // Stop menu from reopening from useEffect\n            let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            setLastValue(itemText);\n            closeMenu();\n        } else {\n            // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    const commitValue = ()=>{\n        if (allowsCustomValue) {\n            var _collection_getItem;\n            var _collection_getItem_textValue;\n            const itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            inputValue === itemText ? commitSelection() : commitCustomValue();\n        } else commitSelection();\n    };\n    let commit = ()=>{\n        if (triggerState.isOpen && selectionManager.focusedKey != null) {\n            // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n            // fire onSelectionChange to allow the application to control the closing.\n            if (selectedKey === selectionManager.focusedKey) commitSelection();\n            else setSelectedKey(selectionManager.focusedKey);\n        } else commitValue();\n    };\n    let valueOnFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(inputValue);\n    let setFocused = (isFocused)=>{\n        if (isFocused) {\n            valueOnFocus.current = inputValue;\n            if (menuTrigger === \"focus\") open(null, \"focus\");\n        } else {\n            if (shouldCloseOnBlur) commitValue();\n            if (inputValue !== valueOnFocus.current) validation.commitValidation();\n        }\n        setFocusedState(isFocused);\n    };\n    let displayedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (triggerState.isOpen) {\n            if (showAllItems) return originalCollection;\n            else return filteredCollection;\n        } else return lastCollection;\n    }, [\n        triggerState.isOpen,\n        originalCollection,\n        filteredCollection,\n        showAllItems,\n        lastCollection\n    ]);\n    return {\n        ...validation,\n        ...triggerState,\n        focusStrategy: focusStrategy,\n        toggle: toggle,\n        open: open,\n        close: commitValue,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        disabledKeys: disabledKeys,\n        isFocused: isFocused,\n        setFocused: setFocused,\n        selectedItem: selectedItem,\n        collection: displayedCollection,\n        inputValue: inputValue,\n        setInputValue: setInputValue,\n        commit: commit,\n        revert: revert\n    };\n}\nfunction $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {\n    return new (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.ListCollection)($a9e7382a7d111cb5$var$filterNodes(collection, collection, inputValue, filter));\n}\nfunction $a9e7382a7d111cb5$var$filterNodes(collection, nodes, inputValue, filter) {\n    let filteredNode = [];\n    for (let node of nodes){\n        if (node.type === \"section\" && node.hasChildNodes) {\n            let filtered = $a9e7382a7d111cb5$var$filterNodes(collection, (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__.getChildNodes)(node, collection), inputValue, filter);\n            if ([\n                ...filtered\n            ].some((node)=>node.type === \"item\")) filteredNode.push({\n                ...node,\n                childNodes: filtered\n            });\n        } else if (node.type === \"item\" && filter(node.textValue, inputValue)) filteredNode.push({\n            ...node\n        });\n        else if (node.type !== \"item\") filteredNode.push({\n            ...node\n        });\n    }\n    return filteredNode;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEY7QUFDWDtBQUN3RDtBQUMrQjtBQUNuRjtBQUNXO0FBRWhHOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBTUQsU0FBU3NCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxxQkFBcUJDO0lBQ3pCLElBQUksRUFBRUMsZUFBZUEsYUFBYSxFQUFFQyxhQUFhQSxjQUFjLE9BQU8sRUFBRUMsdUJBQXVCQSx3QkFBd0IsS0FBSyxFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxtQkFBbUJBLG9CQUFvQixJQUFJLEVBQUUsR0FBR1A7SUFDcE4sSUFBSSxDQUFDUSxjQUFjQyxnQkFBZ0IsR0FBRyxDQUFDLEdBQUd2QiwyQ0FBYyxFQUFHO0lBQzNELElBQUksQ0FBQ3dCLFdBQVdDLGdCQUFnQixHQUFHLENBQUMsR0FBR3pCLDJDQUFjLEVBQUc7SUFDeEQsSUFBSSxDQUFDMEIsZUFBZUMsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHM0IsMkNBQWMsRUFBRztJQUM3RCxJQUFJNEIsb0JBQW9CLENBQUNDO1FBQ3JCLElBQUlmLE1BQU1jLGlCQUFpQixFQUFFZCxNQUFNYyxpQkFBaUIsQ0FBQ0M7UUFDckQsOERBQThEO1FBQzlELHFEQUFxRDtRQUNyRCxJQUFJQSxRQUFRQyxhQUFhO1lBQ3JCQztZQUNBQztRQUNKO0lBQ0o7SUFDQSxJQUFJQztJQUNKLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFTCxhQUFhQSxXQUFXLEVBQUVNLGdCQUFnQkEsY0FBYyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLGNBQWNBLFlBQVksRUFBRSxHQUFHLENBQUMsR0FBRzFDLHlFQUE4QixFQUFHO1FBQ3hOLEdBQUdrQixLQUFLO1FBQ1JjLG1CQUFtQkE7UUFDbkJXLE9BQU8sQ0FBQ04sZUFBZW5C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QUMsQ0FBQ0osT0FBT0EsS0FBS0MsSUFBSSxLQUFLLFNBQVNGLGFBQWFNLElBQUksQ0FBQztnQkFDcEQsR0FBR0wsSUFBSTtnQkFDUE0sWUFBWUg7WUFDaEI7UUFDSixPQUFPLElBQUlILEtBQUtDLElBQUksS0FBSyxVQUFVTCxPQUFPSSxLQUFLakQsU0FBUyxFQUFFSixhQUFhb0QsYUFBYU0sSUFBSSxDQUFDO1lBQ3JGLEdBQUdMLElBQUk7UUFDWDthQUNLLElBQUlBLEtBQUtDLElBQUksS0FBSyxRQUFRRixhQUFhTSxJQUFJLENBQUM7WUFDN0MsR0FBR0wsSUFBSTtRQUNYO0lBQ0o7SUFDQSxPQUFPRDtBQUNYO0FBS3VFLENBQ3ZFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9jb21ib2JveC9kaXN0L2ltcG9ydC5tanM/Y2I4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUZvcm1WYWxpZGF0aW9uU3RhdGUgYXMgJGs2UHB1JHVzZUZvcm1WYWxpZGF0aW9uU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9mb3JtXCI7XG5pbXBvcnQge2dldENoaWxkTm9kZXMgYXMgJGs2UHB1JGdldENoaWxkTm9kZXN9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUgYXMgJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSwgTGlzdENvbGxlY3Rpb24gYXMgJGs2UHB1JExpc3RDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvbGlzdFwiO1xuaW1wb3J0IHt1c2VTdGF0ZSBhcyAkazZQcHUkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJGs2UHB1JHVzZU1lbW8sIHVzZVJlZiBhcyAkazZQcHUkdXNlUmVmLCB1c2VDYWxsYmFjayBhcyAkazZQcHUkdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCBhcyAkazZQcHUkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRrNlBwdSR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VPdmVybGF5VHJpZ2dlclN0YXRlIGFzICRrNlBwdSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICogXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZnVuY3Rpb24gJGE5ZTczODJhN2QxMTFjYjUkZXhwb3J0JGI0NTNhM2JmZDRhNWZhOWUocHJvcHMpIHtcbiAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbSwgX2NvbGxlY3Rpb25fZ2V0SXRlbTE7XG4gICAgbGV0IHsgZGVmYXVsdEZpbHRlcjogZGVmYXVsdEZpbHRlciwgbWVudVRyaWdnZXI6IG1lbnVUcmlnZ2VyID0gXCJpbnB1dFwiLCBhbGxvd3NFbXB0eUNvbGxlY3Rpb246IGFsbG93c0VtcHR5Q29sbGVjdGlvbiA9IGZhbHNlLCBhbGxvd3NDdXN0b21WYWx1ZTogYWxsb3dzQ3VzdG9tVmFsdWUsIHNob3VsZENsb3NlT25CbHVyOiBzaG91bGRDbG9zZU9uQmx1ciA9IHRydWUgfSA9IHByb3BzO1xuICAgIGxldCBbc2hvd0FsbEl0ZW1zLCBzZXRTaG93QWxsSXRlbXNdID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBbaXNGb2N1c2VkLCBzZXRGb2N1c2VkU3RhdGVdID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgb25TZWxlY3Rpb25DaGFuZ2UgPSAoa2V5KT0+e1xuICAgICAgICBpZiAocHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKGtleSk7XG4gICAgICAgIC8vIElmIGtleSBpcyB0aGUgc2FtZSwgcmVzZXQgdGhlIGlucHV0VmFsdWUgYW5kIGNsb3NlIHRoZSBtZW51XG4gICAgICAgIC8vIChzY2VuYXJpbzogdXNlciBjbGlja3Mgb24gYWxyZWFkeSBzZWxlY3RlZCBvcHRpb24pXG4gICAgICAgIGlmIChrZXkgPT09IHNlbGVjdGVkS2V5KSB7XG4gICAgICAgICAgICByZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgIGNsb3NlTWVudSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3Byb3BzX2l0ZW1zO1xuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsIHNlbGVjdGVkS2V5OiBzZWxlY3RlZEtleSwgc2V0U2VsZWN0ZWRLZXk6IHNldFNlbGVjdGVkS2V5LCBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbSwgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMgfSA9ICgwLCAkazZQcHUkdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICAgIGl0ZW1zOiAoX3Byb3BzX2l0ZW1zID0gcHJvcHMuaXRlbXMpICE9PSBudWxsICYmIF9wcm9wc19pdGVtcyAhPT0gdm9pZCAwID8gX3Byb3BzX2l0ZW1zIDogcHJvcHMuZGVmYXVsdEl0ZW1zXG4gICAgfSk7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSwgX3JlZjtcbiAgICBsZXQgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gKDAsICRrNlBwdSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLmlucHV0VmFsdWUsIChfcmVmID0gKF9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSA9IHByb3BzLmRlZmF1bHRJbnB1dFZhbHVlKSAhPT0gbnVsbCAmJiBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0SW5wdXRWYWx1ZSA6IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBcIlwiLCBwcm9wcy5vbklucHV0Q2hhbmdlKTtcbiAgICAvLyBQcmVzZXJ2ZSBvcmlnaW5hbCBjb2xsZWN0aW9uIHNvIHdlIGNhbiBzaG93IGFsbCBpdGVtcyBvbiBkZW1hbmRcbiAgICBsZXQgb3JpZ2luYWxDb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICBsZXQgZmlsdGVyZWRDb2xsZWN0aW9uID0gKDAsICRrNlBwdSR1c2VNZW1vKSgoKT0+Ly8gTm8gZGVmYXVsdCBmaWx0ZXIgaWYgaXRlbXMgYXJlIGNvbnRyb2xsZWQuXG4gICAgICAgIHByb3BzLml0ZW1zICE9IG51bGwgfHwgIWRlZmF1bHRGaWx0ZXIgPyBjb2xsZWN0aW9uIDogJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlckNvbGxlY3Rpb24oY29sbGVjdGlvbiwgaW5wdXRWYWx1ZSwgZGVmYXVsdEZpbHRlciksIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgZGVmYXVsdEZpbHRlcixcbiAgICAgICAgcHJvcHMuaXRlbXNcbiAgICBdKTtcbiAgICBsZXQgW2xhc3RDb2xsZWN0aW9uLCBzZXRMYXN0Q29sbGVjdGlvbl0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShmaWx0ZXJlZENvbGxlY3Rpb24pO1xuICAgIC8vIFRyYWNrIHdoYXQgYWN0aW9uIGlzIGF0dGVtcHRpbmcgdG8gb3BlbiB0aGUgbWVudVxuICAgIGxldCBtZW51T3BlblRyaWdnZXIgPSAoMCwgJGs2UHB1JHVzZVJlZikoXCJmb2N1c1wiKTtcbiAgICBsZXQgb25PcGVuQ2hhbmdlID0gKG9wZW4pPT57XG4gICAgICAgIGlmIChwcm9wcy5vbk9wZW5DaGFuZ2UpIHByb3BzLm9uT3BlbkNoYW5nZShvcGVuLCBvcGVuID8gbWVudU9wZW5UcmlnZ2VyLmN1cnJlbnQgOiB1bmRlZmluZWQpO1xuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLnNldEZvY3VzZWQob3Blbik7XG4gICAgICAgIGlmICghb3Blbikgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgIH07XG4gICAgbGV0IHRyaWdnZXJTdGF0ZSA9ICgwLCAkazZQcHUkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb25PcGVuQ2hhbmdlOiBvbk9wZW5DaGFuZ2UsXG4gICAgICAgIGlzT3BlbjogdW5kZWZpbmVkLFxuICAgICAgICBkZWZhdWx0T3BlbjogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgbGV0IG9wZW4gPSAoZm9jdXNTdHJhdGVneSA9IG51bGwsIHRyaWdnZXIpPT57XG4gICAgICAgIGxldCBkaXNwbGF5QWxsSXRlbXMgPSB0cmlnZ2VyID09PSBcIm1hbnVhbFwiIHx8IHRyaWdnZXIgPT09IFwiZm9jdXNcIiAmJiBtZW51VHJpZ2dlciA9PT0gXCJmb2N1c1wiO1xuICAgICAgICAvLyBQcmV2ZW50IG9wZW4gb3BlcmF0aW9ucyBmcm9tIHRyaWdnZXJpbmcgaWYgdGhlcmUgaXMgbm90aGluZyB0byBkaXNwbGF5XG4gICAgICAgIC8vIEFsc28gcHJldmVudCBvcGVuIG9wZXJhdGlvbnMgZnJvbSB0cmlnZ2VyaW5nIGlmIGl0ZW1zIGFyZSB1bmNvbnRyb2xsZWQgYnV0IGRlZmF1bHRJdGVtcyBpcyBlbXB0eSwgZXZlbiBpZiBkaXNwbGF5QWxsSXRlbXMgaXMgdHJ1ZS5cbiAgICAgICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IGNvbWJvYm94ZXMgd2l0aCBlbXB0eSBkZWZhdWx0SXRlbXMgZnJvbSBvcGVuaW5nIGJ1dCBhbGxvdyBjb250cm9sbGVkIGl0ZW1zIGNvbWJvYm94ZXMgdG8gb3BlbiBldmVuIGlmIHRoZSBpbml0YWwgbGlzdCBpcyBlbXB0eSAoYXNzdW1wdGlvbiBpcyB1c2VyIHdpbGwgcHJvdmlkZSBzd2FwIHRoZSBlbXB0eSBsaXN0IHdpdGggYSBiYXNlIGxpc3QgdmlhIG9uT3BlbkNoYW5nZSByZXR1cm5pbmcgYG1lbnVUcmlnZ2VyYCBtYW51YWwpXG4gICAgICAgIGlmIChhbGxvd3NFbXB0eUNvbGxlY3Rpb24gfHwgZmlsdGVyZWRDb2xsZWN0aW9uLnNpemUgPiAwIHx8IGRpc3BsYXlBbGxJdGVtcyAmJiBvcmlnaW5hbENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgcHJvcHMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5QWxsSXRlbXMgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgcHJvcHMuaXRlbXMgPT09IHVuZGVmaW5lZCkgLy8gU2hvdyBhbGwgaXRlbXMgaWYgbWVudSBpcyBtYW51YWxseSBvcGVuZWQuIE9ubHkgY2FyZSBhYm91dCB0aGlzIGlmIGl0ZW1zIGFyZSB1bmRlZmluZWRcbiAgICAgICAgICAgIHNldFNob3dBbGxJdGVtcyh0cnVlKTtcbiAgICAgICAgICAgIG1lbnVPcGVuVHJpZ2dlci5jdXJyZW50ID0gdHJpZ2dlcjtcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgICAgICB0cmlnZ2VyU3RhdGUub3BlbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgdG9nZ2xlID0gKGZvY3VzU3RyYXRlZ3kgPSBudWxsLCB0cmlnZ2VyKT0+e1xuICAgICAgICBsZXQgZGlzcGxheUFsbEl0ZW1zID0gdHJpZ2dlciA9PT0gXCJtYW51YWxcIiB8fCB0cmlnZ2VyID09PSBcImZvY3VzXCIgJiYgbWVudVRyaWdnZXIgPT09IFwiZm9jdXNcIjtcbiAgICAgICAgLy8gSWYgdGhlIG1lbnUgaXMgY2xvc2VkIGFuZCB0aGVyZSBpcyBub3RoaW5nIHRvIGRpc3BsYXksIGVhcmx5IHJldHVybiBzbyB0b2dnbGUgaXNuJ3QgY2FsbGVkIHRvIHByZXZlbnQgZXh0cmFuZW91cyBvbk9wZW5DaGFuZ2VcbiAgICAgICAgaWYgKCEoYWxsb3dzRW1wdHlDb2xsZWN0aW9uIHx8IGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBkaXNwbGF5QWxsSXRlbXMgJiYgb3JpZ2luYWxDb2xsZWN0aW9uLnNpemUgPiAwIHx8IHByb3BzLml0ZW1zKSAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbikgcmV0dXJuO1xuICAgICAgICBpZiAoZGlzcGxheUFsbEl0ZW1zICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIHByb3BzLml0ZW1zID09PSB1bmRlZmluZWQpIC8vIFNob3cgYWxsIGl0ZW1zIGlmIG1lbnUgaXMgdG9nZ2xlZCBvcGVuLiBPbmx5IGNhcmUgYWJvdXQgdGhpcyBpZiBpdGVtcyBhcmUgdW5kZWZpbmVkXG4gICAgICAgIHNldFNob3dBbGxJdGVtcyh0cnVlKTtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIG1lbnVPcGVuVHJpZ2dlciBpZiBtZW51IGlzIGN1cnJlbnRseSBjbG9zZWRcbiAgICAgICAgaWYgKCF0cmlnZ2VyU3RhdGUuaXNPcGVuKSBtZW51T3BlblRyaWdnZXIuY3VycmVudCA9IHRyaWdnZXI7XG4gICAgICAgIHRvZ2dsZU1lbnUoZm9jdXNTdHJhdGVneSk7XG4gICAgfTtcbiAgICBsZXQgdXBkYXRlTGFzdENvbGxlY3Rpb24gPSAoMCwgJGs2UHB1JHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRMYXN0Q29sbGVjdGlvbihzaG93QWxsSXRlbXMgPyBvcmlnaW5hbENvbGxlY3Rpb24gOiBmaWx0ZXJlZENvbGxlY3Rpb24pO1xuICAgIH0sIFtcbiAgICAgICAgc2hvd0FsbEl0ZW1zLFxuICAgICAgICBvcmlnaW5hbENvbGxlY3Rpb24sXG4gICAgICAgIGZpbHRlcmVkQ29sbGVjdGlvblxuICAgIF0pO1xuICAgIC8vIElmIG1lbnUgaXMgZ29pbmcgdG8gY2xvc2UsIHNhdmUgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiBzbyB3ZSBjYW4gZnJlZXplIHRoZSBkaXNwbGF5ZWQgY29sbGVjdGlvbiB3aGVuIHRoZVxuICAgIC8vIHVzZXIgY2xpY2tzIG91dHNpZGUgdGhlIHBvcG92ZXIgdG8gY2xvc2UgdGhlIG1lbnUuIFByZXZlbnRzIHRoZSBtZW51IGNvbnRlbnRzIGZyb20gdXBkYXRpbmcgYXMgdGhlIG1lbnUgY2xvc2VzLlxuICAgIGxldCB0b2dnbGVNZW51ID0gKDAsICRrNlBwdSR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3BlbikgdXBkYXRlTGFzdENvbGxlY3Rpb24oKTtcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgdHJpZ2dlclN0YXRlLnRvZ2dsZSgpO1xuICAgIH0sIFtcbiAgICAgICAgdHJpZ2dlclN0YXRlLFxuICAgICAgICB1cGRhdGVMYXN0Q29sbGVjdGlvblxuICAgIF0pO1xuICAgIGxldCBjbG9zZU1lbnUgPSAoMCwgJGs2UHB1JHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3Blbikge1xuICAgICAgICAgICAgdXBkYXRlTGFzdENvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRyaWdnZXJTdGF0ZS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB0cmlnZ2VyU3RhdGUsXG4gICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uXG4gICAgXSk7XG4gICAgbGV0IFtsYXN0VmFsdWUsIHNldExhc3RWYWx1ZV0gPSAoMCwgJGs2UHB1JHVzZVN0YXRlKShpbnB1dFZhbHVlKTtcbiAgICBsZXQgcmVzZXRJbnB1dFZhbHVlID0gKCk9PntcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICAgICAgbGV0IGl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcbiAgICAgICAgc2V0TGFzdFZhbHVlKGl0ZW1UZXh0KTtcbiAgICAgICAgc2V0SW5wdXRWYWx1ZShpdGVtVGV4dCk7XG4gICAgfTtcbiAgICB2YXIgX3Byb3BzX3NlbGVjdGVkS2V5LCBfcmVmMTtcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5ID0gKDAsICRrNlBwdSR1c2VSZWYpKChfcmVmMSA9IChfcHJvcHNfc2VsZWN0ZWRLZXkgPSBwcm9wcy5zZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX3NlbGVjdGVkS2V5ICE9PSB2b2lkIDAgPyBfcHJvcHNfc2VsZWN0ZWRLZXkgOiBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IG51bGwpO1xuICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICBsZXQgbGFzdFNlbGVjdGVkS2V5VGV4dCA9ICgwLCAkazZQcHUkdXNlUmVmKSgoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbTEgPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbTEudGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiKTtcbiAgICAvLyBpbnRlbnRpb25hbCBvbWl0IGRlcGVuZGVuY3kgYXJyYXksIHdhbnQgdGhpcyB0byBoYXBwZW4gb24gZXZlcnkgcmVuZGVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICgwLCAkazZQcHUkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgLy8gT3BlbiBhbmQgY2xvc2UgbWVudSBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGlucHV0IHZhbHVlIGNoYW5nZXMgaWYgdGhlIGlucHV0IGlzIGZvY3VzZWQsXG4gICAgICAgIC8vIGFuZCB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gb3IgYWxsb3dFbXB0eUNvbGxlY3Rpb24gaXMgdHJ1ZS5cbiAgICAgICAgaWYgKGlzRm9jdXNlZCAmJiAoZmlsdGVyZWRDb2xsZWN0aW9uLnNpemUgPiAwIHx8IGFsbG93c0VtcHR5Q29sbGVjdGlvbikgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4gJiYgaW5wdXRWYWx1ZSAhPT0gbGFzdFZhbHVlICYmIG1lbnVUcmlnZ2VyICE9PSBcIm1hbnVhbFwiKSBvcGVuKG51bGwsIFwiaW5wdXRcIik7XG4gICAgICAgIC8vIENsb3NlIHRoZSBtZW51IGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiBEb24ndCBjbG9zZSBtZW51IGlmIGZpbHRlcmVkIGNvbGxlY3Rpb24gc2l6ZSBpcyAwXG4gICAgICAgIC8vIGJ1dCB3ZSBhcmUgY3VycmVudGx5IHNob3dpbmcgYWxsIGl0ZW1zIHZpYSBidXR0b24gcHJlc3NcbiAgICAgICAgaWYgKCFzaG93QWxsSXRlbXMgJiYgIWFsbG93c0VtcHR5Q29sbGVjdGlvbiAmJiB0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID09PSAwKSBjbG9zZU1lbnUoKTtcbiAgICAgICAgLy8gQ2xvc2Ugd2hlbiBhbiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT0gbnVsbCAmJiBzZWxlY3RlZEtleSAhPT0gbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQpIGNsb3NlTWVudSgpO1xuICAgICAgICAvLyBDbGVhciBmb2N1c2VkIGtleSB3aGVuIGlucHV0IHZhbHVlIGNoYW5nZXMgYW5kIGRpc3BsYXkgZmlsdGVyZWQgY29sbGVjdGlvbiBhZ2Fpbi5cbiAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgICAgICAgICAgc2V0U2hvd0FsbEl0ZW1zKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIFNldCBzZWxlY3RlZEtleSB0byBudWxsIHdoZW4gdGhlIHVzZXIgY2xlYXJzIHRoZSBpbnB1dC5cbiAgICAgICAgICAgIC8vIElmIGNvbnRyb2xsZWQsIHRoaXMgaXMgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlcidzIHJlc3BvbnNpYmlsaXR5LlxuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09IFwiXCIgJiYgKHByb3BzLmlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy5zZWxlY3RlZEtleSA9PT0gdW5kZWZpbmVkKSkgc2V0U2VsZWN0ZWRLZXkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkS2V5IGNoYW5nZWQsIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgYm90aCBpbnB1dFZhbHVlIGFuZCBzZWxlY3RlZEtleSBhcmUgY29udHJvbGxlZC5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpdCdzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gdXBkYXRlIGlucHV0VmFsdWUgaW4gb25TZWxlY3Rpb25DaGFuZ2UuXG4gICAgICAgIGlmIChzZWxlY3RlZEtleSAhPT0gbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgJiYgKHByb3BzLmlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy5zZWxlY3RlZEtleSA9PT0gdW5kZWZpbmVkKSkgcmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgIGVsc2UgaWYgKGxhc3RWYWx1ZSAhPT0gaW5wdXRWYWx1ZSkgc2V0TGFzdFZhbHVlKGlucHV0VmFsdWUpO1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXRWYWx1ZSBpZiB0aGUgc2VsZWN0ZWQgaXRlbSdzIHRleHQgY2hhbmdlcyBmcm9tIGl0cyBsYXN0IHRyYWNrZWQgdmFsdWUuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIHdoZXJlIGEgc2VsZWN0ZWRLZXkgaXMgc3BlY2lmaWVkIGJ1dCB0aGUgaXRlbXMgYXJlbid0IGF2YWlsYWJsZSAoYXN5bmMgbG9hZGluZykgb3IgdGhlIHNlbGVjdGVkIGl0ZW0ncyB0ZXh0IHZhbHVlIHVwZGF0ZXMuXG4gICAgICAgIC8vIE9ubHkgcmVzZXQgaWYgdGhlIHVzZXIgaXNuJ3QgY3VycmVudGx5IHdpdGhpbiB0aGUgZmllbGQgc28gd2UgZG9uJ3QgZXJyb25lb3VzbHkgbW9kaWZ5IHVzZXIgaW5wdXQuXG4gICAgICAgIC8vIElmIGlucHV0VmFsdWUgaXMgY29udHJvbGxlZCwgaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byB1cGRhdGUgdGhlIGlucHV0VmFsdWUgd2hlbiBpdGVtcyBjaGFuZ2UuXG4gICAgICAgIGxldCBzZWxlY3RlZEl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcbiAgICAgICAgaWYgKCFpc0ZvY3VzZWQgJiYgc2VsZWN0ZWRLZXkgIT0gbnVsbCAmJiBwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgJiYgc2VsZWN0ZWRLZXkgPT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAobGFzdFNlbGVjdGVkS2V5VGV4dC5jdXJyZW50ICE9PSBzZWxlY3RlZEl0ZW1UZXh0KSB7XG4gICAgICAgICAgICAgICAgc2V0TGFzdFZhbHVlKHNlbGVjdGVkSXRlbVRleHQpO1xuICAgICAgICAgICAgICAgIHNldElucHV0VmFsdWUoc2VsZWN0ZWRJdGVtVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBzZWxlY3RlZEtleTtcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5VGV4dC5jdXJyZW50ID0gc2VsZWN0ZWRJdGVtVGV4dDtcbiAgICB9KTtcbiAgICBsZXQgdmFsaWRhdGlvbiA9ICgwLCAkazZQcHUkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXlcbiAgICAgICAgICAgIH0pLCBbXG4gICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0ZWRLZXlcbiAgICAgICAgXSlcbiAgICB9KTtcbiAgICAvLyBSZXZlcnQgaW5wdXQgdmFsdWUgYW5kIGNsb3NlIG1lbnVcbiAgICBsZXQgcmV2ZXJ0ID0gKCk9PntcbiAgICAgICAgaWYgKGFsbG93c0N1c3RvbVZhbHVlICYmIHNlbGVjdGVkS2V5ID09IG51bGwpIGNvbW1pdEN1c3RvbVZhbHVlKCk7XG4gICAgICAgIGVsc2UgY29tbWl0U2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICBsZXQgY29tbWl0Q3VzdG9tVmFsdWUgPSAoKT0+e1xuICAgICAgICBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHNldFNlbGVjdGVkS2V5KG51bGwpO1xuICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICB9O1xuICAgIGxldCBjb21taXRTZWxlY3Rpb24gPSAoKT0+e1xuICAgICAgICAvLyBJZiBtdWx0aXBsZSB0aGluZ3MgYXJlIGNvbnRyb2xsZWQsIGNhbGwgb25TZWxlY3Rpb25DaGFuZ2VcbiAgICAgICAgaWYgKHByb3BzLnNlbGVjdGVkS2V5ICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuaW5wdXRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgICAgIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKHNlbGVjdGVkS2V5KTtcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICAgICAgICAgIC8vIFN0b3AgbWVudSBmcm9tIHJlb3BlbmluZyBmcm9tIHVzZUVmZmVjdFxuICAgICAgICAgICAgbGV0IGl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgIHNldExhc3RWYWx1ZShpdGVtVGV4dCk7XG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG9ubHkgYSBzaW5nbGUgYXNwZWN0IG9mIGNvbWJvYm94IGlzIGNvbnRyb2xsZWQsIHJlc2V0IGlucHV0IHZhbHVlIGFuZCBjbG9zZSBtZW51IGZvciB0aGUgdXNlclxuICAgICAgICAgICAgcmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29tbWl0VmFsdWUgPSAoKT0+e1xuICAgICAgICBpZiAoYWxsb3dzQ3VzdG9tVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgaXRlbVRleHQgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgPSAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgOiBcIlwiO1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9PT0gaXRlbVRleHQgPyBjb21taXRTZWxlY3Rpb24oKSA6IGNvbW1pdEN1c3RvbVZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSAvLyBSZXNldCBpbnB1dFZhbHVlIGFuZCBjbG9zZSBtZW51XG4gICAgICAgIGNvbW1pdFNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgbGV0IGNvbW1pdCA9ICgpPT57XG4gICAgICAgIGlmICh0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIHNlbGVjdGlvbk1hbmFnZXIuZm9jdXNlZEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZXNldCBpbnB1dFZhbHVlIGFuZCBjbG9zZSBtZW51IGhlcmUgaWYgdGhlIHNlbGVjdGVkIGtleSBpcyBhbHJlYWR5IHRoZSBmb2N1c2VkIGtleS4gT3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBmaXJlIG9uU2VsZWN0aW9uQ2hhbmdlIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBjb250cm9sIHRoZSBjbG9zaW5nLlxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkS2V5ID09PSBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkpIGNvbW1pdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZWxzZSBzZXRTZWxlY3RlZEtleShzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkpO1xuICAgICAgICB9IGVsc2UgY29tbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIGxldCB2YWx1ZU9uRm9jdXMgPSAoMCwgJGs2UHB1JHVzZVJlZikoaW5wdXRWYWx1ZSk7XG4gICAgbGV0IHNldEZvY3VzZWQgPSAoaXNGb2N1c2VkKT0+e1xuICAgICAgICBpZiAoaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICB2YWx1ZU9uRm9jdXMuY3VycmVudCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICBpZiAobWVudVRyaWdnZXIgPT09IFwiZm9jdXNcIikgb3BlbihudWxsLCBcImZvY3VzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3VsZENsb3NlT25CbHVyKSBjb21taXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IHZhbHVlT25Gb2N1cy5jdXJyZW50KSB2YWxpZGF0aW9uLmNvbW1pdFZhbGlkYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRGb2N1c2VkU3RhdGUoaXNGb2N1c2VkKTtcbiAgICB9O1xuICAgIGxldCBkaXNwbGF5ZWRDb2xsZWN0aW9uID0gKDAsICRrNlBwdSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3Blbikge1xuICAgICAgICAgICAgaWYgKHNob3dBbGxJdGVtcykgcmV0dXJuIG9yaWdpbmFsQ29sbGVjdGlvbjtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZpbHRlcmVkQ29sbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHJldHVybiBsYXN0Q29sbGVjdGlvbjtcbiAgICB9LCBbXG4gICAgICAgIHRyaWdnZXJTdGF0ZS5pc09wZW4sXG4gICAgICAgIG9yaWdpbmFsQ29sbGVjdGlvbixcbiAgICAgICAgZmlsdGVyZWRDb2xsZWN0aW9uLFxuICAgICAgICBzaG93QWxsSXRlbXMsXG4gICAgICAgIGxhc3RDb2xsZWN0aW9uXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsaWRhdGlvbixcbiAgICAgICAgLi4udHJpZ2dlclN0YXRlLFxuICAgICAgICBmb2N1c1N0cmF0ZWd5OiBmb2N1c1N0cmF0ZWd5LFxuICAgICAgICB0b2dnbGU6IHRvZ2dsZSxcbiAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgY2xvc2U6IGNvbW1pdFZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXksXG4gICAgICAgIHNldFNlbGVjdGVkS2V5OiBzZXRTZWxlY3RlZEtleSxcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkLFxuICAgICAgICBzZXRGb2N1c2VkOiBzZXRGb2N1c2VkLFxuICAgICAgICBzZWxlY3RlZEl0ZW06IHNlbGVjdGVkSXRlbSxcbiAgICAgICAgY29sbGVjdGlvbjogZGlzcGxheWVkQ29sbGVjdGlvbixcbiAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgc2V0SW5wdXRWYWx1ZTogc2V0SW5wdXRWYWx1ZSxcbiAgICAgICAgY29tbWl0OiBjb21taXQsXG4gICAgICAgIHJldmVydDogcmV2ZXJ0XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGlucHV0VmFsdWUsIGZpbHRlcikge1xuICAgIHJldHVybiBuZXcgKDAsICRrNlBwdSRMaXN0Q29sbGVjdGlvbikoJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb24sIGlucHV0VmFsdWUsIGZpbHRlcikpO1xufVxuZnVuY3Rpb24gJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzKGNvbGxlY3Rpb24sIG5vZGVzLCBpbnB1dFZhbHVlLCBmaWx0ZXIpIHtcbiAgICBsZXQgZmlsdGVyZWROb2RlID0gW107XG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwic2VjdGlvblwiICYmIG5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlck5vZGVzKGNvbGxlY3Rpb24sICgwLCAkazZQcHUkZ2V0Q2hpbGROb2Rlcykobm9kZSwgY29sbGVjdGlvbiksIGlucHV0VmFsdWUsIGZpbHRlcik7XG4gICAgICAgICAgICBpZiAoW1xuICAgICAgICAgICAgICAgIC4uLmZpbHRlcmVkXG4gICAgICAgICAgICBdLnNvbWUoKG5vZGUpPT5ub2RlLnR5cGUgPT09IFwiaXRlbVwiKSkgZmlsdGVyZWROb2RlLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogZmlsdGVyZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIgJiYgZmlsdGVyKG5vZGUudGV4dFZhbHVlLCBpbnB1dFZhbHVlKSkgZmlsdGVyZWROb2RlLnB1c2goe1xuICAgICAgICAgICAgLi4ubm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlICE9PSBcIml0ZW1cIikgZmlsdGVyZWROb2RlLnB1c2goe1xuICAgICAgICAgICAgLi4ubm9kZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkTm9kZTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTllNzM4MmE3ZDExMWNiNSRleHBvcnQkYjQ1M2EzYmZkNGE1ZmE5ZSBhcyB1c2VDb21ib0JveFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGs2UHB1JHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJnZXRDaGlsZE5vZGVzIiwiJGs2UHB1JGdldENoaWxkTm9kZXMiLCJ1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCIkazZQcHUkdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwiTGlzdENvbGxlY3Rpb24iLCIkazZQcHUkTGlzdENvbGxlY3Rpb24iLCJ1c2VTdGF0ZSIsIiRrNlBwdSR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkazZQcHUkdXNlTWVtbyIsInVzZVJlZiIsIiRrNlBwdSR1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIiRrNlBwdSR1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIiRrNlBwdSR1c2VFZmZlY3QiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiRrNlBwdSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJGE5ZTczODJhN2QxMTFjYjUkZXhwb3J0JGI0NTNhM2JmZDRhNWZhOWUiLCJwcm9wcyIsIl9jb2xsZWN0aW9uX2dldEl0ZW0iLCJfY29sbGVjdGlvbl9nZXRJdGVtMSIsImRlZmF1bHRGaWx0ZXIiLCJtZW51VHJpZ2dlciIsImFsbG93c0VtcHR5Q29sbGVjdGlvbiIsImFsbG93c0N1c3RvbVZhbHVlIiwic2hvdWxkQ2xvc2VPbkJsdXIiLCJzaG93QWxsSXRlbXMiLCJzZXRTaG93QWxsSXRlbXMiLCJpc0ZvY3VzZWQiLCJzZXRGb2N1c2VkU3RhdGUiLCJmb2N1c1N0cmF0ZWd5Iiwic2V0Rm9jdXNTdHJhdGVneSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwia2V5Iiwic2VsZWN0ZWRLZXkiLCJyZXNldElucHV0VmFsdWUiLCJjbG9zZU1lbnUiLCJfcHJvcHNfaXRlbXMiLCJjb2xsZWN0aW9uIiwic2VsZWN0aW9uTWFuYWdlciIsInNldFNlbGVjdGVkS2V5Iiwic2VsZWN0ZWRJdGVtIiwiZGlzYWJsZWRLZXlzIiwiaXRlbXMiLCJkZWZhdWx0SXRlbXMiLCJfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUiLCJfcmVmIiwiaW5wdXRWYWx1ZSIsInNldElucHV0VmFsdWUiLCJkZWZhdWx0SW5wdXRWYWx1ZSIsImdldEl0ZW0iLCJ0ZXh0VmFsdWUiLCJvbklucHV0Q2hhbmdlIiwib3JpZ2luYWxDb2xsZWN0aW9uIiwiZmlsdGVyZWRDb2xsZWN0aW9uIiwiJGE5ZTczODJhN2QxMTFjYjUkdmFyJGZpbHRlckNvbGxlY3Rpb24iLCJsYXN0Q29sbGVjdGlvbiIsInNldExhc3RDb2xsZWN0aW9uIiwibWVudU9wZW5UcmlnZ2VyIiwib25PcGVuQ2hhbmdlIiwib3BlbiIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJzZXRGb2N1c2VkIiwic2V0Rm9jdXNlZEtleSIsInRyaWdnZXJTdGF0ZSIsImlzT3BlbiIsImRlZmF1bHRPcGVuIiwidHJpZ2dlciIsImRpc3BsYXlBbGxJdGVtcyIsInNpemUiLCJ0b2dnbGUiLCJ0b2dnbGVNZW51IiwidXBkYXRlTGFzdENvbGxlY3Rpb24iLCJjbG9zZSIsImxhc3RWYWx1ZSIsInNldExhc3RWYWx1ZSIsIl9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIiwiaXRlbVRleHQiLCJfcHJvcHNfc2VsZWN0ZWRLZXkiLCJfcmVmMSIsImxhc3RTZWxlY3RlZEtleSIsImRlZmF1bHRTZWxlY3RlZEtleSIsImxhc3RTZWxlY3RlZEtleVRleHQiLCJzZWxlY3RlZEl0ZW1UZXh0IiwidmFsaWRhdGlvbiIsInZhbHVlIiwicmV2ZXJ0IiwiY29tbWl0Q3VzdG9tVmFsdWUiLCJjb21taXRTZWxlY3Rpb24iLCJjb21taXRWYWx1ZSIsImNvbW1pdCIsImZvY3VzZWRLZXkiLCJ2YWx1ZU9uRm9jdXMiLCJjb21taXRWYWxpZGF0aW9uIiwiZGlzcGxheWVkQ29sbGVjdGlvbiIsImZpbHRlciIsIiRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2RlcyIsIm5vZGVzIiwiZmlsdGVyZWROb2RlIiwibm9kZSIsInR5cGUiLCJoYXNDaGlsZE5vZGVzIiwiZmlsdGVyZWQiLCJzb21lIiwicHVzaCIsImNoaWxkTm9kZXMiLCJ1c2VDb21ib0JveFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLElBQUlBLHlDQUF5QztBQUNqRCxTQUFTQztJQUNMRCx5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRTtJQUNMLE9BQU9GO0FBQ1g7QUFHMEksQ0FDMUksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2ZsYWdzL2Rpc3QvaW1wb3J0Lm1qcz9hODAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBsZXQgJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MgPSBmYWxzZTtcbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwKCkge1xuICAgICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2KCkge1xuICAgIHJldHVybiAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cztcbn1cblxuXG5leHBvcnQgeyRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwIGFzIGVuYWJsZVRhYmxlTmVzdGVkUm93cywgJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDFiMDBjYjE0YTk2MTk0ZTYgYXMgdGFibGVOZXN0ZWRSb3dzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyIkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyIsIiRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCRkOWQ4YTBmODJkZTQ5NTMwIiwiJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDFiMDBjYjE0YTk2MTk0ZTYiLCJlbmFibGVUYWJsZU5lc3RlZFJvd3MiLCJ0YWJsZU5lc3RlZFJvd3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTtBQUU3TTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELE1BQU1ZLDRDQUE0QztJQUM5Q0MsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyw4Q0FBOEM7SUFDaEQsR0FBR1oseUNBQXlDO0lBQzVDRSxhQUFhO0lBQ2JTLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztJQUM5Q0MsV0FBVztJQUNYQyxtQkFBbUJmO0lBQ25CZ0Isa0JBQWtCLEVBQUU7QUFDeEI7QUFDQSxNQUFNQyw0Q0FBNEMsQ0FBQyxHQUFHNUIsZ0RBQW1CLEVBQUcsQ0FBQztBQUM3RSxNQUFNNkIsMkNBQTJDLDBCQUEwQkMsS0FBS0MsR0FBRztBQUNuRixTQUFTQywwQ0FBMENDLEtBQUs7SUFDcEQsZ0VBQWdFO0lBQ2hFLElBQUlBLEtBQUssQ0FBQ0oseUNBQXlDLEVBQUU7UUFDakQsSUFBSSxFQUFFSyxvQkFBb0JBLGtCQUFrQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxpQkFBaUJBLGVBQWUsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHTCxLQUFLLENBQUNKLHlDQUF5QztRQUNoUCxPQUFPO1lBQ0hLLG9CQUFvQkE7WUFDcEJDLG1CQUFtQkE7WUFDbkJDLGtCQUFrQkE7WUFDbEJDLGlCQUFpQkE7WUFDakJDLGtCQUFrQkE7UUFDdEI7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPQyxpREFBaUROO0FBQzVEO0FBQ0EsU0FBU00saURBQWlETixLQUFLO0lBQzNELElB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LGdCQUFnQixDQUFDOEMsTUFBTSxLQUFLRSxFQUFFaEQsZ0JBQWdCLENBQUM4QyxNQUFNLElBQUlDLEVBQUUvQyxnQkFBZ0IsQ0FBQ2lELEtBQUssQ0FBQyxDQUFDRixHQUFHRyxJQUFJSCxNQUFNQyxFQUFFaEQsZ0JBQWdCLENBQUNrRCxFQUFFLEtBQUtDLE9BQU9DLE9BQU8sQ0FBQ0wsRUFBRWhELGlCQUFpQixFQUFFa0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksR0FBR1YsRUFBRSxHQUFHSyxFQUFFakQsaUJBQWlCLENBQUNzRCxFQUFFLEtBQUtWO0FBQy9QO0FBQ0EsU0FBU1csMENBQTBDLEdBQUdDLE9BQU87SUFDekQsSUFBSVYsU0FBUyxJQUFJVztJQUNqQixJQUFJMUQsWUFBWTtJQUNoQixJQUFJQyxvQkFBb0I7UUFDcEIsR0FBR2YseUNBQXlDO0lBQ2hEO0lBQ0EsS0FBSyxJQUFJMkQsS0FBS1ksUUFBUTtRQUNsQixJQUFJRSxvQkFBb0JDO1FBQ3hCLEtBQUssSUFBSWQsS0FBS0QsRUFBRTNDLGdCQUFnQixDQUFDNkMsT0FBT2MsR0FBRyxDQUFDZjtRQUM1Qyw4Q0FBOEM7UUFDOUM5QyxhQUFjQSxDQUFBQSxZQUFZNkMsRUFBRTdDLFNBQVM7UUFDckMsSUFBSSxJQUFJOEQsT0FBTzdELGtCQUFrQixDQUFDMEQscUJBQXFCMUQsaUJBQWdCLENBQUUsQ0FBQzJELE9BQU9FLElBQUksSUFBS0gsQ0FBQUEsa0JBQWtCLENBQUNDLEtBQUssR0FBR2YsRUFBRTVDLGlCQUFpQixDQUFDNkQsSUFBSTtJQUNqSjtJQUNBN0Qsa0JBQWtCSixLQUFLLEdBQUcsQ0FBQ0c7SUFDM0IsT0FBTztRQUNIQSxXQUFXQTtRQUNYRSxrQkFBa0I7ZUFDWDZDO1NBQ047UUFDRDlDLG1CQUFtQkE7SUFDdkI7QUFDSjtBQUtrYSxDQUNsYSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNpZ24tZW5naW5lZXIvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanM/ZjUwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2NyZWF0ZUNvbnRleHQgYXMgJGpjSU93JGNyZWF0ZUNvbnRleHQsIHVzZU1lbW8gYXMgJGpjSU93JHVzZU1lbW8sIHVzZUNvbnRleHQgYXMgJGpjSU93JHVzZUNvbnRleHQsIHVzZVN0YXRlIGFzICRqY0lPdyR1c2VTdGF0ZSwgdXNlUmVmIGFzICRqY0lPdyR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkamNJT3ckdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjID0ge1xuICAgIGJhZElucHV0OiBmYWxzZSxcbiAgICBjdXN0b21FcnJvcjogZmFsc2UsXG4gICAgcGF0dGVybk1pc21hdGNoOiBmYWxzZSxcbiAgICByYW5nZU92ZXJmbG93OiBmYWxzZSxcbiAgICByYW5nZVVuZGVyZmxvdzogZmFsc2UsXG4gICAgc3RlcE1pc21hdGNoOiBmYWxzZSxcbiAgICB0b29Mb25nOiBmYWxzZSxcbiAgICB0b29TaG9ydDogZmFsc2UsXG4gICAgdHlwZU1pc21hdGNoOiBmYWxzZSxcbiAgICB2YWx1ZU1pc3Npbmc6IGZhbHNlLFxuICAgIHZhbGlkOiB0cnVlXG59O1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURSA9IHtcbiAgICAuLi4kZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyxcbiAgICBjdXN0b21FcnJvcjogdHJ1ZSxcbiAgICB2YWxpZDogZmFsc2Vcbn07XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSA9IHtcbiAgICBpc0ludmFsaWQ6IGZhbHNlLFxuICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyxcbiAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXVxufTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExID0gKDAsICRqY0lPdyRjcmVhdGVDb250ZXh0KSh7fSk7XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViID0gXCJfX2Zvcm1WYWxpZGF0aW9uU3RhdGVcIiArIERhdGUubm93KCk7XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMChwcm9wcykge1xuICAgIC8vIFByaXZhdGUgcHJvcCBmb3IgcGFyZW50IGNvbXBvbmVudHMgdG8gcGFzcyBzdGF0ZSB0byBjaGlsZHJlbi5cbiAgICBpZiAocHJvcHNbJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYl0pIHtcbiAgICAgICAgbGV0IHsgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sIGRpc3BsYXlWYWxpZGF0aW9uOiBkaXNwbGF5VmFsaWRhdGlvbiwgdXBkYXRlVmFsaWRhdGlvbjogdXBkYXRlVmFsaWRhdGlvbiwgcmVzZXRWYWxpZGF0aW9uOiByZXNldFZhbGlkYXRpb24sIGNvbW1pdFZhbGlkYXRpb246IGNvbW1pdFZhbGlkYXRpb24gfSA9IHByb3BzWyRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWJdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbHRpbWVWYWxpZGF0aW9uOiByZWFsdGltZVZhbGlkYXRpb24sXG4gICAgICAgICAgICBkaXNwbGF5VmFsaWRhdGlvbjogZGlzcGxheVZhbGlkYXRpb24sXG4gICAgICAgICAgICB1cGRhdGVWYWxpZGF0aW9uOiB1cGRhdGVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgcmVzZXRWYWxpZGF0aW9uOiByZXNldFZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb21taXRWYWxpZGF0aW9uOiBjb21taXRWYWxpZGF0aW9uXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZUltcGwocHJvcHMpO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsKHByb3BzKSB7XG4gICAgbGV0IHsgaXNJbnZhbGlkOiBpc0ludmFsaWQsIHZhbGlkYXRpb25TdGF0ZTogdmFsaWRhdGlvblN0YXRlLCBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGJ1aWx0aW5WYWxpZGF0aW9uOiBidWlsdGluVmFsaWRhdGlvbiwgdmFsaWRhdGU6IHZhbGlkYXRlLCB2YWxpZGF0aW9uQmVoYXZpb3I6IHZhbGlkYXRpb25CZWhhdmlvciA9IFwiYXJpYVwiIH0gPSBwcm9wcztcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGlmICh2YWxpZGF0aW9uU3RhdGUpIGlzSW52YWxpZCB8fCAoaXNJbnZhbGlkID0gdmFsaWRhdGlvblN0YXRlID09PSBcImludmFsaWRcIik7XG4gICAgLy8gSWYgdGhlIGlzSW52YWxpZCBwcm9wIGlzIHRydWUsIHVwZGF0ZSB2YWxpZGF0aW9uIHJlc3VsdCBpbiByZWFsdGltZSAoY29udHJvbGxlZCkuXG4gICAgbGV0IGNvbnRyb2xsZWRFcnJvciA9IGlzSW52YWxpZCA/IHtcbiAgICAgICAgaXNJbnZhbGlkOiB0cnVlLFxuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEVcbiAgICB9IDogbnVsbDtcbiAgICAvLyBQZXJmb3JtIGN1c3RvbSBjbGllbnQgc2lkZSB2YWxpZGF0aW9uLlxuICAgIGxldCBjbGllbnRFcnJvciA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KCRlNWJlMjAwYzY3NWMzYjNhJHZhciRydW5WYWxpZGF0ZSh2YWxpZGF0ZSwgdmFsdWUpKSwgW1xuICAgICAgICB2YWxpZGF0ZSxcbiAgICAgICAgdmFsdWVcbiAgICBdKTtcbiAgICBpZiAoYnVpbHRpblZhbGlkYXRpb24gPT09IG51bGwgfHwgYnVpbHRpblZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1aWx0aW5WYWxpZGF0aW9uLnZhbGlkYXRpb25EZXRhaWxzLnZhbGlkKSBidWlsdGluVmFsaWRhdGlvbiA9IG51bGw7XG4gICAgLy8gR2V0IHJlbGV2YW50IHNlcnZlciBlcnJvcnMgZnJvbSB0aGUgZm9ybS5cbiAgICBsZXQgc2VydmVyRXJyb3JzID0gKDAsICRqY0lPdyR1c2VDb250ZXh0KSgkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSk7XG4gICAgbGV0IHNlcnZlckVycm9yTWVzc2FnZXMgPSAoMCwgJGpjSU93JHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGlmIChuYW1lKSByZXR1cm4gQXJyYXkuaXNBcnJheShuYW1lKSA/IG5hbWUuZmxhdE1hcCgobmFtZSk9PiRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHNlcnZlckVycm9yc1tuYW1lXSkpIDogJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoc2VydmVyRXJyb3JzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sIFtcbiAgICAgICAgc2VydmVyRXJyb3JzLFxuICAgICAgICBuYW1lXG4gICAgXSk7XG4gICAgLy8gU2hvdyBzZXJ2ZXIgZXJyb3JzIHdoZW4gdGhlIGZvcm0gZ2V0cyBhIG5ldyB2YWx1ZSwgYW5kIGNsZWFyIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgdmFsdWUuXG4gICAgbGV0IFtsYXN0U2VydmVyRXJyb3JzLCBzZXRMYXN0U2VydmVyRXJyb3JzXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKHNlcnZlckVycm9ycyk7XG4gICAgbGV0IFtpc1NlcnZlckVycm9yQ2xlYXJlZCwgc2V0U2VydmVyRXJyb3JDbGVhcmVkXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBpZiAoc2VydmVyRXJyb3JzICE9PSBsYXN0U2VydmVyRXJyb3JzKSB7XG4gICAgICAgIHNldExhc3RTZXJ2ZXJFcnJvcnMoc2VydmVyRXJyb3JzKTtcbiAgICAgICAgc2V0U2VydmVyRXJyb3JDbGVhcmVkKGZhbHNlKTtcbiAgICB9XG4gICAgbGV0IHNlcnZlckVycm9yID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+JGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoaXNTZXJ2ZXJFcnJvckNsZWFyZWQgPyBbXSA6IHNlcnZlckVycm9yTWVzc2FnZXMpLCBbXG4gICAgICAgIGlzU2VydmVyRXJyb3JDbGVhcmVkLFxuICAgICAgICBzZXJ2ZXJFcnJvck1lc3NhZ2VzXG4gICAgXSk7XG4gICAgLy8gVHJhY2sgdGhlIG5leHQgdmFsaWRhdGlvbiBzdGF0ZSBpbiBhIHJlZiB1bnRpbCBjb21taXRWYWxpZGF0aW9uIGlzIGNhbGxlZC5cbiAgICBsZXQgbmV4dFZhbGlkYXRpb24gPSAoMCwgJGpjSU93JHVzZVJlZikoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEpO1xuICAgIGxldCBbY3VycmVudFZhbGlkaXR5LCBzZXRDdXJyZW50VmFsaWRpdHldID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEpO1xuICAgIGxldCBsYXN0RXJyb3IgPSAoMCwgJGpjSU93JHVzZVJlZikoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEpO1xuICAgIGxldCBjb21taXRWYWxpZGF0aW9uID0gKCk9PntcbiAgICAgICAgaWYgKCFjb21taXRRdWV1ZWQpIHJldHVybjtcbiAgICAgICAgc2V0Q29tbWl0UXVldWVkKGZhbHNlKTtcbiAgICAgICAgbGV0IGVycm9yID0gY2xpZW50RXJyb3IgfHwgYnVpbHRpblZhbGlkYXRpb24gfHwgbmV4dFZhbGlkYXRpb24uY3VycmVudDtcbiAgICAgICAgaWYgKCEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oZXJyb3IsIGxhc3RFcnJvci5jdXJyZW50KSkge1xuICAgICAgICAgICAgbGFzdEVycm9yLmN1cnJlbnQgPSBlcnJvcjtcbiAgICAgICAgICAgIHNldEN1cnJlbnRWYWxpZGl0eShlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBbY29tbWl0UXVldWVkLCBzZXRDb21taXRRdWV1ZWRdID0gKDAsICRqY0lPdyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgICgwLCAkamNJT3ckdXNlRWZmZWN0KShjb21taXRWYWxpZGF0aW9uKTtcbiAgICAvLyByZWFsdGltZVZhbGlkYXRpb24gaXMgdXNlZCB0byB1cGRhdGUgdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50J3Mgc3RhdGUgYmFzZWQgb24gY3VzdG9tIHZhbGlkYXRpb24gbG9naWMuXG4gICAgLy8gZGlzcGxheVZhbGlkYXRpb24gaXMgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdmFsaWRhdGlvbiBzdGF0ZSB0aGF0IHRoZSB1c2VyIHNlZXMgKGUuZy4gb24gaW5wdXQgY2hhbmdlL2Zvcm0gc3VibWl0KS5cbiAgICAvLyBXaXRoIHZhbGlkYXRpb25CZWhhdmlvcj1cImFyaWFcIiwgYWxsIGVycm9ycyBhcmUgZGlzcGxheWVkIGluIHJlYWx0aW1lIHJhdGhlciB0aGFuIG9uIHN1Ym1pdC5cbiAgICBsZXQgcmVhbHRpbWVWYWxpZGF0aW9uID0gY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhO1xuICAgIGxldCBkaXNwbGF5VmFsaWRhdGlvbiA9IHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIiA/IGNvbnRyb2xsZWRFcnJvciB8fCBzZXJ2ZXJFcnJvciB8fCBjdXJyZW50VmFsaWRpdHkgOiBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY2xpZW50RXJyb3IgfHwgYnVpbHRpblZhbGlkYXRpb24gfHwgY3VycmVudFZhbGlkaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWx0aW1lVmFsaWRhdGlvbjogcmVhbHRpbWVWYWxpZGF0aW9uLFxuICAgICAgICBkaXNwbGF5VmFsaWRhdGlvbjogZGlzcGxheVZhbGlkYXRpb24sXG4gICAgICAgIHVwZGF0ZVZhbGlkYXRpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB2YWxpZGF0aW9uQmVoYXZpb3IgaXMgJ2FyaWEnLCB1cGRhdGUgaW4gcmVhbHRpbWUuIE90aGVyd2lzZSwgc3RvcmUgaW4gYSByZWYgdW50aWwgY29tbWl0LlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJhcmlhXCIgJiYgISRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihjdXJyZW50VmFsaWRpdHksIHZhbHVlKSkgc2V0Q3VycmVudFZhbGlkaXR5KHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgbmV4dFZhbGlkYXRpb24uY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFZhbGlkYXRpb24gKCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHZhbGlkYXRpb24gc3RhdGUgdG8gdmFsaWQgb24gZm9ybSByZXNldCxcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIG5hdGl2ZSB2YWxpZGl0eSBzYXlzIGl0IGlzbid0LiBJdCdsbCBzaG93IGFnYWluIG9uIHRoZSBuZXh0IGZvcm0gc3VibWl0LlxuICAgICAgICAgICAgbGV0IGVycm9yID0gJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmE7XG4gICAgICAgICAgICBpZiAoISRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihlcnJvciwgbGFzdEVycm9yLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yLmN1cnJlbnQgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VmFsaWRpdHkoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGNvbW1pdCB2YWxpZGF0aW9uIGFmdGVyIHRoZSBuZXh0IHJlbmRlci4gVGhpcyBhdm9pZHMgYSBjb25kaXRpb24gd2hlcmVcbiAgICAgICAgICAgIC8vIHVzZVNlbGVjdCBjYWxscyBjb21taXRWYWxpZGF0aW9uIGluc2lkZSBhbiBvblJlc2V0IGhhbmRsZXIuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiKSBzZXRDb21taXRRdWV1ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0U2VydmVyRXJyb3JDbGVhcmVkKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRWYWxpZGF0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB2YWxpZGF0aW9uIHN0YXRlIHNvIHRoZSB1c2VyIHNlZXMgaXQgb24gYmx1ci9jaGFuZ2Uvc3VibWl0LiBBbHNvIGNsZWFyIGFueSBzZXJ2ZXIgZXJyb3JzLlxuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBhZnRlciB0aGUgbmV4dCByZW5kZXIgdG8gY29tbWl0IHNvIHRoYXQgdGhlIGxhdGVzdCB2YWx1ZSBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiKSBzZXRDb21taXRRdWV1ZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRTZXJ2ZXJFcnJvckNsZWFyZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkodikge1xuICAgIGlmICghdikgcmV0dXJuIFtdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFtcbiAgICAgICAgdlxuICAgIF07XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkcnVuVmFsaWRhdGUodmFsaWRhdGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGxldCBlID0gdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZSAmJiB0eXBlb2YgZSAhPT0gXCJib29sZWFuXCIpIHJldHVybiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQoZXJyb3JzKSB7XG4gICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyB7XG4gICAgICAgIGlzSW52YWxpZDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogZXJyb3JzLFxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURVxuICAgIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGEgJiYgYiAmJiBhLmlzSW52YWxpZCA9PT0gYi5pc0ludmFsaWQgJiYgYS52YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA9PT0gYi52YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCAmJiBhLnZhbGlkYXRpb25FcnJvcnMuZXZlcnkoKGEsIGkpPT5hID09PSBiLnZhbGlkYXRpb25FcnJvcnNbaV0pICYmIE9iamVjdC5lbnRyaWVzKGEudmFsaWRhdGlvbkRldGFpbHMpLmV2ZXJ5KChbaywgdl0pPT5iLnZhbGlkYXRpb25EZXRhaWxzW2tdID09PSB2KTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ3NWVlN2M3NWQ2OGY1YjBlKC4uLnJlc3VsdHMpIHtcbiAgICBsZXQgZXJyb3JzID0gbmV3IFNldCgpO1xuICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICBsZXQgdmFsaWRhdGlvbkRldGFpbHMgPSB7XG4gICAgICAgIC4uLiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjXG4gICAgfTtcbiAgICBmb3IgKGxldCB2IG9mIHJlc3VsdHMpe1xuICAgICAgICB2YXIgX3ZhbGlkYXRpb25EZXRhaWxzLCBfa2V5O1xuICAgICAgICBmb3IgKGxldCBlIG9mIHYudmFsaWRhdGlvbkVycm9ycyllcnJvcnMuYWRkKGUpO1xuICAgICAgICAvLyBPbmx5IHRoZXNlIHByb3BlcnRpZXMgYXBwbHkgZm9yIGNoZWNrYm94ZXMuXG4gICAgICAgIGlzSW52YWxpZCB8fCAoaXNJbnZhbGlkID0gdi5pc0ludmFsaWQpO1xuICAgICAgICBmb3IobGV0IGtleSBpbiB2YWxpZGF0aW9uRGV0YWlscykoX3ZhbGlkYXRpb25EZXRhaWxzID0gdmFsaWRhdGlvbkRldGFpbHMpW19rZXkgPSBrZXldIHx8IChfdmFsaWRhdGlvbkRldGFpbHNbX2tleV0gPSB2LnZhbGlkYXRpb25EZXRhaWxzW2tleV0pO1xuICAgIH1cbiAgICB2YWxpZGF0aW9uRGV0YWlscy52YWxpZCA9ICFpc0ludmFsaWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IFtcbiAgICAgICAgICAgIC4uLmVycm9yc1xuICAgICAgICBdLFxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogdmFsaWRhdGlvbkRldGFpbHNcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExIGFzIEZvcm1WYWxpZGF0aW9uQ29udGV4dCwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGZjMWEzNjRhZTFmM2ZmMTAgYXMgdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEgYXMgREVGQVVMVF9WQUxJREFUSU9OX1JFU1VMVCwgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMgYXMgVkFMSURfVkFMSURJVFlfU1RBVEUsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWIgYXMgcHJpdmF0ZVZhbGlkYXRpb25TdGF0ZVByb3AsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ3NWVlN2M3NWQ2OGY1YjBlIGFzIG1lcmdlVmFsaWRhdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIiRqY0lPdyRjcmVhdGVDb250ZXh0IiwidXNlTWVtbyIsIiRqY0lPdyR1c2VNZW1vIiwidXNlQ29udGV4dCIsIiRqY0lPdyR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkamNJT3ckdXNlU3RhdGUiLCJ1c2VSZWYiLCIkamNJT3ckdXNlUmVmIiwidXNlRWZmZWN0IiwiJGpjSU93JHVzZUVmZmVjdCIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjIiwiYmFkSW5wdXQiLCJjdXN0b21FcnJvciIsInBhdHRlcm5NaXNtYXRjaCIsInJhbmdlT3ZlcmZsb3ciLCJyYW5nZVVuZGVyZmxvdyIsInN0ZXBNaXNtYXRjaCIsInRvb0xvbmciLCJ0b29TaG9ydCIsInR5cGVNaXNtYXRjaCIsInZhbHVlTWlzc2luZyIsInZhbGlkIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJENVU1RPTV9WQUxJRElUWV9TVEFURSIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhIiwiaXNJbnZhbGlkIiwidmFsaWRhdGlvbkRldGFpbHMiLCJ2YWxpZGF0aW9uRXJyb3JzIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViIiwiRGF0ZSIsIm5vdyIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwIiwicHJvcHMiLCJyZWFsdGltZVZhbGlkYXRpb24iLCJkaXNwbGF5VmFsaWRhdGlvbiIsInVwZGF0ZVZhbGlkYXRpb24iLCJyZXNldFZhbGlkYXRpb24iLCJjb21taXRWYWxpZGF0aW9uIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsIiwidmFsaWRhdGlvblN0YXRlIiwibmFtZSIsInZhbHVlIiwiYnVpbHRpblZhbGlkYXRpb24iLCJ2YWxpZGF0ZSIsInZhbGlkYXRpb25CZWhhdmlvciIsImNvbnRyb2xsZWRFcnJvciIsImNsaWVudEVycm9yIiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGdldFZhbGlkYXRpb25SZXN1bHQiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkcnVuVmFsaWRhdGUiLCJzZXJ2ZXJFcnJvcnMiLCJzZXJ2ZXJFcnJvck1lc3NhZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxhdE1hcCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5IiwibGFzdFNlcnZlckVycm9ycyIsInNldExhc3RTZXJ2ZXJFcnJvcnMiLCJpc1NlcnZlckVycm9yQ2xlYXJlZCIsInNldFNlcnZlckVycm9yQ2xlYXJlZCIsInNlcnZlckVycm9yIiwibmV4dFZhbGlkYXRpb24iLCJjdXJyZW50VmFsaWRpdHkiLCJzZXRDdXJyZW50VmFsaWRpdHkiLCJsYXN0RXJyb3IiLCJjb21taXRRdWV1ZWQiLCJzZXRDb21taXRRdWV1ZWQiLCJlcnJvciIsImN1cnJlbnQiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24iLCJ2IiwiZSIsImVycm9ycyIsImxlbmd0aCIsImEiLCJiIiwiZXZlcnkiLCJpIiwiT2JqZWN0IiwiZW50cmllcyIsImsiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSIsInJlc3VsdHMiLCJTZXQiLCJfdmFsaWRhdGlvbkRldGFpbHMiLCJfa2V5IiwiYWRkIiwia2V5IiwiRm9ybVZhbGlkYXRpb25Db250ZXh0IiwidXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIkRFRkFVTFRfVkFMSURBVElPTl9SRVNVTFQiLCJWQUxJRF9WQUxJRElUWV9TVEFURSIsInByaXZhdGVWYWxpZGF0aW9uU3RhdGVQcm9wIiwibWVyZ2VWYWxpZGF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1QztBQUV4Rzs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU2dCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsV0FBV0EsU0FBUyxFQUFFLEdBQUdGO0lBQ3ZELElBQUlHLGlCQUFpQixDQUFDLEdBQUdiLCtFQUErQixFQUFHVTtJQUMzRCxJQUFJSSxlQUFlLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJTSxNQUFNSSxZQUFZLEdBQUcsSUFBSUMsSUFBSUwsTUFBTUksWUFBWSxJQUFJLElBQUlDLE9BQU87UUFDckdMLE1BQU1JLFlBQVk7S0FDckI7SUFDRCxJQUFJRSxnQkFBZ0JILGVBQWVHLGFBQWE7SUFDaERILGVBQWVHLGFBQWEsR0FBRyxDQUFDQyxLQUFLQztRQUNqQywyRUFBMkU7UUFDM0UsSUFBSU4sY0FBYyxVQUFVSyxPQUFPLE1BQU07WUFDckMsSUFBSUUsT0FBT1IsV0FBV1MsT0FBTyxDQUFDSDtZQUM5QixJQUFJLENBQUNFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxJQUFJLE1BQU0sUUFBUTtnQkFDcEUsSUFBSUMsY0FBY0M7Z0JBQ2xCLElBQUlDLFdBQVcsQ0FBQyxHQUFHOUIscUVBQW1CLEVBQUd5QixNQUFNUjtnQkFDL0MsSUFBSU8sVUFBVSxRQUFRRCxNQUFNLENBQUNLLGVBQWUsQ0FBQyxHQUFHMUIsbUVBQWlCLEVBQUc0QixTQUFRLE1BQU8sUUFBUUYsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFMLEdBQUc7cUJBQ3pJQSxNQUFNLENBQUNNLGdCQUFnQixDQUFDLEdBQUd6QixvRUFBa0IsRUFBRzBCLFNBQVEsTUFBTyxRQUFRRCxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY04sR0FB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Q0FBQzFELE1BQU1ELEdBQUcsR0FBRzRELE9BQU8zRDtZQUNoRjtRQUNKO1FBQ0EsSUFBSTJELFNBQVMsQ0FBQ2pEO1lBQ1YsSUFBSSxDQUFDdUIsTUFBTSxDQUFDMkIsTUFBTSxDQUFDbEQsS0FBS1gsR0FBRztZQUMzQixLQUFLLElBQUlDLFNBQVNVLEtBQUtjLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDRyxHQUFHLENBQUNwQyxNQUFNRCxHQUFHLE1BQU1DLE9BQU8yRCxPQUFPM0Q7UUFDdkY7UUFDQSxJQUFJd0Q7UUFDSlIsS0FBS2EsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BELE1BQU1xRDtZQUN0QixJQUFJQyxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQbEUsS0FBSyxTQUFTZ0U7Z0JBQ2Q1RCxNQUFNO2dCQUNOK0QsT0FBT0M7Z0JBQ1AxQyxlQUFlO2dCQUNmRCxZQUFZO3VCQUNMZCxLQUFLYyxVQUFVO2lCQUNyQjtnQkFDRDRDLFVBQVVEO2dCQUNWRSxXQUFXRjtnQkFDWCxHQUFHekQsSUFBSTtZQUNYO1lBQ0EsSUFBSThDLE1BQU07Z0JBQ05BLEtBQUtqQixPQUFPLEdBQUd5QixRQUFRakUsR0FBRztnQkFDMUJpRSxRQUFRM0IsT0FBTyxHQUFHbUIsS0FBS3pELEdBQUc7WUFDOUIsT0FBT2lFLFFBQVEzQixPQUFPLEdBQUc7WUFDekIsSUFBSSxDQUFDdEIsSUFBSSxDQUFDdUQsSUFBSSxDQUFDTjtZQUNmYixNQUFNYTtZQUNOUixPQUFPUTtRQUNYO1FBQ0EsSUFBSVIsTUFBTUEsS0FBS2pCLE9BQU8sR0FBRztJQUM3QjtBQUNKO0FBSytILENBQy9ILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9ncmlkL2Rpc3QvaW1wb3J0Lm1qcz9iNmEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0Q2hpbGROb2RlcyBhcyAkY0FuNWYkZ2V0Q2hpbGROb2RlcywgZ2V0TGFzdEl0ZW0gYXMgJGNBbjVmJGdldExhc3RJdGVtLCBnZXRGaXJzdEl0ZW0gYXMgJGNBbjVmJGdldEZpcnN0SXRlbX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUgYXMgJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsIFNlbGVjdGlvbk1hbmFnZXIgYXMgJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb25cIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkY0FuNWYkdXNlTWVtbywgdXNlUmVmIGFzICRjQW41ZiR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkY0FuNWYkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkKHByb3BzKSB7XG4gICAgbGV0IHsgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgZm9jdXNNb2RlOiBmb2N1c01vZGUgfSA9IHByb3BzO1xuICAgIGxldCBzZWxlY3Rpb25TdGF0ZSA9ICgwLCAkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSkocHJvcHMpO1xuICAgIGxldCBkaXNhYmxlZEtleXMgPSAoMCwgJGNBbjVmJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IHNldEZvY3VzZWRLZXkgPSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5O1xuICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkgPSAoa2V5LCBjaGlsZCk9PntcbiAgICAgICAgLy8gSWYgZm9jdXNNb2RlIGlzIGNlbGwgYW5kIGFuIGl0ZW0gaXMgZm9jdXNlZCwgZm9jdXMgYSBjaGlsZCBjZWxsIGluc3RlYWQuXG4gICAgICAgIGlmIChmb2N1c01vZGUgPT09IFwiY2VsbFwiICYmIGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0udHlwZSkgPT09IFwiaXRlbVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRMYXN0SXRlbSwgX2dldEZpcnN0SXRlbTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSAoMCwgJGNBbjVmJGdldENoaWxkTm9kZXMpKGl0ZW0sIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gXCJsYXN0XCIpIGtleSA9IChfZ2V0TGFzdEl0ZW0gPSAoMCwgJGNBbjVmJGdldExhc3RJdGVtKShjaGlsZHJlbikpID09PSBudWxsIHx8IF9nZXRMYXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldExhc3RJdGVtLmtleTtcbiAgICAgICAgICAgICAgICBlbHNlIGtleSA9IChfZ2V0Rmlyc3RJdGVtID0gKDAsICRjQW41ZiRnZXRGaXJzdEl0ZW0pKGNoaWxkcmVuKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkKTtcbiAgICB9O1xuICAgIGxldCBzZWxlY3Rpb25NYW5hZ2VyID0gKDAsICRjQW41ZiR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkY0FuNWYkU2VsZWN0aW9uTWFuYWdlcikoY29sbGVjdGlvbiwgc2VsZWN0aW9uU3RhdGUpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIHNlbGVjdGlvblN0YXRlXG4gICAgXSk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBjb25zdCBjYWNoZWRDb2xsZWN0aW9uID0gKDAsICRjQW41ZiR1c2VSZWYpKG51bGwpO1xuICAgICgwLCAkY0FuNWYkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEtleSAhPSBudWxsICYmIChub2RlLnR5cGUgPT09IFwiY2VsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJyb3doZWFkZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiY29sdW1uXCIpID8gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpIDogbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJvd3MgPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQucm93cztcbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBjb2xsZWN0aW9uLnJvd3M7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gY2FjaGVkUm93cy5sZW5ndGggLSByb3dzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKGRpZmYgPiAxID8gTWF0aC5tYXgocGFyZW50Tm9kZS5pbmRleCAtIGRpZmYgKyAxLCAwKSA6IHBhcmVudE5vZGUuaW5kZXgsIHJvd3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgbmV3Um93O1xuICAgICAgICAgICAgd2hpbGUoaW5kZXggPj0gMCl7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25NYW5hZ2VyLmlzRGlzYWJsZWQocm93c1tpbmRleF0ua2V5KSAmJiByb3dzW2luZGV4XS50eXBlICE9PSBcImhlYWRlcnJvd1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IHJvd3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCBuZXh0LCBub3QgZGlzYWJsZWQgcm93LlxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHJvd3MubGVuZ3RoIC0gMSkgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50Tm9kZS5pbmRleCkgaW5kZXggPSBwYXJlbnROb2RlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdSb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLigwLCAkY0FuNWYkZ2V0Q2hpbGROb2RlcykobmV3Um93LCBjb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlUb0ZvY3VzID0gbmV3Um93Lmhhc0NoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSAhPT0gbm9kZSAmJiBub2RlLmluZGV4IDwgY2hpbGROb2Rlcy5sZW5ndGggPyBjaGlsZE5vZGVzW25vZGUuaW5kZXhdLmtleSA6IG5ld1Jvdy5rZXk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShrZXlUb0ZvY3VzKTtcbiAgICAgICAgICAgIH0gZWxzZSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlZENvbGxlY3Rpb24uY3VycmVudCA9IGNvbGxlY3Rpb247XG4gICAgfSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZSxcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlclxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2Qge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICB2YXIgXztcbiAgICAgICAgcmV0dXJuIChfID0gW1xuICAgICAgICAgICAgLi4udGhpcy5yb3dzXG4gICAgICAgIF1bMF0pID09PSBudWxsIHx8IF8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF8ua2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICB2YXIgX3Jvd3NfO1xuICAgICAgICBsZXQgcm93cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKF9yb3dzXyA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX3Jvd3NfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm93c18ua2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2hpbGROb2RlcykgfHwgW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY29sdW1uQ291bnQ7XG4gICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIHRoZSBzYW1lIG9iamVjdCBhcyB0aGUgcHJldmlvdXMgbm9kZSBmb3IgdGhlIHNhbWUga2V5LFxuICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFdlIGFsd2F5cyB2aXNpdCBjb2x1bW5zIHRob3VnaCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZGVwZW5kIG9uIG9yZGVyIHRvIGJ1aWxkIHRoZSBjb2x1bW5zIGFycmF5LlxuICAgICAgICAgICAgbGV0IHByZXZOb2RlID0gdGhpcy5rZXlNYXAuZ2V0KG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZpc2l0Tm9kZSkgbm9kZSA9IG9wdHMudmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY2VsbFwiICYmIGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwgcGFyZW50IGtleSBpc24ndCBhbHJlYWR5IGVzdGFibGlzaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBtYXRjaCBjaGlsZCBub2RlIHRvIHBhcmVudCByb3dcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgICAgICBjaGlsZEtleXMuYWRkKGNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGNoaWxkLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZpc2l0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkZWxldGVkIG5vZGVzIGFuZCB0aGVpciBjaGlsZHJlbiBmcm9tIHRoZSBrZXkgbWFwXG4gICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBwcmV2Tm9kZS5jaGlsZE5vZGVzKWlmICghY2hpbGRLZXlzLmhhcyhjaGlsZC5rZXkpKSByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVtb3ZlID0gKG5vZGUpPT57XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmICh0aGlzLmtleU1hcC5nZXQoY2hpbGQua2V5KSA9PT0gY2hpbGQpIHJlbW92ZShjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBvcHRzLml0ZW1zLmZvckVhY2goKG5vZGUsIGkpPT57XG4gICAgICAgICAgICBsZXQgcm93Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBrZXk6IFwicm93LVwiICsgaSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJvd1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi5ub2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSByb3dOb2RlLmtleTtcbiAgICAgICAgICAgICAgICByb3dOb2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgIH0gZWxzZSByb3dOb2RlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2gocm93Tm9kZSk7XG4gICAgICAgICAgICB2aXNpdChyb3dOb2RlKTtcbiAgICAgICAgICAgIGxhc3QgPSByb3dOb2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhc3QpIGxhc3QubmV4dEtleSA9IG51bGw7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ2Mjk2N2QxMjZmM2FhODIzJGV4cG9ydCQ0MDA3YWMwOWZmOWM2OGVkIGFzIHVzZUdyaWRTdGF0ZSwgJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCBhcyBHcmlkQ29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0Q2hpbGROb2RlcyIsIiRjQW41ZiRnZXRDaGlsZE5vZGVzIiwiZ2V0TGFzdEl0ZW0iLCIkY0FuNWYkZ2V0TGFzdEl0ZW0iLCJnZXRGaXJzdEl0ZW0iLCIkY0FuNWYkZ2V0Rmlyc3RJdGVtIiwidXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIiRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiU2VsZWN0aW9uTWFuYWdlciIsIiRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyIiwidXNlTWVtbyIsIiRjQW41ZiR1c2VNZW1vIiwidXNlUmVmIiwiJGNBbjVmJHVzZVJlZiIsInVzZUVmZmVjdCIsIiRjQW41ZiR1c2VFZmZlY3QiLCIkNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZCIsInByb3BzIiwiY29sbGVjdGlvbiIsImZvY3VzTW9kZSIsInNlbGVjdGlvblN0YXRlIiwiZGlzYWJsZWRLZXlzIiwiU2V0Iiwic2V0Rm9jdXNlZEtleSIsImtleSIsImNoaWxkIiwiaXRlbSIsImdldEl0ZW0iLCJ0eXBlIiwiX2dldExhc3RJdGVtIiwiX2dldEZpcnN0SXRlbSIsImNoaWxkcmVuIiwic2VsZWN0aW9uTWFuYWdlciIsImNhY2hlZENvbGxlY3Rpb24iLCJmb2N1c2VkS2V5Iiwibm9kZSIsImN1cnJlbnQiLCJwYXJlbnROb2RlIiwicGFyZW50S2V5IiwiY2FjaGVkUm93cyIsInJvd3MiLCJkaWZmIiwibGVuZ3RoIiwiaW5kZXgiLCJNYXRoIiwibWluIiwibWF4IiwibmV3Um93IiwiaXNEaXNhYmxlZCIsImNoaWxkTm9kZXMiLCJoYXNDaGlsZE5vZGVzIiwia2V5VG9Gb2N1cyIsImlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCIkMTY4MDViMWIxODA5M2M1ZiRleHBvcnQkZGUzZmRmNjQ5M2MzNTNkIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzaXplIiwiZ2V0S2V5cyIsImtleU1hcCIsImtleXMiLCJnZXRLZXlCZWZvcmUiLCJnZXQiLCJwcmV2S2V5IiwiZ2V0S2V5QWZ0ZXIiLCJuZXh0S2V5IiwiZ2V0Rmlyc3RLZXkiLCJfIiwiZ2V0TGFzdEtleSIsIl9yb3dzXyIsImF0IiwiaWR4IiwiZ2V0Q2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJNYXAiLCJjb2x1bW5Db3VudCIsInZpc2l0IiwicHJldk5vZGUiLCJ2aXNpdE5vZGUiLCJzZXQiLCJjaGlsZEtleXMiLCJsYXN0IiwiYWRkIiwiaGFzIiwicmVtb3ZlIiwiZGVsZXRlIiwiaXRlbXMiLCJmb3JFYWNoIiwiaSIsInJvd05vZGUiLCJsZXZlbCIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVuZGVyZWQiLCJ0ZXh0VmFsdWUiLCJwdXNoIiwidXNlR3JpZFN0YXRlIiwiR3JpZENvbGxlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSjtBQUNUO0FBQzFEO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsTUFBTWdCO0lBQ04sQ0FBQyxDQUFDQyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUNqQixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBLElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDRCxJQUFJO0lBQzNCO0lBQ0FFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxJQUFJO0lBQzNCO0lBQ0FDLGFBQWFDLEdBQUcsRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0UsT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLFlBQVlKLEdBQUcsRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0ksT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDdkI7SUFDQUMsUUFBUVYsR0FBRyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtJQUMzQjtJQUNBVyxHQUFHQyxHQUFHLEVBQUU7UUFDSixNQUFNZCxPQUFPO2VBQ04sSUFBSSxDQUFDRCxPQUFPO1NBQ2xCO1FBQ0QsT0FBTyxJQUFJLENBQUNhLE9BQU8sQ0FBQ1osSUFBSSxDQUFDYyxJQUFJO0lBQ2pDO0lBQ0FDLFlBQVliLEdBQUcsRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBTyxDQUFDQyxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS2EsVUFBVSxLQUFLLEVBQUU7SUFDOUU7SUFDQUMsWUFBWUMsS0FBSyxDQUFDO1FBQ2QsSUFBSSxDQUFDcEIsTUFBTSxHQUFHLElBQUlxQjtRQUNsQixJQUFJLENBQUN2QixRQUFRLEdBQUdzQjtRQUNoQixJQUFJRSxRQUFRLENBQUNqQjtZQUNULElBQUksQ0FBQ0wsTUFBTSxDQUFDdUIsR0FBRyxDQUFDbEIsS0FBS0QsR0FBRyxFQUFFQztZQUMxQixJQUFJQSxLQUFLYSxVQUFVLElBQUliLEtBQUttQixJQUFJLEtBQUssV0FBVyxLQUFLLElBQUlDLFNBQVNwQixLQUFLYSxVQUFVLENBQUNJLE1BQU1HO1FBQzVGO1FBQ0EsS0FBSyxJQUFJcEIsUUFBUWUsTUFBTUUsTUFBTWpCO1FBQzdCLElBQUlxQjtRQUNKLElBQUlDLFFBQVE7UUFDWixLQUFLLElBQUksQ0FBQ3ZCLEtBQUtDLEtBQUssSUFBSSxJQUFJLENBQUNMLE1BQU0sQ0FBQztZQUNoQyxJQUFJMEIsTUFBTTtnQkFDTkEsS0FBS2pCLE9BQU8sR0FBR0w7Z0JBQ2ZDLEtBQUtFLE9BQU8sR0FBR21CLEtBQUt0QixHQUFHO1lBQzNCLE9BQU87Z0JBQ0gsSUFBSSxDQUFDTyxRQUFRLEdBQUdQO2dCQUNoQkMsS0FBS0UsT0FBTyxHQUFHcUI7WUFDbkI7WUFDQSxJQUFJdkIsS0FBS21CLElBQUksS0FBSyxRQUFRbkIsS0FBS3NCLEtBQUssR0FBR0E7WUFDdkNELE9BQU9yQjtZQUNQLDZEQUE2RDtZQUM3RCxpRkFBaUY7WUFDakZxQixLQUFLakIsT0FBTyxHQUFHbUI7UUFDbkI7UUFDQSxJQUFJLENBQUNmLE9BQU8sR0FBR2EsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUt0QixHQUFHO0lBQ3ZFO0FBQ0o7QUFNQSxTQUFTeUIsMENBQTBDQyxLQUFLO0lBQ3BELElBQUksRUFBRUMsUUFBUUEsTUFBTSxFQUFFLEdBQUdEO0lBQ3pCLElBQUlFLGlCQUFpQixDQUFDLEdBQUdwRCwrRUFBK0IsRUFBR2tEO0lBQzNELElBQUlHLGVBQWUsQ0FBQyxHQUFHakQsMENBQWEsRUFBRyxJQUFJOEMsTUFBTUcsWUFBWSxHQUFHLElBQUlDLElBQUlKLE1BQU1HLFlBQVksSUFBSSxJQUFJQyxPQUFPO1FBQ3JHSixNQUFNRyxZQUFZO0tBQ3JCO0lBQ0QsSUFBSUUsVUFBVSxDQUFDLEdBQUdqRCw4Q0FBaUIsRUFBRyxDQUFDa0MsUUFBUVcsU0FBUyxJQUFLLElBQUdwQyx5Q0FBd0MsRUFBR29DLE9BQU9YLFVBQVUsSUFBSyxJQUFHekIseUNBQXdDLEVBQUd5QixRQUFRO1FBQ25MVztLQUNIO0lBQ0QsSUFBSUssVUFBVSxDQUFDLEdBQUdwRCwwQ0FBYSxFQUFHLElBQUs7WUFDL0JxRCwwQkFBMEJQLE1BQU1PLHdCQUF3QjtRQUM1RCxJQUFJO1FBQ0pQLE1BQU1PLHdCQUF3QjtLQUNqQztJQUNELElBQUlDLGFBQWEsQ0FBQyxHQUFHOUMscUVBQW1CLEVBQUdzQyxPQUFPSyxTQUFTQztJQUMzRCxJQUFJRyxtQkFBbUIsQ0FBQyxHQUFHdkQsMENBQWEsRUFBRyxJQUFJLElBQUssSUFBR0Ysc0VBQXNCLEVBQUd3RCxZQUFZTixpQkFBaUI7UUFDekdNO1FBQ0FOO0tBQ0g7SUFDRCxpRUFBaUU7SUFDakUsTUFBTVEsbUJBQW1CLENBQUMsR0FBR3BELHlDQUFZLEVBQUc7SUFDM0MsSUFBR0UsNENBQWUsRUFBRztRQUNsQixJQUFJMEMsZUFBZVMsVUFBVSxJQUFJLFFBQVEsQ0FBQ0gsV0FBV3hCLE9BQU8sQ0FBQ2tCLGVBQWVTLFVBQVUsR0FBRztZQUNyRixNQUFNQyxZQUFZRixpQkFBaUJHLE9BQU8sQ0FBQzdCLE9BQU8sQ0FBQ2tCLGVBQWVTLFVBQVU7WUFDNUUsTUFBTUcsa0JBQWtCO21CQUNqQkosaUJBQWlCRyxPQUFPLENBQUMxQyxPQUFPO2FBQ3RDLENBQUM0QyxHQUFHLENBQUMsQ0FBQ3pDO2dCQUNILE1BQU0wQyxXQUFXTixpQkFBaUJHLE9BQU8sQ0FBQzdCLE9BQU8sQ0FBQ1Y7Z0JBQ2xELE9BQU8wQyxTQUFTdEIsSUFBSSxLQUFLLFNBQVNzQixXQUFXO1lBQ2pELEdBQUdmLE1BQU0sQ0FBQyxDQUFDMUIsT0FBT0EsU0FBUztZQUMzQixNQUFNMEMsWUFBWTttQkFDWFQsV0FBV3JDLE9BQU87YUFDeEIsQ0FBQzRDLEdBQUcsQ0FBQyxDQUFDekM7Z0JBQ0gsTUFBTTBDLFdBQVdSLFdBQVd4QixPQUFPLENBQUNWO2dCQUNwQyxPQUFPMEMsU0FBU3RCLElBQUksS0FBSyxTQUFTc0IsV0FBVztZQUNqRCxHQUFHZixNQUFNLENBQUMsQ0FBQzFCLE9BQU9BLFNBQVM7WUFDM0IsTUFBTTJDLE9BQU9KLGdCQUFnQkssTUFBTSxHQUFHRixVQUFVRSxNQUFNO1lBQ3RELElBQUl0QixRQUFRdUIsS0FBS0MsR0FBRyxDQUFDSCxPQUFPLElBQUlFLEtBQUtFLEdBQUcsQ0FBQ1YsVUFBVWYsS0FBSyxHQUFHcUIsT0FBTyxHQUFHLEtBQUtOLFVBQVVmLEtBQUssRUFBRW9CLFVBQVVFLE1BQU0sR0FBRztZQUM5RyxJQUFJSTtZQUNKLE1BQU0xQixTQUFTLEVBQUU7Z0JBQ2IsSUFBSSxDQUFDWSxpQkFBaUJlLFVBQVUsQ0FBQ1AsU0FBUyxDQUFDcEIsTUFBTSxDQUFDdkIsR0FBRyxHQUFHO29CQUNwRGlELFVBQVVOLFNBQVMsQ0FBQ3BCLE1BQU07b0JBQzFCO2dCQUNKO2dCQUNBLGdDQUFnQztnQkFDaEMsSUFBSUEsUUFBUW9CLFVBQVVFLE1BQU0sR0FBRyxHQUFHdEI7cUJBQzdCO29CQUNELElBQUlBLFFBQVFlLFVBQVVmLEtBQUssRUFBRUEsUUFBUWUsVUFBVWYsS0FBSztvQkFDcERBO2dCQUNKO1lBQ0o7WUFDQUssZUFBZXVCLGFBQWEsQ0FBQ0YsVUFBVUEsUUFBUWpELEdBQUcsR0FBRztRQUN6RDtRQUNBb0MsaUJBQWlCRyxPQUFPLEdBQUdMO0lBQy9CLEdBQUc7UUFDQ0E7UUFDQUM7UUFDQVA7UUFDQUEsZUFBZVMsVUFBVTtLQUM1QjtJQUNELE9BQU87UUFDSEgsWUFBWUE7UUFDWkwsY0FBY0E7UUFDZE0sa0JBQWtCQTtJQUN0QjtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUdELFNBQVNpQiwwQ0FBMEMxQixLQUFLO0lBQ3BELElBQUkyQjtJQUNKLElBQUksQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHLENBQUMsR0FBR2pFLG9FQUF3QixFQUFHb0MsTUFBTTRCLFdBQVcsRUFBRSxDQUFDRCw0QkFBNEIzQixNQUFNOEIsa0JBQWtCLE1BQU0sUUFBUUgsOEJBQThCLEtBQUssSUFBSUEsNEJBQTRCLE1BQU0zQixNQUFNK0IsaUJBQWlCO0lBQ3pQLElBQUlDLGVBQWUsQ0FBQyxHQUFHOUUsMENBQWEsRUFBRyxJQUFJMEUsZUFBZSxPQUFPO1lBQ3pEQTtTQUNILEdBQUcsRUFBRSxFQUFFO1FBQ1JBO0tBQ0g7SUFDRCxJQUFJLEVBQUVwQixZQUFZQSxVQUFVLEVBQUVMLGNBQWNBLFlBQVksRUFBRU0sa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsR0FBR1YseUNBQXdDLEVBQUc7UUFDNUksR0FBR0MsS0FBSztRQUNSaUMsZUFBZTtRQUNmQyx3QkFBd0I7UUFDeEJDLCtCQUErQjtRQUMvQkgsY0FBY0E7UUFDZEQsbUJBQW1CLENBQUMzRDtZQUNoQixJQUFJZ0U7WUFDSixJQUFJOUQsTUFBTSxDQUFDOEQsMEJBQTBCaEUsS0FBS2lFLE1BQU0sR0FBR0MsSUFBSSxHQUFHQyxLQUFLLE1BQU0sUUFBUUgsNEJBQTRCLEtBQUssSUFBSUEsMEJBQTBCO1lBQzVJLDZEQUE2RDtZQUM3RCxvREFBb0Q7WUFDcEQsSUFBSTlELFFBQVFzRCxlQUFlNUIsTUFBTStCLGlCQUFpQixFQUFFL0IsTUFBTStCLGlCQUFpQixDQUFDekQ7WUFDNUV1RCxlQUFldkQ7UUFDbkI7SUFDSjtJQUNBLElBQUlrRSxlQUFlWixlQUFlLE9BQU9wQixXQUFXeEIsT0FBTyxDQUFDNEMsZUFBZTtJQUMzRSxPQUFPO1FBQ0hwQixZQUFZQTtRQUNaTCxjQUFjQTtRQUNkTSxrQkFBa0JBO1FBQ2xCbUIsYUFBYUE7UUFDYkMsZ0JBQWdCQTtRQUNoQlcsY0FBY0E7SUFDbEI7QUFDSjtBQU11TSxDQUN2TSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNpZ24tZW5naW5lZXIvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanM/NTAxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUgYXMgJDU4UGhzJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsIFNlbGVjdGlvbk1hbmFnZXIgYXMgJDU4UGhzJFNlbGVjdGlvbk1hbmFnZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb25cIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkNThQaHMkdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDU4UGhzJHVzZUNhbGxiYWNrLCB1c2VSZWYgYXMgJDU4UGhzJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQ1OFBocyR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VDb2xsZWN0aW9uIGFzICQ1OFBocyR1c2VDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQ1OFBocyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0S2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuY2hpbGROb2RlcykgfHwgW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5vZGVzKXtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBub2RlcztcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLnR5cGUgPT09IFwic2VjdGlvblwiKSBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXZpc2l0KG5vZGUpO1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbm9kZV0gb2YgdGhpcy5rZXlNYXApe1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJpdGVtXCIpIG5vZGUuaW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgICAgICAgICAvLyBTZXQgbmV4dEtleSBhcyB1bmRlZmluZWQgc2luY2UgdGhpcyBtaWdodCBiZSB0aGUgbGFzdCBub2RlXG4gICAgICAgICAgICAvLyBJZiBpdCBpc24ndCB0aGUgbGFzdCBub2RlLCBsYXN0Lm5leHRLZXkgd2lsbCBwcm9wZXJseSBzZXQgYXQgc3RhcnQgb2YgbmV3IGxvb3BcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RLZXkgPSBsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3Qua2V5O1xuICAgIH1cbn1cblxuXG5cblxuXG5mdW5jdGlvbiAkZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NChwcm9wcykge1xuICAgIGxldCB7IGZpbHRlcjogZmlsdGVyIH0gPSBwcm9wcztcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJDU4UGhzJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBmYWN0b3J5ID0gKDAsICQ1OFBocyR1c2VDYWxsYmFjaykoKG5vZGVzKT0+ZmlsdGVyID8gbmV3ICgwLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNykoZmlsdGVyKG5vZGVzKSkgOiBuZXcgKDAsICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3KShub2RlcyksIFtcbiAgICAgICAgZmlsdGVyXG4gICAgXSk7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nOiBwcm9wcy5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmdcbiAgICAgICAgfSksIFtcbiAgICAgICAgcHJvcHMuc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nXG4gICAgXSk7XG4gICAgbGV0IGNvbGxlY3Rpb24gPSAoMCwgJDU4UGhzJHVzZUNvbGxlY3Rpb24pKHByb3BzLCBmYWN0b3J5LCBjb250ZXh0KTtcbiAgICBsZXQgc2VsZWN0aW9uTWFuYWdlciA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDU4UGhzJFNlbGVjdGlvbk1hbmFnZXIpKGNvbGxlY3Rpb24sIHNlbGVjdGlvblN0YXRlKSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZVxuICAgIF0pO1xuICAgIC8vIFJlc2V0IGZvY3VzZWQga2V5IGlmIHRoYXQgaXRlbSBpcyBkZWxldGVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgY29uc3QgY2FjaGVkQ29sbGVjdGlvbiA9ICgwLCAkNThQaHMkdXNlUmVmKShudWxsKTtcbiAgICAoMCwgJDU4UGhzJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEl0ZW0gPSBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEl0ZW1Ob2RlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5jYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQuZ2V0S2V5cygpXG4gICAgICAgICAgICBdLm1hcCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbU5vZGUudHlwZSA9PT0gXCJpdGVtXCIgPyBpdGVtTm9kZSA6IG51bGw7XG4gICAgICAgICAgICB9KS5maWx0ZXIoKG5vZGUpPT5ub2RlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1Ob2RlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5jb2xsZWN0aW9uLmdldEtleXMoKVxuICAgICAgICAgICAgXS5tYXAoKGtleSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtTm9kZS50eXBlID09PSBcIml0ZW1cIiA/IGl0ZW1Ob2RlIDogbnVsbDtcbiAgICAgICAgICAgIH0pLmZpbHRlcigobm9kZSk9Pm5vZGUgIT09IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNhY2hlZEl0ZW1Ob2Rlcy5sZW5ndGggLSBpdGVtTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5taW4oZGlmZiA+IDEgPyBNYXRoLm1heChzdGFydEl0ZW0uaW5kZXggLSBkaWZmICsgMSwgMCkgOiBzdGFydEl0ZW0uaW5kZXgsIGl0ZW1Ob2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGxldCBuZXdOb2RlO1xuICAgICAgICAgICAgd2hpbGUoaW5kZXggPj0gMCl7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25NYW5hZ2VyLmlzRGlzYWJsZWQoaXRlbU5vZGVzW2luZGV4XS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBpdGVtTm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCBuZXh0LCBub3QgZGlzYWJsZWQgaXRlbS5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBpdGVtTm9kZXMubGVuZ3RoIC0gMSkgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gc3RhcnRJdGVtLmluZGV4KSBpbmRleCA9IHN0YXJ0SXRlbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG5ld05vZGUgPyBuZXdOb2RlLmtleSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlZENvbGxlY3Rpb24uY3VycmVudCA9IGNvbGxlY3Rpb247XG4gICAgfSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZSxcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyXG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuZnVuY3Rpb24gJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYocHJvcHMpIHtcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleTtcbiAgICBsZXQgW3NlbGVjdGVkS2V5LCBzZXRTZWxlY3RlZEtleV0gPSAoMCwgJDU4UGhzJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuc2VsZWN0ZWRLZXksIChfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5ID0gcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5KSAhPT0gbnVsbCAmJiBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5ICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5IDogbnVsbCwgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIGxldCBzZWxlY3RlZEtleXMgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5zZWxlY3RlZEtleSAhPSBudWxsID8gW1xuICAgICAgICAgICAgc2VsZWN0ZWRLZXlcbiAgICAgICAgXSA6IFtdLCBbXG4gICAgICAgIHNlbGVjdGVkS2V5XG4gICAgXSk7XG4gICAgbGV0IHsgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIgfSA9ICgwLCAkZTcyZGQ3MmUxYzc2YTIyNSRleHBvcnQkMmY2NDU2NDVmN2JjYTc2NCkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogXCJzaW5nbGVcIixcbiAgICAgICAgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IHRydWUsXG4gICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZTogKGtleXMpPT57XG4gICAgICAgICAgICB2YXIgX2tleXNfdmFsdWVzX25leHRfdmFsdWU7XG4gICAgICAgICAgICBsZXQga2V5ID0gKF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlID0ga2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpICE9PSBudWxsICYmIF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlICE9PSB2b2lkIDAgPyBfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAvLyBBbHdheXMgZmlyZSBvblNlbGVjdGlvbkNoYW5nZSwgZXZlbiBpZiB0aGUga2V5IGlzIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBhcyB0aGUgY3VycmVudCBrZXkgKHVzZUNvbnRyb2xsZWRTdGF0ZSBkb2VzIG5vdCkuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZEtleSAmJiBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSkgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2Uoa2V5KTtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRLZXkgIT0gbnVsbCA/IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXksXG4gICAgICAgIHNldFNlbGVjdGVkS2V5OiBzZXRTZWxlY3RlZEtleSxcbiAgICAgICAgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW1cbiAgICB9O1xufVxuXG5cblxuXG5cbmV4cG9ydCB7JGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQgYXMgdXNlTGlzdFN0YXRlLCAkYTBkNjQ1Mjg5ZmU5Yjg2YiRleHBvcnQkZTdmMDVlOTg1ZGFmNGI1ZiBhcyB1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUsICRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3IGFzIExpc3RDb2xsZWN0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiJDU4UGhzJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIiwiJDU4UGhzJFNlbGVjdGlvbk1hbmFnZXIiLCJ1c2VNZW1vIiwiJDU4UGhzJHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiQ1OFBocyR1c2VDYWxsYmFjayIsInVzZVJlZiIsIiQ1OFBocyR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkNThQaHMkdXNlRWZmZWN0IiwidXNlQ29sbGVjdGlvbiIsIiQ1OFBocyR1c2VDb2xsZWN0aW9uIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJDU4UGhzJHVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRhMDJkNTcwNDlkMjAyNjk1JGV4cG9ydCRkMDg1ZmI5ZTkyMGI1Y2E3IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpdGVyYWJsZSIsInNpemUiLCJrZXlNYXAiLCJnZXRLZXlzIiwia2V5cyIsImdldEtleUJlZm9yZSIsImtleSIsIm5vZGUiLCJnZXQiLCJwcmV2S2V5IiwiZ2V0S2V5QWZ0ZXIiLCJuZXh0S2V5IiwiZ2V0Rmlyc3RLZXkiLCJmaXJzdEtleSIsImdldExhc3RLZXkiLCJsYXN0S2V5IiwiZ2V0SXRlbSIsImF0IiwiaWR4IiwiZ2V0Q2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwiY29uc3RydWN0b3IiLCJub2RlcyIsIk1hcCIsInZpc2l0Iiwic2V0IiwidHlwZSIsImNoaWxkIiwibGFzdCIsImluZGV4IiwidW5kZWZpbmVkIiwiJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQiLCJwcm9wcyIsImZpbHRlciIsInNlbGVjdGlvblN0YXRlIiwiZGlzYWJsZWRLZXlzIiwiU2V0IiwiZmFjdG9yeSIsImNvbnRleHQiLCJzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmciLCJjb2xsZWN0aW9uIiwic2VsZWN0aW9uTWFuYWdlciIsImNhY2hlZENvbGxlY3Rpb24iLCJmb2N1c2VkS2V5Iiwic3RhcnRJdGVtIiwiY3VycmVudCIsImNhY2hlZEl0ZW1Ob2RlcyIsIm1hcCIsIml0ZW1Ob2RlIiwiaXRlbU5vZGVzIiwiZGlmZiIsImxlbmd0aCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJuZXdOb2RlIiwiaXNEaXNhYmxlZCIsInNldEZvY3VzZWRLZXkiLCIkYTBkNjQ1Mjg5ZmU5Yjg2YiRleHBvcnQkZTdmMDVlOTg1ZGFmNGI1ZiIsIl9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkiLCJzZWxlY3RlZEtleSIsInNldFNlbGVjdGVkS2V5IiwiZGVmYXVsdFNlbGVjdGVkS2V5Iiwib25TZWxlY3Rpb25DaGFuZ2UiLCJzZWxlY3RlZEtleXMiLCJzZWxlY3Rpb25Nb2RlIiwiZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiIsImFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzIiwiX2tleXNfdmFsdWVzX25leHRfdmFsdWUiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJzZWxlY3RlZEl0ZW0iLCJ1c2VMaXN0U3RhdGUiLCJ1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCJMaXN0Q29sbGVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_useSubmenuTriggerState: () => (/* binding */ $e5614764aa47eb35$export$d39fdbfa42246ac4),\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [expandedKeysStack, setExpandedKeysStack] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let closeAll = ()=>{\n        setExpandedKeysStack([]);\n        overlayTriggerState.close();\n    };\n    let openSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            if (level > oldStack.length) return oldStack;\n            return [\n                ...oldStack.slice(0, level),\n                triggerKey\n            ];\n        });\n    };\n    let closeSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            let key = oldStack[level];\n            if (key === triggerKey) return oldStack.slice(0, level);\n            else return oldStack;\n        });\n    };\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        },\n        close () {\n            closeAll();\n        },\n        UNSTABLE_expandedKeysStack: expandedKeysStack,\n        UNSTABLE_openSubmenu: openSubmenu,\n        UNSTABLE_closeSubmenu: closeSubmenu\n    };\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e5614764aa47eb35$export$d39fdbfa42246ac4(props, state) {\n    let { triggerKey: triggerKey } = props;\n    let { UNSTABLE_expandedKeysStack: UNSTABLE_expandedKeysStack, UNSTABLE_openSubmenu: UNSTABLE_openSubmenu, UNSTABLE_closeSubmenu: UNSTABLE_closeSubmenu, close: closeAll } = state;\n    let [submenuLevel] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNSTABLE_expandedKeysStack === null || UNSTABLE_expandedKeysStack === void 0 ? void 0 : UNSTABLE_expandedKeysStack.length);\n    let isOpen = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>UNSTABLE_expandedKeysStack[submenuLevel] === triggerKey, [\n        UNSTABLE_expandedKeysStack,\n        triggerKey,\n        submenuLevel\n    ]);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        UNSTABLE_openSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_openSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFocusStrategy(null);\n        UNSTABLE_closeSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_closeSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        if (isOpen) close();\n        else open(focusStrategy);\n    }, [\n        close,\n        open,\n        isOpen\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusStrategy: focusStrategy,\n            isOpen: isOpen,\n            open: open,\n            close: close,\n            closeAll: closeAll,\n            submenuLevel: submenuLevel,\n            // TODO: Placeholders that aren't used but give us parity with OverlayTriggerState so we can use this in Popover. Refactor if we update Popover via\n            // https://github.com/adobe/react-spectrum/pull/4976#discussion_r1336472863\n            setOpen: ()=>{},\n            toggle: toggle\n        }), [\n        isOpen,\n        open,\n        close,\n        closeAll,\n        focusStrategy,\n        toggle,\n        submenuLevel\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNnQjtBQUVoSDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNRLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxzQkFBc0IsQ0FBQyxHQUFHVCwyRUFBNEIsRUFBR1E7SUFDN0QsSUFBSSxDQUFDRSxlQUFlQyxpQkFBaUIsR0FBRyxDQUFDLEdBQUdULDJDQUFjLEVBQUc7SUFDN0QsSUFBSSxDQUFDVSxtQkFBbUJDLHFCQUFxQixHQUFHLENBQUMsR0FBR1gsMkNBQWMsRUFBRyxFQUFFO0lBQ3ZFLElBQUlZLFdBQVc7UUFDWEQscUJBQXFCLEVBQUU7UUFDdkJKLG9CQUFvQk0sS0FBSztJQUM3QjtJQUNBLElBQUlDLGNBQWMsQ0FBQ0MsWUFBWUM7UUFDM0JMLHFCQUFxQixDQUFDTTtZQUNsQixJQUFJRCxRQUFRQyxTQUFTQyxNQUFNLEVBQUUsT0FBT0Q7WUFDcEMsT0FBTzttQkFDQUEsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2dCQUNyQkQ7YUFDSDtRQUNMO0lBQ0o7SUFDQSxJQUFJSyxlQUFlLENBQUNMLFlBQVlDO1FBQzVCTCxxQkFBcUIsQ0FBQ007WUFDbEIsSUFBSUksTUFBTUosUUFBUSxDQUFDRCxNQUFNO1lBQ3pCLElBQUlLLFFBQVFOLFlBQVksT0FBT0UsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2lCQUM1QyxPQUFPQztRQUNoQjtJQUNKO0lBQ0EsT0FBTztRQUNIVCxlQUFlQTtRQUNmLEdBQUdELG1CQUFtQjtRQUN0QmUsTUFBTWQsZ0JBQWdCLElBQUk7WUFDdEJDLGlCQUFpQkQ7WUFDakJELG9CQUFvQmUsSUFBSTtRQUM1QjtRQUNBQyxRQUFRZixnQkFBZ0IsSUFBSTtZQUN4QkMsaUJBQWlCRDtZQUNqQkQsb0JBQW9CZ0IsTUFBTTtRQUM5QjtRQUNBVjtZQUNJRDtRQUNKO1FBQ0FZLDRCQUE0QmQ7UUFDNUJlLHNCQUFzQlg7UUFDdEJZLHVCQUF1Qk47SUFDM0I7QUFDSjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTTywwQ0FBMENyQixLQUFLLEVBQUVzQixLQUFLO0lBQzNELElBQUksRUFBRWIsWUFBWUEsVUFBVSxFQUFFLEdBQUdUO0lBQ2pDLElBQUksRUFBRWtCLDRCQUE0QkEsMEJBQTBCLEVBQUVDLHNCQUFzQkEsb0JBQW9CLEVBQUVDLHVCQUF1QkEscUJBQXFCLEVBQUViLE9BQU9ELFFBQVEsRUFBRSxHQUFHZ0I7SUFDNUssSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxHQUFHN0IsMkNBQWMsRUFBR3dCLCtCQUErQixRQUFRQSwrQkFBK0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsMkJBQTJCTixNQUFNO0lBQ25LLElBQUlZLFNBQVMsQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFJc0IsMEJBQTBCLENBQUNLLGFBQWEsS0FBS2QsWUFBWTtRQUMxRlM7UUFDQVQ7UUFDQWM7S0FDSDtJQUNELElBQUksQ0FBQ3JCLGVBQWVDLGlCQUFpQixHQUFHLENBQUMsR0FBR1QsMkNBQWMsRUFBRztJQUM3RCxJQUFJc0IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDSSxnQkFBZ0IsSUFBSTtRQUNwREMsaUJBQWlCRDtRQUNqQmlCLHFCQUFxQlYsWUFBWWM7SUFDckMsR0FBRztRQUNDSjtRQUNBSTtRQUNBZDtLQUNIO0lBQ0QsSUFBSUYsUUFBUSxDQUFDLEdBQUdULDhDQUFpQixFQUFHO1FBQ2hDSyxpQkFBaUI7UUFDakJpQixzQkFBc0JYLFlBQVljO0lBQ3RDLEdBQUc7UUFDQ0g7UUFDQUc7UUFDQWQ7S0FDSDtJQUNELElBQUlRLFNBQVMsQ0FBQyxHQUFHbkIsOENBQWlCLEVBQUcsQ0FBQ0ksZ0JBQWdCLElBQUk7UUFDdERDLGlCQUFpQkQ7UUFDakIsSUFBSXNCLFFBQVFqQjthQUNQUyxLQUFLZDtJQUNkLEdBQUc7UUFDQ0s7UUFDQVM7UUFDQVE7S0FDSDtJQUNELE9BQU8sQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFLO1lBQ3hCTSxlQUFlQTtZQUNmc0IsUUFBUUE7WUFDUlIsTUFBTUE7WUFDTlQsT0FBT0E7WUFDUEQsVUFBVUE7WUFDVmlCLGNBQWNBO1lBQ2QsbUpBQW1KO1lBQ25KLDJFQUEyRTtZQUMzRUUsU0FBUyxLQUFLO1lBQ2RSLFFBQVFBO1FBQ1osSUFBSTtRQUNKTztRQUNBUjtRQUNBVDtRQUNBRDtRQUNBSjtRQUNBZTtRQUNBTTtLQUNIO0FBQ0w7QUFLd0osQ0FDeEosa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L21lbnUvZGlzdC9pbXBvcnQubWpzPzFiNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VPdmVybGF5VHJpZ2dlclN0YXRlIGFzICQ5WHZvaCR1c2VPdmVybGF5VHJpZ2dlclN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjtcbmltcG9ydCB7dXNlU3RhdGUgYXMgJDlYdm9oJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ5WHZvaCR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkOVh2b2gkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkYTI4YzkwM2VlOWFkOGRjNSRleHBvcnQkNzlmZWZlYjFjMjA5MWFjMyhwcm9wcykge1xuICAgIGxldCBvdmVybGF5VHJpZ2dlclN0YXRlID0gKDAsICQ5WHZvaCR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKShwcm9wcyk7XG4gICAgbGV0IFtmb2N1c1N0cmF0ZWd5LCBzZXRGb2N1c1N0cmF0ZWd5XSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBbZXhwYW5kZWRLZXlzU3RhY2ssIHNldEV4cGFuZGVkS2V5c1N0YWNrXSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKFtdKTtcbiAgICBsZXQgY2xvc2VBbGwgPSAoKT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXNTdGFjayhbXSk7XG4gICAgICAgIG92ZXJsYXlUcmlnZ2VyU3RhdGUuY2xvc2UoKTtcbiAgICB9O1xuICAgIGxldCBvcGVuU3VibWVudSA9ICh0cmlnZ2VyS2V5LCBsZXZlbCk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzU3RhY2soKG9sZFN0YWNrKT0+e1xuICAgICAgICAgICAgaWYgKGxldmVsID4gb2xkU3RhY2subGVuZ3RoKSByZXR1cm4gb2xkU3RhY2s7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm9sZFN0YWNrLnNsaWNlKDAsIGxldmVsKSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGxldCBjbG9zZVN1Ym1lbnUgPSAodHJpZ2dlcktleSwgbGV2ZWwpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKChvbGRTdGFjayk9PntcbiAgICAgICAgICAgIGxldCBrZXkgPSBvbGRTdGFja1tsZXZlbF07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0cmlnZ2VyS2V5KSByZXR1cm4gb2xkU3RhY2suc2xpY2UoMCwgbGV2ZWwpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gb2xkU3RhY2s7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcbiAgICAgICAgLi4ub3ZlcmxheVRyaWdnZXJTdGF0ZSxcbiAgICAgICAgb3BlbiAoZm9jdXNTdHJhdGVneSA9IG51bGwpIHtcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLm9wZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlIChmb2N1c1N0cmF0ZWd5ID0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShmb2N1c1N0cmF0ZWd5KTtcbiAgICAgICAgICAgIG92ZXJsYXlUcmlnZ2VyU3RhdGUudG9nZ2xlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlICgpIHtcbiAgICAgICAgICAgIGNsb3NlQWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrOiBleHBhbmRlZEtleXNTdGFjayxcbiAgICAgICAgVU5TVEFCTEVfb3BlblN1Ym1lbnU6IG9wZW5TdWJtZW51LFxuICAgICAgICBVTlNUQUJMRV9jbG9zZVN1Ym1lbnU6IGNsb3NlU3VibWVudVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGU1NjE0NzY0YWE0N2ViMzUkZXhwb3J0JGQzOWZkYmZhNDIyNDZhYzQocHJvcHMsIHN0YXRlKSB7XG4gICAgbGV0IHsgdHJpZ2dlcktleTogdHJpZ2dlcktleSB9ID0gcHJvcHM7XG4gICAgbGV0IHsgVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2s6IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLCBVTlNUQUJMRV9vcGVuU3VibWVudTogVU5TVEFCTEVfb3BlblN1Ym1lbnUsIFVOU1RBQkxFX2Nsb3NlU3VibWVudTogVU5TVEFCTEVfY2xvc2VTdWJtZW51LCBjbG9zZTogY2xvc2VBbGwgfSA9IHN0YXRlO1xuICAgIGxldCBbc3VibWVudUxldmVsXSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrID09PSBudWxsIHx8IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjay5sZW5ndGgpO1xuICAgIGxldCBpc09wZW4gPSAoMCwgJDlYdm9oJHVzZU1lbW8pKCgpPT5VTlNUQUJMRV9leHBhbmRlZEtleXNTdGFja1tzdWJtZW51TGV2ZWxdID09PSB0cmlnZ2VyS2V5LCBbXG4gICAgICAgIFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrLFxuICAgICAgICB0cmlnZ2VyS2V5LFxuICAgICAgICBzdWJtZW51TGV2ZWxcbiAgICBdKTtcbiAgICBsZXQgW2ZvY3VzU3RyYXRlZ3ksIHNldEZvY3VzU3RyYXRlZ3ldID0gKDAsICQ5WHZvaCR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IG9wZW4gPSAoMCwgJDlYdm9oJHVzZUNhbGxiYWNrKSgoZm9jdXNTdHJhdGVneSA9IG51bGwpPT57XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgIFVOU1RBQkxFX29wZW5TdWJtZW51KHRyaWdnZXJLZXksIHN1Ym1lbnVMZXZlbCk7XG4gICAgfSwgW1xuICAgICAgICBVTlNUQUJMRV9vcGVuU3VibWVudSxcbiAgICAgICAgc3VibWVudUxldmVsLFxuICAgICAgICB0cmlnZ2VyS2V5XG4gICAgXSk7XG4gICAgbGV0IGNsb3NlID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0Rm9jdXNTdHJhdGVneShudWxsKTtcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51KHRyaWdnZXJLZXksIHN1Ym1lbnVMZXZlbCk7XG4gICAgfSwgW1xuICAgICAgICBVTlNUQUJMRV9jbG9zZVN1Ym1lbnUsXG4gICAgICAgIHN1Ym1lbnVMZXZlbCxcbiAgICAgICAgdHJpZ2dlcktleVxuICAgIF0pO1xuICAgIGxldCB0b2dnbGUgPSAoMCwgJDlYdm9oJHVzZUNhbGxiYWNrKSgoZm9jdXNTdHJhdGVneSA9IG51bGwpPT57XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgIGlmIChpc09wZW4pIGNsb3NlKCk7XG4gICAgICAgIGVsc2Ugb3Blbihmb2N1c1N0cmF0ZWd5KTtcbiAgICB9LCBbXG4gICAgICAgIGNsb3NlLFxuICAgICAgICBvcGVuLFxuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICByZXR1cm4gKDAsICQ5WHZvaCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIGZvY3VzU3RyYXRlZ3k6IGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgICAgICBjbG9zZUFsbDogY2xvc2VBbGwsXG4gICAgICAgICAgICBzdWJtZW51TGV2ZWw6IHN1Ym1lbnVMZXZlbCxcbiAgICAgICAgICAgIC8vIFRPRE86IFBsYWNlaG9sZGVycyB0aGF0IGFyZW4ndCB1c2VkIGJ1dCBnaXZlIHVzIHBhcml0eSB3aXRoIE92ZXJsYXlUcmlnZ2VyU3RhdGUgc28gd2UgY2FuIHVzZSB0aGlzIGluIFBvcG92ZXIuIFJlZmFjdG9yIGlmIHdlIHVwZGF0ZSBQb3BvdmVyIHZpYVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL3B1bGwvNDk3NiNkaXNjdXNzaW9uX3IxMzM2NDcyODYzXG4gICAgICAgICAgICBzZXRPcGVuOiAoKT0+e30sXG4gICAgICAgICAgICB0b2dnbGU6IHRvZ2dsZVxuICAgICAgICB9KSwgW1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIG9wZW4sXG4gICAgICAgIGNsb3NlLFxuICAgICAgICBjbG9zZUFsbCxcbiAgICAgICAgZm9jdXNTdHJhdGVneSxcbiAgICAgICAgdG9nZ2xlLFxuICAgICAgICBzdWJtZW51TGV2ZWxcbiAgICBdKTtcbn1cblxuXG5cblxuZXhwb3J0IHskYTI4YzkwM2VlOWFkOGRjNSRleHBvcnQkNzlmZWZlYjFjMjA5MWFjMyBhcyB1c2VNZW51VHJpZ2dlclN0YXRlLCAkZTU2MTQ3NjRhYTQ3ZWIzNSRleHBvcnQkZDM5ZmRiZmE0MjI0NmFjNCBhcyBVTlNUQUJMRV91c2VTdWJtZW51VHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJDlYdm9oJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCJ1c2VTdGF0ZSIsIiQ5WHZvaCR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkOVh2b2gkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDlYdm9oJHVzZUNhbGxiYWNrIiwiJGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMiLCJwcm9wcyIsIm92ZXJsYXlUcmlnZ2VyU3RhdGUiLCJmb2N1c1N0cmF0ZWd5Iiwic2V0Rm9jdXNTdHJhdGVneSIsImV4cGFuZGVkS2V5c1N0YWNrIiwic2V0RXhwYW5kZWRLZXlzU3RhY2siLCJjbG9zZUFsbCIsImNsb3NlIiwib3BlblN1Ym1lbnUiLCJ0cmlnZ2VyS2V5IiwibGV2ZWwiLCJvbGRTdGFjayIsImxlbmd0aCIsInNsaWNlIiwiY2xvc2VTdWJtZW51Iiwia2V5Iiwib3BlbiIsInRvZ2dsZSIsIlVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrIiwiVU5TVEFCTEVfb3BlblN1Ym1lbnUiLCJVTlNUQUJMRV9jbG9zZVN1Ym1lbnUiLCIkZTU2MTQ3NjRhYTQ3ZWIzNSRleHBvcnQkZDM5ZmRiZmE0MjI0NmFjNCIsInN0YXRlIiwic3VibWVudUxldmVsIiwiaXNPcGVuIiwic2V0T3BlbiIsInVzZU1lbnVUcmlnZ2VyU3RhdGUiLCJVTlNUQUJMRV91c2VTdWJtZW51VHJpZ2dlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2QjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNJLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FBRyxDQUFDLEdBQUdKLG9FQUF3QixFQUFHRSxNQUFNQyxNQUFNLEVBQUVELE1BQU1HLFdBQVcsSUFBSSxPQUFPSCxNQUFNSSxZQUFZO0lBQ25ILE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCw4Q0FBaUIsRUFBRztRQUNqQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHViw4Q0FBaUIsRUFBRztRQUNsQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1LLFNBQVMsQ0FBQyxHQUFHWCw4Q0FBaUIsRUFBRztRQUNuQ00sUUFBUSxDQUFDRDtJQUNiLEdBQUc7UUFDQ0M7UUFDQUQ7S0FDSDtJQUNELE9BQU87UUFDSEEsUUFBUUE7UUFDUkMsU0FBU0E7UUFDVEcsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsUUFBUUE7SUFDWjtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9vdmVybGF5cy9kaXN0L2ltcG9ydC5tanM/MDdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNhbGxiYWNrIGFzICQ0b0EzUCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGZjOTA5NzYyYjMzMGI3NDYkZXhwb3J0JDYxYzZhOGM4NGU2MDVmYjYocHJvcHMpIHtcbiAgICBsZXQgW2lzT3Blbiwgc2V0T3Blbl0gPSAoMCwgJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuaXNPcGVuLCBwcm9wcy5kZWZhdWx0T3BlbiB8fCBmYWxzZSwgcHJvcHMub25PcGVuQ2hhbmdlKTtcbiAgICBjb25zdCBvcGVuID0gKDAsICQ0b0EzUCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0T3Blbih0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW5cbiAgICBdKTtcbiAgICBjb25zdCBjbG9zZSA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlblxuICAgIF0pO1xuICAgIGNvbnN0IHRvZ2dsZSA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldE9wZW4oIWlzT3Blbik7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuLFxuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgc2V0T3Blbjogc2V0T3BlbixcbiAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICB0b2dnbGU6IHRvZ2dsZVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JGZjOTA5NzYyYjMzMGI3NDYkZXhwb3J0JDYxYzZhOGM4NGU2MDVmYjYgYXMgdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCIkNG9BM1AkdXNlQ2FsbGJhY2siLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkNG9BM1AkdXNlQ29udHJvbGxlZFN0YXRlIiwiJGZjOTA5NzYyYjMzMGI3NDYkZXhwb3J0JDYxYzZhOGM4NGU2MDVmYjYiLCJwcm9wcyIsImlzT3BlbiIsInNldE9wZW4iLCJkZWZhdWx0T3BlbiIsIm9uT3BlbkNoYW5nZSIsIm9wZW4iLCJjbG9zZSIsInRvZ2dsZSIsInVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    var _props_defaultValue;\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValue\n    });\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) {\n            setSelected(value);\n            validation.commitValidation();\n        }\n    };\n    let isInvalid = validation.displayValidation.isInvalid;\n    return {\n        ...validation,\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || (isInvalid ? \"invalid\" : null),\n        isInvalid: isInvalid\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEY7QUFDUDtBQUNSO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBR0QsSUFBSVEsaUNBQWlDQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztBQUNoRSxJQUFJQywwQkFBMEI7QUFDOUIsU0FBU0MsMENBQTBDQyxLQUFLO0lBQ3BELG1HQUFtRztJQUNuRyxJQUFJQyxPQUFPLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJUyxNQUFNQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUVQLCtCQUErQixDQUFDLEVBQUUsRUFBRUksd0JBQXdCLENBQUMsRUFBRTtRQUMzSEUsTUFBTUMsSUFBSTtLQUNiO0lBQ0QsSUFBSUM7SUFDSixJQUFJLENBQUNDLGVBQWVDLFlBQVksR0FBRyxDQUFDLEdBQUdmLG9FQUF3QixFQUFHVyxNQUFNSyxLQUFLLEVBQUUsQ0FBQ0gsc0JBQXNCRixNQUFNTSxZQUFZLE1BQU0sUUFBUUosd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLE1BQU1GLE1BQU1PLFFBQVE7SUFDak4sSUFBSSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR2hCLDJDQUFjLEVBQUc7SUFDbkUsSUFBSWlCLGFBQWEsQ0FBQyxHQUFHdkIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR2EsS0FBSztRQUNSSyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVEsbUJBQW1CLENBQUNOO1FBQ3BCLElBQUksQ0FBQ0wsTUFBTVksVUFBVSxJQUFJLENBQUNaLE1BQU1hLFVBQVUsRUFBRTtZQUN4Q1QsWUFBWUM7WUFDWkssV0FBV0ksZ0JBQWdCO1FBQy9CO0lBQ0o7SUFDQSxJQUFJQyxZQUFZTCxXQUFXTSxpQkFBaUIsQ0FBQ0QsU0FBUztJQUN0RCxPQUFPO1FBQ0gsR0FBR0wsVUFBVTtRQUNiVCxNQUFNQTtRQUNORSxlQUFlQTtRQUNmUSxrQkFBa0JBO1FBQ2xCSCxrQkFBa0JBO1FBQ2xCQyxxQkFBcUJBO1FBQ3JCSSxZQUFZYixNQUFNYSxVQUFVLElBQUk7UUFDaENELFlBQVlaLE1BQU1ZLFVBQVUsSUFBSTtRQUNoQ0ssWUFBWWpCLE1BQU1pQixVQUFVLElBQUk7UUFDaENDLGlCQUFpQmxCLE1BQU1rQixlQUFlLElBQUtILENBQUFBLFlBQVksWUFBWSxJQUFHO1FBQ3RFQSxXQUFXQTtJQUNmO0FBQ0o7QUFLeUUsQ0FDekUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3JhZGlvL2Rpc3QvaW1wb3J0Lm1qcz8zM2UzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlRm9ybVZhbGlkYXRpb25TdGF0ZSBhcyAkZlEyU0YkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2Zvcm1cIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICRmUTJTRiR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICRmUTJTRiR1c2VNZW1vLCB1c2VTdGF0ZSBhcyAkZlEyU0YkdXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmxldCAkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2UgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCk7XG5sZXQgJGE1NGNkYzVjMTk0MmI2MzkkdmFyJGkgPSAwO1xuZnVuY3Rpb24gJGE1NGNkYzVjMTk0MmI2MzkkZXhwb3J0JGJjYTlkMDI2ZjhlNzA0ZWIocHJvcHMpIHtcbiAgICAvLyBQcmVzZXJ2ZWQgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gUmVhY3QgQXJpYSBub3cgZ2VuZXJhdGVzIHRoZSBuYW1lIGluc3RlYWQgb2Ygc3RhdGVseS5cbiAgICBsZXQgbmFtZSA9ICgwLCAkZlEyU0YkdXNlTWVtbykoKCk9PnByb3BzLm5hbWUgfHwgYHJhZGlvLWdyb3VwLSR7JGE1NGNkYzVjMTk0MmI2MzkkdmFyJGluc3RhbmNlfS0keysrJGE1NGNkYzVjMTk0MmI2MzkkdmFyJGl9YCwgW1xuICAgICAgICBwcm9wcy5uYW1lXG4gICAgXSk7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0VmFsdWU7XG4gICAgbGV0IFtzZWxlY3RlZFZhbHVlLCBzZXRTZWxlY3RlZF0gPSAoMCwgJGZRMlNGJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMudmFsdWUsIChfcHJvcHNfZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlKSAhPT0gbnVsbCAmJiBfcHJvcHNfZGVmYXVsdFZhbHVlICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdFZhbHVlIDogbnVsbCwgcHJvcHMub25DaGFuZ2UpO1xuICAgIGxldCBbbGFzdEZvY3VzZWRWYWx1ZSwgc2V0TGFzdEZvY3VzZWRWYWx1ZV0gPSAoMCwgJGZRMlNGJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgdmFsaWRhdGlvbiA9ICgwLCAkZlEyU0YkdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVcbiAgICB9KTtcbiAgICBsZXQgc2V0U2VsZWN0ZWRWYWx1ZSA9ICh2YWx1ZSk9PntcbiAgICAgICAgaWYgKCFwcm9wcy5pc1JlYWRPbmx5ICYmICFwcm9wcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLmNvbW1pdFZhbGlkYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IGlzSW52YWxpZCA9IHZhbGlkYXRpb24uZGlzcGxheVZhbGlkYXRpb24uaXNJbnZhbGlkO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbGlkYXRpb24sXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHNldFNlbGVjdGVkVmFsdWU6IHNldFNlbGVjdGVkVmFsdWUsXG4gICAgICAgIGxhc3RGb2N1c2VkVmFsdWU6IGxhc3RGb2N1c2VkVmFsdWUsXG4gICAgICAgIHNldExhc3RGb2N1c2VkVmFsdWU6IHNldExhc3RGb2N1c2VkVmFsdWUsXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVhZE9ubHk6IHByb3BzLmlzUmVhZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgIGlzUmVxdWlyZWQ6IHByb3BzLmlzUmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZTogcHJvcHMudmFsaWRhdGlvblN0YXRlIHx8IChpc0ludmFsaWQgPyBcImludmFsaWRcIiA6IG51bGwpLFxuICAgICAgICBpc0ludmFsaWQ6IGlzSW52YWxpZFxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JGE1NGNkYzVjMTk0MmI2MzkkZXhwb3J0JGJjYTlkMDI2ZjhlNzA0ZWIgYXMgdXNlUmFkaW9Hcm91cFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGZRMlNGJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlTWVtbyIsIiRmUTJTRiR1c2VNZW1vIiwidXNlU3RhdGUiLCIkZlEyU0YkdXNlU3RhdGUiLCIkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaW5zdGFuY2UiLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCIkYTU0Y2RjNWMxOTQyYjYzOSR2YXIkaSIsIiRhNTRjZGM1YzE5NDJiNjM5JGV4cG9ydCRiY2E5ZDAyNmY4ZTcwNGViIiwicHJvcHMiLCJuYW1lIiwiX3Byb3BzX2RlZmF1bHRWYWx1ZSIsInNlbGVjdGVkVmFsdWUiLCJzZXRTZWxlY3RlZCIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwib25DaGFuZ2UiLCJsYXN0Rm9jdXNlZFZhbHVlIiwic2V0TGFzdEZvY3VzZWRWYWx1ZSIsInZhbGlkYXRpb24iLCJzZXRTZWxlY3RlZFZhbHVlIiwiaXNSZWFkT25seSIsImlzRGlzYWJsZWQiLCJjb21taXRWYWxpZGF0aW9uIiwiaXNJbnZhbGlkIiwiZGlzcGxheVZhbGlkYXRpb24iLCJpc1JlcXVpcmVkIiwidmFsaWRhdGlvblN0YXRlIiwidXNlUmFkaW9Hcm91cFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4QjtBQUVuSzs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRyxNQUFNZ0Isa0RBQWtEQztJQUN4REMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQztRQUNwQyxLQUFLLENBQUNGO1FBQ04sSUFBSUEsZ0JBQWdCSCwyQ0FBMkM7WUFDM0QsSUFBSSxDQUFDSSxTQUFTLEdBQUdBLGFBQWFELEtBQUtDLFNBQVM7WUFDNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdBLGNBQWNGLEtBQUtFLFVBQVU7UUFDbkQsT0FBTztZQUNILElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDdEI7SUFDSjtBQUNKO0FBS0EsU0FBU0MsZ0NBQWdDQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLRCxLQUFLQyxJQUFJLEVBQUUsT0FBTztJQUNwQyxLQUFLLElBQUlDLFFBQVFILEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxLQUFLRyxHQUFHLENBQUNELE9BQU8sT0FBTztJQUNoQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNFLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLGVBQWVBLGdCQUFnQixNQUFNLEVBQUVDLHdCQUF3QkEsc0JBQXNCLEVBQUVDLCtCQUErQkEsNkJBQTZCLEVBQUVDLG1CQUFtQkMsd0JBQXdCLFFBQVEsRUFBRUMsa0JBQWtCQSxtQkFBbUIsS0FBSyxFQUFFLEdBQUdOO0lBQy9QLDhGQUE4RjtJQUM5RixrR0FBa0c7SUFDbEcsSUFBSU8sZUFBZSxDQUFDLEdBQUdqQyx5Q0FBWSxFQUFHO0lBQ3RDLElBQUksR0FBR2tDLFdBQVcsR0FBRyxDQUFD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YWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvbi9kaXN0L2ltcG9ydC5tanM/YWVkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkUXN0bzIkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlUmVmIGFzICRRc3RvMiR1c2VSZWYsIHVzZVN0YXRlIGFzICRRc3RvMiR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkUXN0bzIkdXNlTWVtbywgdXNlRWZmZWN0IGFzICRRc3RvMiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtjb21wYXJlTm9kZU9yZGVyIGFzICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyLCBnZXRGaXJzdEl0ZW0gYXMgJFFzdG8yJGdldEZpcnN0SXRlbSwgZ2V0Q2hpbGROb2RlcyBhcyAkUXN0bzIkZ2V0Q2hpbGROb2Rlc30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmIGV4dGVuZHMgU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCBhbmNob3JLZXksIGN1cnJlbnRLZXkpe1xuICAgICAgICBzdXBlcihrZXlzKTtcbiAgICAgICAgaWYgKGtleXMgaW5zdGFuY2VvZiAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikge1xuICAgICAgICAgICAgdGhpcy5hbmNob3JLZXkgPSBhbmNob3JLZXkgfHwga2V5cy5hbmNob3JLZXk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRLZXkgPSBjdXJyZW50S2V5IHx8IGtleXMuY3VycmVudEtleTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yS2V5ID0gYW5jaG9yS2V5O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5ID0gY3VycmVudEtleTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cblxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyhzZXRBLCBzZXRCKSB7XG4gICAgaWYgKHNldEEuc2l6ZSAhPT0gc2V0Qi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaXRlbSBvZiBzZXRBKXtcbiAgICAgICAgaWYgKCFzZXRCLmhhcyhpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyKHByb3BzKSB7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uLCBhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50czogYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMsIHNlbGVjdGlvbkJlaGF2aW9yOiBzZWxlY3Rpb25CZWhhdmlvclByb3AgPSBcInRvZ2dsZVwiLCBkaXNhYmxlZEJlaGF2aW9yOiBkaXNhYmxlZEJlaGF2aW9yID0gXCJhbGxcIiB9ID0gcHJvcHM7XG4gICAgLy8gV2Ugd2FudCBzeW5jaHJvbm91cyB1cGRhdGVzIHRvIGBpc0ZvY3VzZWRgIGFuZCBgZm9jdXNlZEtleWAgYWZ0ZXIgdGhlaXIgc2V0dGVycyBhcmUgY2FsbGVkLlxuICAgIC8vIEJ1dCB3ZSBhbHNvIG5lZWQgdG8gdHJpZ2dlciBhIHJlYWN0IHJlLXJlbmRlci4gU28sIHdlIGhhdmUgYm90aCBhIHJlZiAoc3luYykgYW5kIHN0YXRlIChhc3luYykuXG4gICAgbGV0IGlzRm9jdXNlZFJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShmYWxzZSk7XG4gICAgbGV0IFssIHNldEZvY3VzZWRdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBmb2N1c2VkS2V5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IFssIHNldEZvY3VzZWRLZXldID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IHNlbGVjdGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT4kN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihwcm9wcy5zZWxlY3RlZEtleXMpLCBbXG4gICAgICAgIHByb3BzLnNlbGVjdGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBkZWZhdWx0U2VsZWN0ZWRLZXlzID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+JDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24ocHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5cywgbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKSksIFtcbiAgICAgICAgcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBbc2VsZWN0ZWRLZXlzLCBzZXRTZWxlY3RlZEtleXNdID0gKDAsICRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGUpKHNlbGVjdGVkS2V5c1Byb3AsIGRlZmF1bHRTZWxlY3RlZEtleXMsIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzUHJvcCA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGlvbkJlaGF2aW9yLCBzZXRTZWxlY3Rpb25CZWhhdmlvcl0gPSAoMCwgJFFzdG8yJHVzZVN0YXRlKShzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xuICAgIC8vIElmIHRoZSBzZWxlY3Rpb25CZWhhdmlvciBwcm9wIGlzIHNldCB0byByZXBsYWNlLCBidXQgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdG9nZ2xlIChlLmcuIGR1ZSB0byBsb25nIHByZXNzXG4gICAgLy8gdG8gZW50ZXIgc2VsZWN0aW9uIG1vZGUgb24gdG91Y2gpLCBhbmQgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIGVtcHR5LCByZXNldCB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yLlxuICAgIGlmIChzZWxlY3Rpb25CZWhhdmlvclByb3AgPT09IFwicmVwbGFjZVwiICYmIHNlbGVjdGlvbkJlaGF2aW9yID09PSBcInRvZ2dsZVwiICYmIHR5cGVvZiBzZWxlY3RlZEtleXMgPT09IFwib2JqZWN0XCIgJiYgc2VsZWN0ZWRLZXlzLnNpemUgPT09IDApIHNldFNlbGVjdGlvbkJlaGF2aW9yKFwicmVwbGFjZVwiKTtcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBjaGFuZ2VzLCB1cGRhdGUgdGhlIHN0YXRlIGFzIHdlbGwuXG4gICAgbGV0IGxhc3RTZWxlY3Rpb25CZWhhdmlvciA9ICgwLCAkUXN0bzIkdXNlUmVmKShzZWxlY3Rpb25CZWhhdmlvclByb3ApO1xuICAgICgwLCAkUXN0bzIkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wICE9PSBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAgICAgICAgIGxhc3RTZWxlY3Rpb25CZWhhdmlvci5jdXJyZW50ID0gc2VsZWN0aW9uQmVoYXZpb3JQcm9wO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzZWxlY3Rpb25CZWhhdmlvclByb3BcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uOiBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3IsXG4gICAgICAgIHNldFNlbGVjdGlvbkJlaGF2aW9yOiBzZXRTZWxlY3Rpb25CZWhhdmlvcixcbiAgICAgICAgZ2V0IGlzRm9jdXNlZCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGb2N1c2VkUmVmLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZvY3VzZWQgKGYpIHtcbiAgICAgICAgICAgIGlzRm9jdXNlZFJlZi5jdXJyZW50ID0gZjtcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBmb2N1c2VkS2V5ICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2VkS2V5UmVmLmN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3kgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkRm9jdXNTdHJhdGVneVJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRGb2N1c2VkS2V5IChrLCBjaGlsZEZvY3VzU3RyYXRlZ3kgPSBcImZpcnN0XCIpIHtcbiAgICAgICAgICAgIGZvY3VzZWRLZXlSZWYuY3VycmVudCA9IGs7XG4gICAgICAgICAgICBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudCA9IGNoaWxkRm9jdXNTdHJhdGVneTtcbiAgICAgICAgICAgIHNldEZvY3VzZWRLZXkoayk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzLFxuICAgICAgICBzZXRTZWxlY3RlZEtleXMgKGtleXMpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50cyB8fCAhJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyhrZXlzLCBzZWxlY3RlZEtleXMpKSBzZXRTZWxlY3RlZEtleXMoa2V5cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzUHJvcCxcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvclxuICAgIH07XG59XG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbihzZWxlY3Rpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghc2VsZWN0aW9uKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiBzZWxlY3Rpb24gPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0aW9uKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNsYXNzICRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIHtcbiAgICAvKipcbiAgICogVGhlIHR5cGUgb2Ygc2VsZWN0aW9uIHRoYXQgaXMgYWxsb3dlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3Rpb25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBhbGxvd3MgZW1wdHkgc2VsZWN0aW9uLlxuICAgKi8gZ2V0IGRpc2FsbG93RW1wdHlTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FsbG93RW1wdHlTZWxlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIGJlaGF2aW9yIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3Rpb25CZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0aW9uQmVoYXZpb3I7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3Rpb24gYmVoYXZpb3IgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3Rpb25CZWhhdmlvcihzZWxlY3Rpb25CZWhhdmlvcik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb2xsZWN0aW9uIGlzIGN1cnJlbnRseSBmb2N1c2VkLlxuICAgKi8gZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGb2N1c2VkO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBjb2xsZWN0aW9uIGlzIGZvY3VzZWQuXG4gICAqLyBzZXRGb2N1c2VkKGlzRm9jdXNlZCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldEZvY3VzZWQoaXNGb2N1c2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZvY3VzZWQga2V5IGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IGZvY3VzZWRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmZvY3VzZWRLZXk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBmaXJzdCBvciBsYXN0IGNoaWxkIG9mIHRoZSBmb2N1c2VkIGtleSBzaG91bGQgcmVjZWl2ZSBmb2N1cy4gKi8gZ2V0IGNoaWxkRm9jdXNTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRGb2N1c1N0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXNlZCBrZXkuXG4gICAqLyBzZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpKSB0aGlzLnN0YXRlLnNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZEZvY3VzU3RyYXRlZ3kpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBrZXlzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gZ2V0IHNlbGVjdGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gbmV3IFNldCh0aGlzLmdldFNlbGVjdEFsbEtleXMoKSkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSByYXcgc2VsZWN0aW9uIHZhbHVlIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICogRWl0aGVyICdhbGwnIGZvciBzZWxlY3QgYWxsLCBvciBhIHNldCBvZiBrZXlzLlxuICAgKi8gZ2V0IHJhd1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEga2V5IGlzIHNlbGVjdGVkLlxuICAgKi8gaXNTZWxlY3RlZChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cy5oYXMoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eS5cbiAgICovIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgIT09IFwiYWxsXCIgJiYgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuc2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGFyZSBzZWxlY3RlZC5cbiAgICovIGdldCBpc1NlbGVjdEFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RBbGwgIT0gbnVsbCkgcmV0dXJuIHRoaXMuX2lzU2VsZWN0QWxsO1xuICAgICAgICBsZXQgYWxsS2V5cyA9IHRoaXMuZ2V0U2VsZWN0QWxsS2V5cygpO1xuICAgICAgICBsZXQgc2VsZWN0ZWRLZXlzID0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0QWxsID0gYWxsS2V5cy5ldmVyeSgoayk9PnNlbGVjdGVkS2V5cy5oYXMoaykpO1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RBbGw7XG4gICAgfVxuICAgIGdldCBmaXJzdFNlbGVjdGVkS2V5KCkge1xuICAgICAgICBsZXQgZmlyc3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdCB8fCBpdGVtICYmICgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBpdGVtLCBmaXJzdCkgPCAwKSBmaXJzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBudWxsIHx8IGZpcnN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdC5rZXk7XG4gICAgfVxuICAgIGdldCBsYXN0U2VsZWN0ZWRLZXkoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBpdGVtICYmICgwLCAkUXN0bzIkY29tcGFyZU5vZGVPcmRlcikodGhpcy5jb2xsZWN0aW9uLCBpdGVtLCBsYXN0KSA+IDApIGxhc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3Qua2V5O1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhYmxlZEtleXM7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhYmxlZEJlaGF2aW9yO1xuICAgIH1cbiAgICAvKipcbiAgICogRXh0ZW5kcyB0aGUgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiBrZXkuXG4gICAqLyBleHRlbmRTZWxlY3Rpb24odG9LZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKHRvS2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0b0tleSA9IHRoaXMuZ2V0S2V5KHRvS2V5KTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbjtcbiAgICAgICAgLy8gT25seSBzZWxlY3QgdGhlIG9uZSBrZXkgaWYgY29taW5nIGZyb20gYSBzZWxlY3QgYWxsLlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIpIHNlbGVjdGlvbiA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKFtcbiAgICAgICAgICAgIHRvS2V5XG4gICAgICAgIF0sIHRvS2V5LCB0b0tleSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICAgICAgbGV0IGFuY2hvcktleSA9IHNlbGVjdGVkS2V5cy5hbmNob3JLZXkgfHwgdG9LZXk7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShzZWxlY3RlZEtleXMsIGFuY2hvcktleSwgdG9LZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuZ2V0S2V5UmFuZ2UoYW5jaG9yS2V5LCBzZWxlY3RlZEtleXMuY3VycmVudEtleSB8fCB0b0tleSkpc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuZ2V0S2V5UmFuZ2UodG9LZXksIGFuY2hvcktleSkpaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSBzZWxlY3Rpb24uYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0S2V5UmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGZyb21JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oZnJvbSk7XG4gICAgICAgIGxldCB0b0l0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbSh0byk7XG4gICAgICAgIGlmIChmcm9tSXRlbSAmJiB0b0l0ZW0pIHtcbiAgICAgICAgICAgIGlmICgoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgZnJvbUl0ZW0sIHRvSXRlbSkgPD0gMCkgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbChmcm9tLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlSYW5nZUludGVybmFsKHRvLCBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldEtleVJhbmdlSW50ZXJuYWwoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IGtleSA9IGZyb207XG4gICAgICAgIHdoaWxlKGtleSl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwiaXRlbVwiIHx8IGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHRvKSByZXR1cm4ga2V5cztcbiAgICAgICAgICAgIGtleSA9IHRoaXMuY29sbGVjdGlvbi5nZXRLZXlBZnRlcihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0S2V5KGtleSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSkgLy8gwq9cXF8o44OEKV8vwq9cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgLy8gSWYgY2VsbCBzZWxlY3Rpb24gaXMgYWxsb3dlZCwganVzdCByZXR1cm4gdGhlIGtleS5cbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uKSByZXR1cm4ga2V5O1xuICAgICAgICAvLyBGaW5kIGEgcGFyZW50IGl0ZW0gdG8gc2VsZWN0XG4gICAgICAgIHdoaWxlKGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIgJiYgaXRlbS5wYXJlbnRLZXkgIT0gbnVsbClpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oaXRlbS5wYXJlbnRLZXkpO1xuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBpdGVtLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRvZ2dsZXMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIHNlbGVjdGVkLlxuICAgKi8gdG9nZ2xlU2VsZWN0aW9uKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiICYmICF0aGlzLmlzU2VsZWN0ZWQoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBrZXlzID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyB0aGlzLmdldFNlbGVjdEFsbEtleXMoKSA6IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAga2V5cy5hbmNob3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBrZXlzLmN1cnJlbnRLZXkgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiAmJiBrZXlzLnNpemUgPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoa2V5cyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gcmVwbGFjZVNlbGVjdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSA/IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKFtcbiAgICAgICAgICAgIGtleVxuICAgICAgICBdLCBrZXksIGtleSkgOiBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xuICAgICAgICB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBrZXlzLlxuICAgKi8gc2V0U2VsZWN0ZWRLZXlzKGtleXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKXtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0QWxsS2V5cygpIHtcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEtleXMgPSAoa2V5KT0+e1xuICAgICAgICAgICAgd2hpbGUoa2V5KXtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5TZWxlY3RJdGVtKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIml0ZW1cIikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjaGlsZCBrZXlzLiBJZiBjZWxsIHNlbGVjdGlvbiBpcyBhbGxvd2VkLCB0aGVuIGluY2x1ZGUgaXRlbSBjaGlsZHJlbiB0b28uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmhhc0NoaWxkTm9kZXMgJiYgKHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbiB8fCBpdGVtLnR5cGUgIT09IFwiaXRlbVwiKSkgYWRkS2V5cygoMCwgJFFzdG8yJGdldEZpcnN0SXRlbSkoKDAsICRRc3RvMiRnZXRDaGlsZE5vZGVzKShpdGVtLCB0aGlzLmNvbGxlY3Rpb24pKS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkS2V5cyh0aGlzLmNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICogU2VsZWN0cyBhbGwgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBzZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdEFsbCAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibXVsdGlwbGVcIikgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoXCJhbGxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXlzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICovIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiAmJiAodGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuc2l6ZSA+IDApKSB0aGlzLnN0YXRlLnNldFNlbGVjdGVkS2V5cyhuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRvZ2dsZXMgYmV0d2VlbiBzZWxlY3QgYWxsIGFuZCBhbiBlbXB0eSBzZWxlY3Rpb24uXG4gICAqLyB0b2dnbGVTZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0QWxsKSB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIGVsc2UgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICB9XG4gICAgc2VsZWN0KGtleSwgZSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKGtleSkgJiYgIXRoaXMuZGlzYWxsb3dFbXB0eVNlbGVjdGlvbikgdGhpcy50b2dnbGVTZWxlY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiB8fCBlICYmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIpKSAvLyBpZiB0b3VjaCBvciB2aXJ0dWFsIChWTykgdGhlbiB3ZSBqdXN0IHdhbnQgdG8gdG9nZ2xlLCBvdGhlcndpc2UgaXQncyBpbXBvc3NpYmxlIHRvIG11bHRpIHNlbGVjdCBiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBtb2RpZmllciBrZXlzXG4gICAgICAgIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgIGVsc2UgdGhpcy5yZXBsYWNlU2VsZWN0aW9uKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBzZWxlY3Rpb24uXG4gICAqLyBpc1NlbGVjdGlvbkVxdWFsKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cykgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZXQgb2Yga2V5cyBtYXRjaC5cbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc2VsZWN0ZWRLZXlzO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLnNpemUgIT09IHNlbGVjdGVkS2V5cy5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzZWxlY3Rpb24pe1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEtleXMuaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhblNlbGVjdEl0ZW0oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiIHx8IHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSA9PT0gXCJjZWxsXCIgJiYgIXRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNEaXNhYmxlZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzLmhhcyhrZXkpICYmIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvciA9PT0gXCJhbGxcIjtcbiAgICB9XG4gICAgaXNMaW5rKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzLCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgIHJldHVybiAhISgoX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgPT09IG51bGwgfHwgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzID0gX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcy5ocmVmKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgc3RhdGUsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHZhciBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gPSAoX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd3NDZWxsU2VsZWN0aW9uKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uICE9PSB2b2lkIDAgPyBfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uIDogZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU2VsZWN0QWxsID0gbnVsbDtcbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCB7JDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIgYXMgdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIgYXMgU2VsZWN0aW9uTWFuYWdlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlQ29udHJvbGxlZFN0YXRlIiwiJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZVJlZiIsIiRRc3RvMiR1c2VSZWYiLCJ1c2VTdGF0ZSIsIiRRc3RvMiR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkUXN0bzIkdXNlTWVtbyIsInVzZUVmZmVjdCIsIiRRc3RvMiR1c2VFZmZlY3QiLCJjb21wYXJlTm9kZU9yZGVyIiwiJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIiLCJnZXRGaXJzdEl0ZW0iLCIkUXN0bzIkZ2V0Rmlyc3RJdGVtIiwiZ2V0Q2hpbGROb2RlcyIsIiRRc3RvMiRnZXRDaGlsZE5vZGVzIiwiJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImtleXMiLCJhbmNob3JLZXkiLCJjdXJyZW50S2V5IiwiJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGVxdWFsU2V0cyIsInNldEEiLCJzZXRCIiwic2l6ZSIsIml0ZW0iLCJoYXMiLCIkN2FmM2Y1YjUxNDg5ZTBiNSRleHBvcnQkMjUzZmU3OGQ0NjMyOTQ3MiIsInByb3BzIiwic2VsZWN0aW9uTW9kZSIsImRpc2FsbG93RW1wdHlTZWxlY3Rpb24iLCJhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50cyIsInNlbGVjdGlvbkJlaGF2aW9yIiwic2VsZWN0aW9uQmVoYXZpb3JQcm9wIiwiZGlzYWJsZWRCZWhhdmlvciIsImlzRm9jdXNlZFJlZiIsInNldEZvY3VzZWQiLCJmb2N1c2VkS2V5UmVmIiwiY2hpbGRGb2N1c1N0cmF0ZWd5UmVmIiwic2V0Rm9jdXNlZEtleSIsInNlbGVjdGVkS2V5c1Byb3AiLCIkN2FmM2Y1YjUxNDg5ZTBiNSR2YXIkY29udmVydFNlbGVjdGlvbiIsInNlbGVjdGVkS2V5cyIsImRlZmF1bHRTZWxlY3RlZEtleXMiLCJzZXRTZWxlY3RlZEtleXMiLCJvblNlbGVjdGlvbkNoYW5nZSIsImRpc2FibGVkS2V5c1Byb3AiLCJkaXNhYmxlZEtleXMiLCJzZXRTZWxlY3Rpb25CZWhhdmlvciIsImxhc3RTZWxlY3Rpb25CZWhhdmlvciIsImN1cnJlbnQiLCJpc0ZvY3VzZWQiLCJmIiwiZm9jdXNlZEtleSIsImNoaWxkRm9jdXNTdHJhdGVneSIsImsiLCJzZWxlY3Rpb24iLCJkZWZhdWx0VmFsdWUiLCIkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiIsInN0YXRlIiwia2V5IiwiY29sbGVjdGlvbiIsImdldEl0ZW0iLCJnZXRTZWxlY3RBbGxLZXlzIiwicmF3U2VsZWN0aW9uIiwiaXNTZWxlY3RlZCIsImdldEtleSIsImNhblNlbGVjdEl0ZW0iLCJpc0VtcHR5IiwiaXNTZWxlY3RBbGwiLCJfaXNTZWxlY3RBbGwiLCJhbGxLZXlzIiwiZXZlcnkiLCJmaXJzdFNlbGVjdGVkS2V5IiwiZmlyc3QiLCJsYXN0U2VsZWN0ZWRLZXkiLCJsYXN0IiwiZXh0ZW5kU2VsZWN0aW9uIiwidG9LZXkiLCJyZXBsYWNlU2VsZWN0aW9uIiwiZ2V0S2V5UmFuZ2UiLCJkZWxldGUiLCJhZGQiLCJmcm9tIiwidG8iLCJmcm9tSXRlbSIsInRvSXRlbSIsImdldEtleVJhbmdlSW50ZXJuYWwiLCJ0eXBlIiwiYWxsb3dzQ2VsbFNlbGVjdGlvbiIsInB1c2giLCJnZXRLZXlBZnRlciIsInBhcmVudEtleSIsInRvZ2dsZVNlbGVjdGlvbiIsImFkZEtleXMiLCJoYXNDaGlsZE5vZGVzIiwiZ2V0Rmlyc3RLZXkiLCJzZWxlY3RBbGwiLCJjbGVhclNlbGVjdGlvbiIsInRvZ2dsZVNlbGVjdEFsbCIsInNlbGVjdCIsImUiLCJwb2ludGVyVHlwZSIsImlzU2VsZWN0aW9uRXF1YWwiLCJpc0Rpc2FibGVkIiwiaXNMaW5rIiwiX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzIiwiX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtIiwiaHJlZiIsIm9wdGlvbnMiLCJfb3B0aW9uc19hbGxvd3NDZWxsU2VsZWN0aW9uIiwidXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/slider/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/slider/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSliderState: () => (/* binding */ $28f99e3e86e6ec45$export$e5fda3247f5d67f9)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n    const { isDisabled: isDisabled = false, minValue: minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE, maxValue: maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE, numberFormatter: formatter, step: step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE, orientation: orientation = \"horizontal\" } = props;\n    // Page step should be at least equal to step and always a multiple of the step.\n    let pageSize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let calcPageSize = (maxValue - minValue) / 10;\n        calcPageSize = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n        return Math.max(calcPageSize, step);\n    }, [\n        step,\n        maxValue,\n        minValue\n    ]);\n    let restrictValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((values)=>values === null || values === void 0 ? void 0 : values.map((val, idx)=>{\n            let min = idx === 0 ? minValue : val[idx - 1];\n            let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(val, min, max, step);\n        }), [\n        minValue,\n        maxValue,\n        step\n    ]);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [\n        props.value\n    ]);\n    let defaultValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _convertValue;\n        return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [\n            minValue\n        ]);\n    }, [\n        props.defaultValue,\n        minValue\n    ]);\n    let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n    let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n    const [values, setValuesState] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(value, defaultValue, onChange);\n    const [isDraggings, setDraggingsState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Array(values.length).fill(false));\n    const isEditablesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(values.length).fill(true));\n    const [focusedIndex, setFocusedIndex] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const valuesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(values);\n    const isDraggingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isDraggings);\n    let setValues = (values)=>{\n        valuesRef.current = values;\n        setValuesState(values);\n    };\n    let setDraggings = (draggings)=>{\n        isDraggingsRef.current = draggings;\n        setDraggingsState(draggings);\n    };\n    function getValuePercent(value) {\n        return (value - minValue) / (maxValue - minValue);\n    }\n    function getThumbMinValue(index) {\n        return index === 0 ? minValue : values[index - 1];\n    }\n    function getThumbMaxValue(index) {\n        return index === values.length - 1 ? maxValue : values[index + 1];\n    }\n    function isThumbEditable(index) {\n        return isEditablesRef.current[index];\n    }\n    function setThumbEditable(index, editable) {\n        isEditablesRef.current[index] = editable;\n    }\n    function updateValue(index, value) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const thisMin = getThumbMinValue(index);\n        const thisMax = getThumbMaxValue(index);\n        // Round value to multiple of step, clamp value between min and max\n        value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, thisMin, thisMax, step);\n        let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n        setValues(newValues);\n    }\n    function updateDragging(index, dragging) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const wasDragging = isDraggingsRef.current[index];\n        isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n        setDraggings(isDraggingsRef.current);\n        // Call onChangeEnd if no handles are dragging.\n        if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n    }\n    function getFormattedValue(value) {\n        return formatter.format(value);\n    }\n    function setThumbPercent(index, percent) {\n        updateValue(index, getPercentValue(percent));\n    }\n    function getRoundedValue(value) {\n        return Math.round((value - minValue) / step) * step + minValue;\n    }\n    function getPercentValue(percent) {\n        const val = percent * (maxValue - minValue) + minValue;\n        return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(getRoundedValue(val), minValue, maxValue);\n    }\n    function incrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] + s, minValue, maxValue, step));\n    }\n    function decrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] - s, minValue, maxValue, step));\n    }\n    return {\n        values: values,\n        getThumbValue: (index)=>values[index],\n        setThumbValue: updateValue,\n        setThumbPercent: setThumbPercent,\n        isThumbDragging: (index)=>isDraggings[index],\n        setThumbDragging: updateDragging,\n        focusedThumb: focusedIndex,\n        setFocusedThumb: setFocusedIndex,\n        getThumbPercent: (index)=>getValuePercent(values[index]),\n        getValuePercent: getValuePercent,\n        getThumbValueLabel: (index)=>getFormattedValue(values[index]),\n        getFormattedValue: getFormattedValue,\n        getThumbMinValue: getThumbMinValue,\n        getThumbMaxValue: getThumbMaxValue,\n        getPercentValue: getPercentValue,\n        isThumbEditable: isThumbEditable,\n        setThumbEditable: setThumbEditable,\n        incrementThumb: incrementThumb,\n        decrementThumb: decrementThumb,\n        step: step,\n        pageSize: pageSize,\n        orientation: orientation,\n        isDisabled: isDisabled\n    };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n    if (array[index] === value) return array;\n    return [\n        ...array.slice(0, index),\n        value,\n        ...array.slice(index + 1)\n    ];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n    if (value == null) return undefined;\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n    return (newValue)=>{\n        if (typeof value === \"number\" || typeof defaultValue === \"number\") onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);\n        else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUo7QUFDZDtBQUV6STs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELE1BQU1jLDBDQUEwQztBQUNoRCxNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsMkNBQTJDO0FBQ2pELFNBQVNDLDBDQUEwQ0MsS0FBSztJQUNwRCxNQUFNLEVBQUVDLFlBQVlBLGFBQWEsS0FBSyxFQUFFQyxVQUFVQSxXQUFXTix1Q0FBdUMsRUFBRU8sVUFBVUEsV0FBV04sdUNBQXVDLEVBQUVPLGlCQUFpQkMsU0FBUyxFQUFFQyxNQUFNQSxPQUFPUix3Q0FBd0MsRUFBRVMsYUFBYUEsY0FBYyxZQUFZLEVBQUUsR0FBR1A7SUFDblMsZ0ZBQWdGO0lBQ2hGLElBQUlRLFdBQVcsQ0FBQyxHQUFHbkIsMENBQWEsRUFBRztRQUMvQixJQUFJb0IsZUFBZSxDQUFDTixXQUFXRCxRQUFPLElBQUs7UUFDM0NPLGVBQWUsQ0FBQyxHQUFHMUIsaUVBQXFCLEVBQUcwQixjQUFjLEdBQUdBLGVBQWVILE1BQU1BO1FBQ2pGLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0YsY0FBY0g7SUFDbEMsR0FBRztRQUNDQTtRQUNBSDtRQUNBRDtLQUNIO0lBQ0QsSUFBSVUsaUJBQWlCLENBQUMsR0FBR3JCLDhDQUFpQixFQUFHLENBQUNzQixTQUFTQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsR0FBRyxDQUFDLENBQUNDLEtBQUtDO1lBQ2hILElBQUlDLE1BQU1ELFFBQVEsSUFBSWQsV0FBV2EsR0FBRyxDQUFDQyxNQUFNLEVBQUU7WUFDN0MsSUFBSUwsTUFBTUssUUFBUUgsT0FBT0ssTUFBTSxHQUFHLElBQUlmLFdBQVdZLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFO1lBQzdELE9BQU8sQ0FBQyxHQUFHakMsaUVBQXFCLEVBQUdnQyxL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LE9BQU83RCxVQUFVLFlBQVksT0FBT0UsaUJBQWlCLFVBQVVFLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTeUQsUUFBUSxDQUFDLEVBQUU7YUFDdEl6RCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3lEO0lBQ3RFO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3NsaWRlci9kaXN0L2ltcG9ydC5tanM/ODE4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3NuYXBWYWx1ZVRvU3RlcCBhcyAkYVR3dXgkc25hcFZhbHVlVG9TdGVwLCB1c2VDb250cm9sbGVkU3RhdGUgYXMgJGFUd3V4JHVzZUNvbnRyb2xsZWRTdGF0ZSwgY2xhbXAgYXMgJGFUd3V4JGNsYW1wfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkYVR3dXgkdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJGFUd3V4JHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSBhcyAkYVR3dXgkdXNlU3RhdGUsIHVzZVJlZiBhcyAkYVR3dXgkdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUlOX1ZBTFVFID0gMDtcbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01BWF9WQUxVRSA9IDEwMDtcbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUgPSAxO1xuZnVuY3Rpb24gJDI4Zjk5ZTNlODZlNmVjNDUkZXhwb3J0JGU1ZmRhMzI0N2Y1ZDY3ZjkocHJvcHMpIHtcbiAgICBjb25zdCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQgPSBmYWxzZSwgbWluVmFsdWU6IG1pblZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUlOX1ZBTFVFLCBtYXhWYWx1ZTogbWF4VmFsdWUgPSAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9NQVhfVkFMVUUsIG51bWJlckZvcm1hdHRlcjogZm9ybWF0dGVyLCBzdGVwOiBzdGVwID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfU1RFUF9WQUxVRSwgb3JpZW50YXRpb246IG9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfSA9IHByb3BzO1xuICAgIC8vIFBhZ2Ugc3RlcCBzaG91bGQgYmUgYXQgbGVhc3QgZXF1YWwgdG8gc3RlcCBhbmQgYWx3YXlzIGEgbXVsdGlwbGUgb2YgdGhlIHN0ZXAuXG4gICAgbGV0IHBhZ2VTaXplID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgY2FsY1BhZ2VTaXplID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMTA7XG4gICAgICAgIGNhbGNQYWdlU2l6ZSA9ICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKShjYWxjUGFnZVNpemUsIDAsIGNhbGNQYWdlU2l6ZSArIHN0ZXAsIHN0ZXApO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY2FsY1BhZ2VTaXplLCBzdGVwKTtcbiAgICB9LCBbXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZVxuICAgIF0pO1xuICAgIGxldCByZXN0cmljdFZhbHVlcyA9ICgwLCAkYVR3dXgkdXNlQ2FsbGJhY2spKCh2YWx1ZXMpPT52YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZXMubWFwKCh2YWwsIGlkeCk9PntcbiAgICAgICAgICAgIGxldCBtaW4gPSBpZHggPT09IDAgPyBtaW5WYWx1ZSA6IHZhbFtpZHggLSAxXTtcbiAgICAgICAgICAgIGxldCBtYXggPSBpZHggPT09IHZhbHVlcy5sZW5ndGggLSAxID8gbWF4VmFsdWUgOiB2YWxbaWR4ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbCwgbWluLCBtYXgsIHN0ZXApO1xuICAgICAgICB9KSwgW1xuICAgICAgICBtaW5WYWx1ZSxcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIHN0ZXBcbiAgICBdKTtcbiAgICBsZXQgdmFsdWUgPSAoMCwgJGFUd3V4JHVzZU1lbW8pKCgpPT5yZXN0cmljdFZhbHVlcygkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlKHByb3BzLnZhbHVlKSksIFtcbiAgICAgICAgcHJvcHMudmFsdWVcbiAgICBdKTtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICB2YXIgX2NvbnZlcnRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3RyaWN0VmFsdWVzKChfY29udmVydFZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKSAhPT0gbnVsbCAmJiBfY29udmVydFZhbHVlICE9PSB2b2lkIDAgPyBfY29udmVydFZhbHVlIDogW1xuICAgICAgICAgICAgbWluVmFsdWVcbiAgICAgICAgXSk7XG4gICAgfSwgW1xuICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIG1pblZhbHVlXG4gICAgXSk7XG4gICAgbGV0IG9uQ2hhbmdlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgb25DaGFuZ2VFbmQgPSAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY3JlYXRlT25DaGFuZ2UocHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgcHJvcHMub25DaGFuZ2VFbmQpO1xuICAgIGNvbnN0IFt2YWx1ZXMsIHNldFZhbHVlc1N0YXRlXSA9ICgwLCAkYVR3dXgkdXNlQ29udHJvbGxlZFN0YXRlKSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSk7XG4gICAgY29uc3QgW2lzRHJhZ2dpbmdzLCBzZXREcmFnZ2luZ3NTdGF0ZV0gPSAoMCwgJGFUd3V4JHVzZVN0YXRlKShuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCkuZmlsbChmYWxzZSkpO1xuICAgIGNvbnN0IGlzRWRpdGFibGVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKS5maWxsKHRydWUpKTtcbiAgICBjb25zdCBbZm9jdXNlZEluZGV4LCBzZXRGb2N1c2VkSW5kZXhdID0gKDAsICRhVHd1eCR1c2VTdGF0ZSkodW5kZWZpbmVkKTtcbiAgICBjb25zdCB2YWx1ZXNSZWYgPSAoMCwgJGFUd3V4JHVzZVJlZikodmFsdWVzKTtcbiAgICBjb25zdCBpc0RyYWdnaW5nc1JlZiA9ICgwLCAkYVR3dXgkdXNlUmVmKShpc0RyYWdnaW5ncyk7XG4gICAgbGV0IHNldFZhbHVlcyA9ICh2YWx1ZXMpPT57XG4gICAgICAgIHZhbHVlc1JlZi5jdXJyZW50ID0gdmFsdWVzO1xuICAgICAgICBzZXRWYWx1ZXNTdGF0ZSh2YWx1ZXMpO1xuICAgIH07XG4gICAgbGV0IHNldERyYWdnaW5ncyA9IChkcmFnZ2luZ3MpPT57XG4gICAgICAgIGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQgPSBkcmFnZ2luZ3M7XG4gICAgICAgIHNldERyYWdnaW5nc1N0YXRlKGRyYWdnaW5ncyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRWYWx1ZVBlcmNlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIG1pblZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGh1bWJNaW5WYWx1ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IDAgPyBtaW5WYWx1ZSA6IHZhbHVlc1tpbmRleCAtIDFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUaHVtYk1heFZhbHVlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCAtIDEgPyBtYXhWYWx1ZSA6IHZhbHVlc1tpbmRleCArIDFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RodW1iRWRpdGFibGUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzRWRpdGFibGVzUmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUaHVtYkVkaXRhYmxlKGluZGV4LCBlZGl0YWJsZSkge1xuICAgICAgICBpc0VkaXRhYmxlc1JlZi5jdXJyZW50W2luZGV4XSA9IGVkaXRhYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgIWlzVGh1bWJFZGl0YWJsZShpbmRleCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGhpc01pbiA9IGdldFRodW1iTWluVmFsdWUoaW5kZXgpO1xuICAgICAgICBjb25zdCB0aGlzTWF4ID0gZ2V0VGh1bWJNYXhWYWx1ZShpbmRleCk7XG4gICAgICAgIC8vIFJvdW5kIHZhbHVlIHRvIG11bHRpcGxlIG9mIHN0ZXAsIGNsYW1wIHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICAgICAgdmFsdWUgPSAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkodmFsdWUsIHRoaXNNaW4sIHRoaXNNYXgsIHN0ZXApO1xuICAgICAgICBsZXQgbmV3VmFsdWVzID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleCh2YWx1ZXNSZWYuY3VycmVudCwgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgc2V0VmFsdWVzKG5ld1ZhbHVlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURyYWdnaW5nKGluZGV4LCBkcmFnZ2luZykge1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCAhaXNUaHVtYkVkaXRhYmxlKGluZGV4KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB3YXNEcmFnZ2luZyA9IGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgICAgICBpc0RyYWdnaW5nc1JlZi5jdXJyZW50ID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleChpc0RyYWdnaW5nc1JlZi5jdXJyZW50LCBpbmRleCwgZHJhZ2dpbmcpO1xuICAgICAgICBzZXREcmFnZ2luZ3MoaXNEcmFnZ2luZ3NSZWYuY3VycmVudCk7XG4gICAgICAgIC8vIENhbGwgb25DaGFuZ2VFbmQgaWYgbm8gaGFuZGxlcyBhcmUgZHJhZ2dpbmcuXG4gICAgICAgIGlmIChvbkNoYW5nZUVuZCAmJiB3YXNEcmFnZ2luZyAmJiAhaXNEcmFnZ2luZ3NSZWYuY3VycmVudC5zb21lKEJvb2xlYW4pKSBvbkNoYW5nZUVuZCh2YWx1ZXNSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGh1bWJQZXJjZW50KGluZGV4LCBwZXJjZW50KSB7XG4gICAgICAgIHVwZGF0ZVZhbHVlKGluZGV4LCBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb3VuZGVkVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbHVlIC0gbWluVmFsdWUpIC8gc3RlcCkgKiBzdGVwICsgbWluVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBlcmNlbnRWYWx1ZShwZXJjZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBlcmNlbnQgKiAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgKyBtaW5WYWx1ZTtcbiAgICAgICAgcmV0dXJuICgwLCAkYVR3dXgkY2xhbXApKGdldFJvdW5kZWRWYWx1ZSh2YWwpLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmNyZW1lbnRUaHVtYihpbmRleCwgc3RlcFNpemUgPSAxKSB7XG4gICAgICAgIGxldCBzID0gTWF0aC5tYXgoc3RlcFNpemUsIHN0ZXApO1xuICAgICAgICB1cGRhdGVWYWx1ZShpbmRleCwgKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbHVlc1tpbmRleF0gKyBzLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIHN0ZXApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjcmVtZW50VGh1bWIoaW5kZXgsIHN0ZXBTaXplID0gMSkge1xuICAgICAgICBsZXQgcyA9IE1hdGgubWF4KHN0ZXBTaXplLCBzdGVwKTtcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdIC0gcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICBnZXRUaHVtYlZhbHVlOiAoaW5kZXgpPT52YWx1ZXNbaW5kZXhdLFxuICAgICAgICBzZXRUaHVtYlZhbHVlOiB1cGRhdGVWYWx1ZSxcbiAgICAgICAgc2V0VGh1bWJQZXJjZW50OiBzZXRUaHVtYlBlcmNlbnQsXG4gICAgICAgIGlzVGh1bWJEcmFnZ2luZzogKGluZGV4KT0+aXNEcmFnZ2luZ3NbaW5kZXhdLFxuICAgICAgICBzZXRUaHVtYkRyYWdnaW5nOiB1cGRhdGVEcmFnZ2luZyxcbiAgICAgICAgZm9jdXNlZFRodW1iOiBmb2N1c2VkSW5kZXgsXG4gICAgICAgIHNldEZvY3VzZWRUaHVtYjogc2V0Rm9jdXNlZEluZGV4LFxuICAgICAgICBnZXRUaHVtYlBlcmNlbnQ6IChpbmRleCk9PmdldFZhbHVlUGVyY2VudCh2YWx1ZXNbaW5kZXhdKSxcbiAgICAgICAgZ2V0VmFsdWVQZXJjZW50OiBnZXRWYWx1ZVBlcmNlbnQsXG4gICAgICAgIGdldFRodW1iVmFsdWVMYWJlbDogKGluZGV4KT0+Z2V0Rm9ybWF0dGVkVmFsdWUodmFsdWVzW2luZGV4XSksXG4gICAgICAgIGdldEZvcm1hdHRlZFZhbHVlOiBnZXRGb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgZ2V0VGh1bWJNaW5WYWx1ZTogZ2V0VGh1bWJNaW5WYWx1ZSxcbiAgICAgICAgZ2V0VGh1bWJNYXhWYWx1ZTogZ2V0VGh1bWJNYXhWYWx1ZSxcbiAgICAgICAgZ2V0UGVyY2VudFZhbHVlOiBnZXRQZXJjZW50VmFsdWUsXG4gICAgICAgIGlzVGh1bWJFZGl0YWJsZTogaXNUaHVtYkVkaXRhYmxlLFxuICAgICAgICBzZXRUaHVtYkVkaXRhYmxlOiBzZXRUaHVtYkVkaXRhYmxlLFxuICAgICAgICBpbmNyZW1lbnRUaHVtYjogaW5jcmVtZW50VGh1bWIsXG4gICAgICAgIGRlY3JlbWVudFRodW1iOiBkZWNyZW1lbnRUaHVtYixcbiAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgcGFnZVNpemU6IHBhZ2VTaXplLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHJldHVybiBhcnJheTtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5hcnJheS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAuLi5hcnJheS5zbGljZShpbmRleCArIDEpXG4gICAgXTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtcbiAgICAgICAgdmFsdWVcbiAgICBdO1xufVxuZnVuY3Rpb24gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKSB7XG4gICAgcmV0dXJuIChuZXdWYWx1ZSk9PntcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcIm51bWJlclwiKSBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UobmV3VmFsdWVbMF0pO1xuICAgICAgICBlbHNlIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShuZXdWYWx1ZSk7XG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMjhmOTllM2U4NmU2ZWM0NSRleHBvcnQkZTVmZGEzMjQ3ZjVkNjdmOSBhcyB1c2VTbGlkZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsic25hcFZhbHVlVG9TdGVwIiwiJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUiLCJjbGFtcCIsIiRhVHd1eCRjbGFtcCIsInVzZU1lbW8iLCIkYVR3dXgkdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJGFUd3V4JHVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCIkYVR3dXgkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkYVR3dXgkdXNlUmVmIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUlOX1ZBTFVFIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUFYX1ZBTFVFIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfU1RFUF9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5IiwicHJvcHMiLCJpc0Rpc2FibGVkIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIm51bWJlckZvcm1hdHRlciIsImZvcm1hdHRlciIsInN0ZXAiLCJvcmllbnRhdGlvbiIsInBhZ2VTaXplIiwiY2FsY1BhZ2VTaXplIiwiTWF0aCIsIm1heCIsInJlc3RyaWN0VmFsdWVzIiwidmFsdWVzIiwibWFwIiwidmFsIiwiaWR4IiwibWluIiwibGVuZ3RoIiwidmFsdWUiLCIkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiX2NvbnZlcnRWYWx1ZSIsIm9uQ2hhbmdlIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlIiwib25DaGFuZ2VFbmQiLCJzZXRWYWx1ZXNTdGF0ZSIsImlzRHJhZ2dpbmdzIiwic2V0RHJhZ2dpbmdzU3RhdGUiLCJBcnJheSIsImZpbGwiLCJpc0VkaXRhYmxlc1JlZiIsImZvY3VzZWRJbmRleCIsInNldEZvY3VzZWRJbmRleCIsInVuZGVmaW5lZCIsInZhbHVlc1JlZiIsImlzRHJhZ2dpbmdzUmVmIiwic2V0VmFsdWVzIiwiY3VycmVudCIsInNldERyYWdnaW5ncyIsImRyYWdnaW5ncyIsImdldFZhbHVlUGVyY2VudCIsImdldFRodW1iTWluVmFsdWUiLCJpbmRleCIsImdldFRodW1iTWF4VmFsdWUiLCJpc1RodW1iRWRpdGFibGUiLCJzZXRUaHVtYkVkaXRhYmxlIiwiZWRpdGFibGUiLCJ1cGRhdGVWYWx1ZSIsInRoaXNNaW4iLCJ0aGlzTWF4IiwibmV3VmFsdWVzIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJHJlcGxhY2VJbmRleCIsInVwZGF0ZURyYWdnaW5nIiwiZHJhZ2dpbmciLCJ3YXNEcmFnZ2luZyIsInNvbWUiLCJCb29sZWFuIiwiZ2V0Rm9ybWF0dGVkVmFsdWUiLCJmb3JtYXQiLCJzZXRUaHVtYlBlcmNlbnQiLCJwZXJjZW50IiwiZ2V0UGVyY2VudFZhbHVlIiwiZ2V0Um91bmRlZFZhbHVlIiwicm91bmQiLCJpbmNyZW1lbnRUaHVtYiIsInN0ZXBTaXplIiwicyIsImRlY3JlbWVudFRodW1iIiwiZ2V0VGh1bWJWYWx1ZSIsInNldFRodW1iVmFsdWUiLCJpc1RodW1iRHJhZ2dpbmciLCJzZXRUaHVtYkRyYWdnaW5nIiwiZm9jdXNlZFRodW1iIiwic2V0Rm9jdXNlZFRodW1iIiwiZ2V0VGh1bWJQZXJjZW50IiwiZ2V0VGh1bWJWYWx1ZUxhYmVsIiwiYXJyYXkiLCJzbGljZSIsImlzQXJyYXkiLCJuZXdWYWx1ZSIsInVzZVNsaWRlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/slider/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the itemâ€™s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the itemâ€™s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the itemâ€™s\n     * target main size was made smaller by this, itâ€™s a max\n     * violation. If the itemâ€™s target main size was made\n     * larger by this, itâ€™s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) {\n            if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n                if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);\n                else this.rowHeaderColumnKeys.add(this.columns[1].key);\n            } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n        }\n    }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsU0FBU3lCLDBDQUEwQ0MsS0FBSztJQUN4RCxPQUFPQSxTQUFTLFFBQVMsRUFBQ0MsTUFBTUQsVUFBVUUsT0FBT0YsT0FBT0csS0FBSyxDQUFDLG9CQUFvQixJQUFHO0FBQ3pGO0FBQ0EsU0FBU0MsMENBQTBDSixLQUFLO0lBQ3BELElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLElBQUlHLFFBQVFILE1BQU1HLEtBQUssQ0FBQztJQUN4Qiw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDQSxPQUFPO1FBQ1JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRU4sTUFBTSw2R0FBNkcsQ0FBQyxFQUFFO1FBQzdJLE9BQU87SUFDWDtJQUNBLE9BQU9PLFdBQVdKLEtBQUssQ0FBQyxFQUFFO0FBQzlCO0FBQ0EsU0FBU0ssMENBQTBDUixLQUFLLEVBQUVTLFVBQVU7SUFDaEUsSUFBSSxPQUFPVCxVQUFVLFVBQVU7UUFDM0IsSUFBSUcsUUFBUUgsTUFBTUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlPLE1BQU07UUFDNUIsT0FBT0QsYUFBY0YsQ0FBQUEsV0FBV0osS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xEO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNXLDBDQUEwQ0MsUUFBUSxFQUFFSCxVQUFVO0lBQ25FLE9BQU9HLFlBQVksT0FBT0osMENBQTBDSSxVQUFVSCxjQUFjSSxPQUFPQyxnQkFBZ0I7QUFDdkg7QUFDQSxTQUFTQywwQ0FBMENDLFFBQVEsRUFBRVAsVUFBVTtJ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TUFBTUEsS0FBS3pILE9BQU8sR0FBRztJQUN6QixPQUFPO1FBQ0h0QixRQUFRQTtRQUNSNkgsaUJBQWlCQTtRQUNqQkksZUFBZUE7UUFDZkwsWUFBWTtlQUNMUztZQUNIO2dCQUNJLEdBQUcxRyxJQUFJO2dCQUNQUCxZQUFZNkc7WUFDaEI7U0FDSDtJQUNMO0FBQ0o7QUFLNHNCLENBQzVzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNpZ24tZW5naW5lZXIvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzPzZjZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTZWN0aW9uIGFzICQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uLCB1c2VDb2xsZWN0aW9uIGFzICQxQmZqVyR1c2VDb2xsZWN0aW9uLCBnZXRGaXJzdEl0ZW0gYXMgJDFCZmpXJGdldEZpcnN0SXRlbSwgZ2V0TGFzdEl0ZW0gYXMgJDFCZmpXJGdldExhc3RJdGVtLCBDb2xsZWN0aW9uQnVpbGRlciBhcyAkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0ICQxQmZqVyRyZWFjdCwge3VzZVN0YXRlIGFzICQxQmZqVyR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkMUJmalckdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDFCZmpXJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlR3JpZFN0YXRlIGFzICQxQmZqVyR1c2VHcmlkU3RhdGUsIEdyaWRDb2xsZWN0aW9uIGFzICQxQmZqVyRHcmlkQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2dyaWRcIjtcbmltcG9ydCB7dGFibGVOZXN0ZWRSb3dzIGFzICQxQmZqVyR0YWJsZU5lc3RlZFJvd3N9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9mbGFnc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDFCZmpXJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSh3aWR0aCkge1xuICAgIHJldHVybiB3aWR0aCAhPSBudWxsICYmICghaXNOYU4od2lkdGgpIHx8IFN0cmluZyh3aWR0aCkubWF0Y2goL14oXFxkKykoPz0lJCkvKSAhPT0gbnVsbCk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCh3aWR0aCkge1xuICAgIGlmICghd2lkdGgpIHJldHVybiAxO1xuICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKC4rKSg/PWZyJCkvKTtcbiAgICAvLyBpZiB3aWR0aCBpcyB0aGUgaW5jb3JyZWN0IGZvcm1hdCwganVzdCBkZWZhdWx0IGl0IHRvIGEgMWZyXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHdpZHRoOiAke3dpZHRofSBpcyBub3QgYSBzdXBwb3J0ZWQgZm9ybWF0LCB3aWR0aCBzaG91bGQgYmUgYSBudW1iZXIgKGV4LiAxNTApLCBwZXJjZW50YWdlIChleC4gJzUwJScpIG9yIGZyIHVuaXQgKGV4LiAnMmZyJylgLCBcImRlZmF1bHRpbmcgdG8gJzFmcidcIik7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFswXSk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5Zih3aWR0aCwgdGFibGVXaWR0aCkge1xuICAgIGlmICh0eXBlb2Ygd2lkdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gd2lkdGgubWF0Y2goL14oXFxkKykoPz0lJCkvKTtcbiAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiT25seSBwZXJjZW50YWdlcyBvciBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgZm9yIHN0YXRpYyBjb2x1bW4gd2lkdGhzXCIpO1xuICAgICAgICByZXR1cm4gdGFibGVXaWR0aCAqIChwYXJzZUZsb2F0KG1hdGNoWzBdKSAvIDEwMCk7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwKG1heFdpZHRoLCB0YWJsZVdpZHRoKSB7XG4gICAgcmV0dXJuIG1heFdpZHRoICE9IG51bGwgPyAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5ZihtYXhXaWR0aCwgdGFibGVXaWR0aCkgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKG1pbldpZHRoLCB0YWJsZVdpZHRoKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoICE9IG51bGwgPyAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5ZihtaW5XaWR0aCwgdGFibGVXaWR0aCkgOiAwO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU1ZDUwZGM2ODczODU0OTEoYXZhaWxhYmxlV2lkdGgsIGNvbHVtbnMsIGNoYW5nZWRDb2x1bW5zLCBnZXREZWZhdWx0V2lkdGgsIGdldERlZmF1bHRNaW5XaWR0aCkge1xuICAgIGxldCBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xuICAgIGxldCBmbGV4SXRlbXMgPSBjb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCk9PntcbiAgICAgICAgdmFyIF9jb2x1bW5fd2lkdGgsIF9yZWYsIF9yZWYxO1xuICAgICAgICBsZXQgd2lkdGggPSBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgIT0gbnVsbCA/IGNoYW5nZWRDb2x1bW5zLmdldChjb2x1bW4ua2V5KSA6IChfcmVmMSA9IChfcmVmID0gKF9jb2x1bW5fd2lkdGggPSBjb2x1bW4ud2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fd2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fd2lkdGggOiBjb2x1bW4uZGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogZ2V0RGVmYXVsdFdpZHRoID09PSBudWxsIHx8IGdldERlZmF1bHRXaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RGVmYXVsdFdpZHRoKGluZGV4KSkgIT09IG51bGwgJiYgX3JlZjEgIT09IHZvaWQgMCA/IF9yZWYxIDogXCIxZnJcIjtcbiAgICAgICAgbGV0IGZyb3plbiA9IGZhbHNlO1xuICAgICAgICBsZXQgYmFzZVNpemUgPSAwO1xuICAgICAgICBsZXQgZmxleCA9IDA7XG4gICAgICAgIGxldCB0YXJnZXRNYWluU2l6ZSA9IG51bGw7XG4gICAgICAgIGlmICgkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSh3aWR0aCkpIHtcbiAgICAgICAgICAgIGJhc2VTaXplID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgIGZyb3plbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGV4ID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpO1xuICAgICAgICAgICAgaWYgKGZsZXggPD0gMCkgZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2NvbHVtbl9taW5XaWR0aCwgX3JlZjI7XG4gICAgICAgIGxldCBtaW4gPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMSgoX3JlZjIgPSAoX2NvbHVtbl9taW5XaWR0aCA9IGNvbHVtbi5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9taW5XaWR0aCA6IGdldERlZmF1bHRNaW5XaWR0aCA9PT0gbnVsbCB8fCBnZXREZWZhdWx0TWluV2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldERlZmF1bHRNaW5XaWR0aChpbmRleCkpICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IDAsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IG1heCA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwKGNvbHVtbi5tYXhXaWR0aCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBsZXQgaHlwb3RoZXRpY2FsTWFpblNpemUgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKGJhc2VTaXplLCBtYXgpKTtcbiAgICAgICAgLy8gOS43LjFcbiAgICAgICAgLy8gV2UgZG9uJ3QgbWFrZSB1c2Ugb2YgZmxleCBiYXNpcywgaXQncyBhbHdheXMgMCwgc28gd2UgYXJlIGFsd2F5cyBpbiAnZ3JvdycgbW9kZS5cbiAgICAgICAgLy8gOS43LjJcbiAgICAgICAgaWYgKGZyb3plbikgdGFyZ2V0TWFpblNpemUgPSBoeXBvdGhldGljYWxNYWluU2l6ZTtcbiAgICAgICAgZWxzZSBpZiAoYmFzZVNpemUgPiBoeXBvdGhldGljYWxNYWluU2l6ZSkge1xuICAgICAgICAgICAgZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldE1haW5TaXplID0gaHlwb3RoZXRpY2FsTWFpblNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOS43LjNcbiAgICAgICAgaWYgKCFmcm96ZW4pIGhhc05vbkZyb3plbkl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb3plbjogZnJvemVuLFxuICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplLFxuICAgICAgICAgICAgaHlwb3RoZXRpY2FsTWFpblNpemU6IGh5cG90aGV0aWNhbE1haW5TaXplLFxuICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgIGZsZXg6IGZsZXgsXG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZTogdGFyZ2V0TWFpblNpemUsXG4gICAgICAgICAgICB2aW9sYXRpb246IDBcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyA5LjcuNFxuICAgIC8vIDkuNy40LmFcbiAgICB3aGlsZShoYXNOb25Gcm96ZW5JdGVtcyl7XG4gICAgICAgIC8vIDkuNy40LmJcbiAgICAgICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBhcyBmb3IgaW5pdGlhbCBmcmVlIHNwYWNlLFxuICAgICAqIGFib3ZlICg5LjcuMykuIElmIHRoZSBzdW0gb2YgdGhlIHVuZnJvemVuIGZsZXggaXRlbXPigJkgZmxleCBmYWN0b3JzIGlzXG4gICAgICogbGVzcyB0aGFuIG9uZSwgbXVsdGlwbHkgdGhlIGluaXRpYWwgZnJlZSBzcGFjZSBieSB0aGlzIHN1bSAob2YgZmxleCBmYWN0b3JzKS5cbiAgICAgKiBJZiB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtYWduaXR1ZGUgb2ZcbiAgICAgKiB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UsIHVzZSB0aGlzIGFzIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZS5cbiAgICAgKi8gbGV0IHVzZWRXaWR0aCA9IDA7XG4gICAgICAgIGxldCBmbGV4RmFjdG9ycyA9IDA7XG4gICAgICAgIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKGl0ZW0uZnJvemVuKSB1c2VkV2lkdGggKz0gaXRlbS50YXJnZXRNYWluU2l6ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVzZWRXaWR0aCArPSBpdGVtLmJhc2VTaXplO1xuICAgICAgICAgICAgICAgIGZsZXhGYWN0b3JzICs9IGl0ZW0uZmxleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZW1haW5pbmdGcmVlU3BhY2UgPSBhdmFpbGFibGVXaWR0aCAtIHVzZWRXaWR0aDtcbiAgICAgICAgLy8gd2Ugb25seSBzdXBwb3J0IGludGVnZXIgRlIncywgYW5kIGJlY2F1c2Ugb2YgaGFzTm9uRnJvemVuSXRlbXMsIHdlIGtub3cgdGhhdCBmbGV4RmFjdG9ycyA+IDBcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBjaGVjayBmb3IgZmxleEZhY3RvcnMgPCAxXG4gICAgICAgIC8vIDkuNy40LmNcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlIGlzIHplcm9cbiAgICAgKiAtIERvIG5vdGhpbmcuXG4gICAgICogRWxzZSAvLyByZW1lbWJlciwgd2UncmUgYWx3YXlzIGluIGdyb3cgbW9kZVxuICAgICAqIC0gRmluZCB0aGUgcmF0aW8gb2YgdGhlIGl0ZW3igJlzIGZsZXggZ3JvdyBmYWN0b3IgdG8gdGhlXG4gICAgICogc3VtIG9mIHRoZSBmbGV4IGdyb3cgZmFjdG9ycyBvZiBhbGwgdW5mcm96ZW4gaXRlbXMgb25cbiAgICAgKiB0aGUgbGluZS4gU2V0IHRoZSBpdGVt4oCZcyB0YXJnZXQgbWFpbiBzaXplIHRvIGl0cyBmbGV4XG4gICAgICogYmFzZSBzaXplIHBsdXMgYSBmcmFjdGlvbiBvZiB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2VcbiAgICAgKiBwcm9wb3J0aW9uYWwgdG8gdGhlIHJhdGlvLlxuICAgICAqLyBpZiAocmVtYWluaW5nRnJlZVNwYWNlID4gMCkgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpZiAoIWl0ZW0uZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvID0gaXRlbS5mbGV4IC8gZmxleEZhY3RvcnM7XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRNYWluU2l6ZSA9IGl0ZW0uYmFzZVNpemUgKyByYXRpbyAqIHJlbWFpbmluZ0ZyZWVTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDkuNy40LmRcbiAgICAgICAgLyoqXG4gICAgICogRml4IG1pbi9tYXggdmlvbGF0aW9ucy4gQ2xhbXAgZWFjaCBub24tZnJvemVuIGl0ZW3igJlzXG4gICAgICogdGFyZ2V0IG1haW4gc2l6ZSBieSBpdHMgdXNlZCBtaW4gYW5kIG1heCBtYWluIHNpemVzXG4gICAgICogYW5kIGZsb29yIGl0cyBjb250ZW50LWJveCBzaXplIGF0IHplcm8uIElmIHRoZSBpdGVt4oCZc1xuICAgICAqIHRhcmdldCBtYWluIHNpemUgd2FzIG1hZGUgc21hbGxlciBieSB0aGlzLCBpdOKAmXMgYSBtYXhcbiAgICAgKiB2aW9sYXRpb24uIElmIHRoZSBpdGVt4oCZcyB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlXG4gICAgICogbGFyZ2VyIGJ5IHRoaXMsIGl04oCZcyBhIG1pbiB2aW9sYXRpb24uXG4gICAgICovIGxldCB0b3RhbFZpb2xhdGlvbiA9IDA7XG4gICAgICAgIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSAwO1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZyb3plbikge1xuICAgICAgICAgICAgICAgIGxldCB7IG1pbjogbWluLCBtYXg6IG1heCwgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplIH0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0TWFpblNpemUgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKHRhcmdldE1haW5TaXplLCBtYXgpKTtcbiAgICAgICAgICAgICAgICBpdGVtLnZpb2xhdGlvbiA9IGl0ZW0udGFyZ2V0TWFpblNpemUgLSB0YXJnZXRNYWluU2l6ZTtcbiAgICAgICAgICAgICAgICB0b3RhbFZpb2xhdGlvbiArPSBpdGVtLnZpb2xhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDkuNy40LmVcbiAgICAgICAgLyoqXG4gICAgICogRnJlZXplIG92ZXItZmxleGVkIGl0ZW1zLiBUaGUgdG90YWwgdmlvbGF0aW9uIGlzIHRoZVxuICAgICAqIHN1bSBvZiB0aGUgYWRqdXN0bWVudHMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcFxuICAgICAqIOKIkShjbGFtcGVkIHNpemUgLSB1bmNsYW1wZWQgc2l6ZSkuIElmIHRoZSB0b3RhbCB2aW9sYXRpb24gaXM6XG4gICAgICogWmVyb1xuICAgICAqIC0gRnJlZXplIGFsbCBpdGVtcy5cbiAgICAgKlxuICAgICAqIFBvc2l0aXZlXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1pbiB2aW9sYXRpb25zLlxuICAgICAqXG4gICAgICogTmVnYXRpdmVcbiAgICAgKiAtIEZyZWV6ZSBhbGwgdGhlIGl0ZW1zIHdpdGggbWF4IHZpb2xhdGlvbnMuXG4gICAgICovIGhhc05vbkZyb3plbkl0ZW1zID0gZmFsc2U7XG4gICAgICAgIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKHRvdGFsVmlvbGF0aW9uID09PSAwIHx8IE1hdGguc2lnbih0b3RhbFZpb2xhdGlvbikgPT09IE1hdGguc2lnbihpdGVtLnZpb2xhdGlvbikpIGl0ZW0uZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpdGVtLmZyb3plbikgaGFzTm9uRnJvemVuSXRlbXMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmcoZmxleEl0ZW1zKTtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmcoZmxleEl0ZW1zKSB7XG4gICAgLypcbiAgR2l2ZW4gYW4gYXJyYXkgb2YgZmxvYXRzIHRoYXQgc3VtIHRvIGFuIGludGVnZXIsIHRoaXMgcm91bmRzIHRoZSBmbG9hdHNcbiAgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCB0aGUgc2FtZSBzdW0uXG4gICovIGxldCBmcFRvdGFsID0gMDtcbiAgICBsZXQgaW50VG90YWwgPSAwO1xuICAgIGxldCByb3VuZGVkQXJyYXkgPSBbXTtcbiAgICBmbGV4SXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGxldCBmbG9hdCA9IGl0ZW0udGFyZ2V0TWFpblNpemU7XG4gICAgICAgIGxldCBpbnRlZ2VyID0gTWF0aC5yb3VuZChmbG9hdCArIGZwVG90YWwpIC0gaW50VG90YWw7XG4gICAgICAgIGZwVG90YWwgKz0gZmxvYXQ7XG4gICAgICAgIGludFRvdGFsICs9IGludGVnZXI7XG4gICAgICAgIHJvdW5kZWRBcnJheS5wdXNoKGludGVnZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiByb3VuZGVkQXJyYXk7XG59XG5cblxuY2xhc3MgJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUge1xuICAgIC8qKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBzcGxpdHMgaXQgaW50byAyIG1hcHMgb2YgY29sdW1ucyB3aXRoIGNvbnRyb2xsZWQgYW5kIGNvbHVtbnMgd2l0aCB1bmNvbnRyb2xsZWQgd2lkdGhzLiAqLyBzcGxpdENvbHVtbnNJbnRvQ29udHJvbGxlZEFuZFVuY29udHJvbGxlZChjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2wpPT57XG4gICAgICAgICAgICBpZiAoY29sLnByb3BzLndpZHRoICE9IG51bGwpIGFjY1swXS5zZXQoY29sLmtleSwgY29sKTtcbiAgICAgICAgICAgIGVsc2UgYWNjWzFdLnNldChjb2wua2V5LCBjb2wpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgbmV3IE1hcCgpLFxuICAgICAgICAgICAgbmV3IE1hcCgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKiogVGFrZXMgdW5jb250cm9sbGVkIGFuZCBjb250cm9sbGVkIHdpZHRocyBhbmQgam9pbnMgdGhlbSBpbnRvIGEgc2luZ2xlIE1hcC4gKi8gcmVjb21iaW5lQ29sdW1ucyhjb2x1bW5zLCB1bmNvbnRyb2xsZWRXaWR0aHMsIHVuY29udHJvbGxlZENvbHVtbnMsIGNvbnRyb2xsZWRDb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKGNvbHVtbnMubWFwKChjb2wpPT57XG4gICAgICAgICAgICBpZiAodW5jb250cm9sbGVkQ29sdW1ucy5oYXMoY29sLmtleSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgY29sLmtleSxcbiAgICAgICAgICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbC5rZXkpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbC5rZXksXG4gICAgICAgICAgICAgICAgY29udHJvbGxlZENvbHVtbnMuZ2V0KGNvbC5rZXkpLnByb3BzLndpZHRoXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKiBVc2VkIHRvIG1ha2UgYW4gaW5pdGlhbCBNYXAgb2YgdGhlIHVuY29udHJvbGxlZCB3aWR0aHMgYmFzZWQgb24gZGVmYXVsdCB3aWR0aHMuICovIGdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKHVuY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleSwgY29sXSk9PntcbiAgICAgICAgICAgIHZhciBfdGhpc19nZXREZWZhdWx0V2lkdGgsIF90aGlzO1xuICAgICAgICAgICAgdmFyIF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoLCBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgKF9yZWYgPSAoX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggPSBjb2wucHJvcHMuZGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCAhPT0gdm9pZCAwID8gX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggOiAoX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID0gKF90aGlzID0gdGhpcykuZ2V0RGVmYXVsdFdpZHRoKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2dldERlZmF1bHRXaWR0aC5jYWxsKF90aGlzLCBjb2wpKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogXCIxZnJcIlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXRDb2x1bW5XaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbldpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uV2lkdGhzX2dldCA9IHRoaXMuY29sdW1uV2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgZ2V0Q29sdW1uTWluV2lkdGgoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbk1pbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCA6IDA7XG4gICAgfVxuICAgIGdldENvbHVtbk1heFdpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5NYXhXaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICByZXNpemVDb2x1bW5XaWR0aCh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLCBjb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRXaWR0aHMsIGNvbCA9IG51bGwsIHdpZHRoKSB7XG4gICAgICAgIGxldCBwcmV2Q29sdW1uV2lkdGhzID0gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgICAgIC8vIHJlc2l6aW5nIGEgY29sdW1uXG4gICAgICAgIGxldCByZXNpemVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgcmVzaXppbmdDaGFuZ2VkID0gbmV3IE1hcChbXG4gICAgICAgICAgICAuLi5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICAgICAgLi4udW5jb250cm9sbGVkV2lkdGhzXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcGVyY2VudEtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBmcktleXNUb1RoZVJpZ2h0ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgbWluV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBmcmVlemUgY29sdW1ucyB0byB0aGUgbGVmdCB0byB0aGVpciBwcmV2aW91cyBwaXhlbCB2YWx1ZVxuICAgICAgICBjb2xsZWN0aW9uLmNvbHVtbnMuZm9yRWFjaCgoY29sdW1uLCBpKT0+e1xuICAgICAgICAgICAgdmFyIF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGgsIF9jb2x1bW5fcHJvcHNfd2lkdGg7XG4gICAgICAgICAgICBsZXQgZnJLZXk7XG4gICAgICAgICAgICBsZXQgZnJWYWx1ZTtcbiAgICAgICAgICAgIG1pbldpZHRocy5zZXQoY29sdW1uLmtleSwgdGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgICAgICBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICFjb2x1bW4ucHJvcHMud2lkdGggJiYgISgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSkodW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSkpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmNvbnRyb2xsZWQgZG9uJ3QgaGF2ZSBwcm9wcy53aWR0aCBmb3IgdXMsIHNvIGluc3RlYWQgZ2V0IGZyb20gb3VyIHN0YXRlXG4gICAgICAgICAgICAgICAgZnJLZXkgPSBjb2x1bW4ua2V5O1xuICAgICAgICAgICAgICAgIGZyVmFsdWUgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgISgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSkoY29sdW1uLnByb3BzLndpZHRoKSAmJiAhdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xsZWRXaWR0aHMgd2lsbCBiZSB0aGUgc2FtZSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KShjb2x1bW4ucHJvcHMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgKChfY29sdW1uX3Byb3BzX3dpZHRoID0gY29sdW1uLnByb3BzLndpZHRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCA9IF9jb2x1bW5fcHJvcHNfd2lkdGguZW5kc1dpdGgpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGguY2FsbChfY29sdW1uX3Byb3BzX3dpZHRoLCBcIiVcIikpKSBwZXJjZW50S2V5cy5zZXQoY29sdW1uLmtleSwgY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIC8vIGRvbid0IGZyZWV6ZSBjb2x1bW5zIHRvIHRoZSByaWdodCBvZiB0aGUgcmVzaXppbmcgb25lXG4gICAgICAgICAgICBpZiAocmVzaXplSW5kZXggPCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyS2V5KSBmcktleXNUb1RoZVJpZ2h0LnNldChmcktleSwgZnJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IHRoZSBuZXcgc2l6ZSBvZiB0aGUgcmVzaXppbmcgY29sdW1uXG4gICAgICAgICAgICBpZiAoY29sdW1uLmtleSA9PT0gY29sKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJlc2l6aW5nQ2hhbmdlZC5zZXQoY29sdW1uLmtleSwgTWF0aC5mbG9vcih3aWR0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZyZWV6ZSBjb2x1bW4gdG8gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgIHJlc2l6aW5nQ2hhbmdlZC5zZXQoY29sdW1uLmtleSwgcHJldkNvbHVtbldpZHRocy5nZXQoY29sdW1uLmtleSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJlZGljdCBwaXhlbHMgc2l6ZXMgZm9yIGFsbCBjb2x1bW5zIGJhc2VkIG9uIHJlc2l6ZVxuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgcmVzaXppbmdDaGFuZ2VkLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIHNldCBhbGwgbmV3IGNvbHVtbiB3aWR0aHMgZm9yIG9uUmVzaXplIGV2ZW50XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGxldCBuZXdXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHNldCBhbGwgY29sdW1uIHdpZHRocyBiYXNlZCBvbiBjYWxjdWxhdGVDb2x1bW5TaXplXG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIEZSJ3MgYmFjayBhcyB0aGV5IHdlcmUgdG8gY29sdW1ucyB0byB0aGUgcmlnaHRcbiAgICAgICAgQXJyYXkuZnJvbShmcktleXNUb1RoZVJpZ2h0KS5mb3JFYWNoKChba2V5XSk9PntcbiAgICAgICAgICAgIG5ld1dpZHRocy5zZXQoa2V5LCBgJHtmcktleXNUb1RoZVJpZ2h0LmdldChrZXkpfWZyYCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwdXQgYmFjayBpbiBwZXJjZW50c1xuICAgICAgICBBcnJheS5mcm9tKHBlcmNlbnRLZXlzKS5mb3JFYWNoKChba2V5LCB3aWR0aF0pPT57XG4gICAgICAgICAgICAvLyByZXNpemluZyBsb2NrcyBhIGNvbHVtbiB0byBhIHB4IHdpZHRoXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBjb2wpIHJldHVybjtcbiAgICAgICAgICAgIG5ld1dpZHRocy5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3V2lkdGhzO1xuICAgIH1cbiAgICBidWlsZENvbHVtbldpZHRocyh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLCB3aWR0aHMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWluV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1heFdpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgb3IgdGFibGUvd2luZG93IHJlc2l6aW5nXG4gICAgICAgIGxldCBjb2x1bW5XaWR0aHMgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU1ZDUwZGM2ODczODU0OTEpKHRhYmxlV2lkdGgsIGNvbGxlY3Rpb24uY29sdW1ucy5tYXAoKGNvbCk9Pih7XG4gICAgICAgICAgICAgICAgLi4uY29sLnByb3BzLFxuICAgICAgICAgICAgICAgIGtleTogY29sLmtleVxuICAgICAgICAgICAgfSkpLCB3aWR0aHMsIChpKT0+dGhpcy5nZXREZWZhdWx0V2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSwgKGkpPT50aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pKTtcbiAgICAgICAgLy8gY29sdW1ucyBnb2luZyBpbiB3aWxsIGJlIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zIGNvbWluZyBvdXRcbiAgICAgICAgY29sdW1uV2lkdGhzLmZvckVhY2goKHdpZHRoLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCBrZXkgPSBjb2xsZWN0aW9uLmNvbHVtbnNbaW5kZXhdLmtleTtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBjb2xsZWN0aW9uLmNvbHVtbnNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICAgICAgdmFyIF9jb2x1bW5fcHJvcHNfbWluV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocy5zZXQoa2V5LCAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEpKChfY29sdW1uX3Byb3BzX21pbldpZHRoID0gY29sdW1uLnByb3BzLm1pbldpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3Byb3BzX21pbldpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3Byb3BzX21pbldpZHRoIDogdGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sdW1uKSwgdGFibGVXaWR0aCkpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwKShjb2x1bW4ucHJvcHMubWF4V2lkdGgsIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbldpZHRocztcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGg7XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdFdpZHRoID0gKF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZXREZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoIDogKCk9PlwiMWZyXCI7XG4gICAgICAgIHZhciBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGg7XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoID0gKF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZXREZWZhdWx0TWluV2lkdGgpICE9PSBudWxsICYmIF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoIDogKCk9Pjc1O1xuICAgIH1cbn1cblxuXG5cbmZ1bmN0aW9uICQyOTJiYzRlMDljZDBlYjYyJGV4cG9ydCRjYjg5NWRjZjg1ZGIxMzE5KHByb3BzLCBzdGF0ZSkge1xuICAgIGxldCB7IGdldERlZmF1bHRXaWR0aDogZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aCwgdGFibGVXaWR0aDogdGFibGVXaWR0aCA9IDAgfSA9IHByb3BzO1xuICAgIGxldCBbcmVzaXppbmdDb2x1bW4sIHNldFJlc2l6aW5nQ29sdW1uXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBjb2x1bW5MYXlvdXQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlKSh7XG4gICAgICAgICAgICBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCxcbiAgICAgICAgICAgIGdldERlZmF1bHRNaW5XaWR0aDogZ2V0RGVmYXVsdE1pbldpZHRoXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGdldERlZmF1bHRXaWR0aCxcbiAgICAgICAgZ2V0RGVmYXVsdE1pbldpZHRoXG4gICAgXSk7XG4gICAgbGV0IFtjb250cm9sbGVkQ29sdW1ucywgdW5jb250cm9sbGVkQ29sdW1uc10gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKSwgW1xuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIC8vIHVuY29udHJvbGxlZCBjb2x1bW4gd2lkdGhzXG4gICAgbGV0IFt1bmNvbnRyb2xsZWRXaWR0aHMsIHNldFVuY29udHJvbGxlZFdpZHRoc10gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKSgoKT0+Y29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucykpO1xuICAgIC8vIFVwZGF0ZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXG4gICAgbGV0IFtsYXN0Q29sdW1ucywgc2V0TGFzdENvbHVtbnNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKTtcbiAgICBpZiAoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zICE9PSBsYXN0Q29sdW1ucykge1xuICAgICAgICBpZiAoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLmxlbmd0aCAhPT0gbGFzdENvbHVtbnMubGVuZ3RoIHx8IHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGxhc3RDb2x1bW5zW2ldLmtleSkpIHtcbiAgICAgICAgICAgIGxldCBuZXdVbmNvbnRyb2xsZWRXaWR0aHMgPSBjb2x1bW5MYXlvdXQuZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyhuZXdVbmNvbnRyb2xsZWRXaWR0aHMpO1xuICAgICAgICB9XG4gICAgICAgIHNldExhc3RDb2x1bW5zKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgfVxuICAgIC8vIGNvbWJpbmUgY29sdW1ucyBiYWNrIGludG8gb25lIG1hcCB0aGF0IG1haW50YWlucyBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zXG4gICAgbGV0IGNvbFdpZHRocyA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5yZWNvbWJpbmVDb2x1bW5zKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucyksIFtcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLFxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgIHVuY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICBsZXQgc3RhcnRSZXNpemUgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoa2V5KT0+e1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtbihrZXkpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cbiAgICBdKTtcbiAgICBsZXQgdXBkYXRlUmVzaXplZENvbHVtbnMgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoa2V5LCB3aWR0aCk9PntcbiAgICAgICAgbGV0IG5ld0NvbnRyb2xsZWQgPSBuZXcgTWFwKEFycmF5LmZyb20oY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleSwgZW50cnldKT0+W1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBlbnRyeS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBsZXQgbmV3U2l6ZXMgPSBjb2x1bW5MYXlvdXQucmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgbmV3Q29udHJvbGxlZCwgdW5jb250cm9sbGVkV2lkdGhzLCBrZXksIHdpZHRoKTtcbiAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoQXJyYXkuZnJvbSh1bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXldKT0+W1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBuZXdTaXplcy5nZXQoa2V5KVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBtYXAuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobWFwKTtcbiAgICAgICAgcmV0dXJuIG5ld1NpemVzO1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIHVuY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgdGFibGVXaWR0aCxcbiAgICAgICAgY29sdW1uTGF5b3V0LFxuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLFxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHNcbiAgICBdKTtcbiAgICBsZXQgZW5kUmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4obnVsbCk7XG4gICAgfSwgW1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtblxuICAgIF0pO1xuICAgICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5idWlsZENvbHVtbldpZHRocyh0YWJsZVdpZHRoLCBzdGF0ZS5jb2xsZWN0aW9uLCBjb2xXaWR0aHMpLCBbXG4gICAgICAgIHRhYmxlV2lkdGgsXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24sXG4gICAgICAgIGNvbFdpZHRocyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICByZXNpemluZ0NvbHVtbjogcmVzaXppbmdDb2x1bW4sXG4gICAgICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1uczogdXBkYXRlUmVzaXplZENvbHVtbnMsXG4gICAgICAgICAgICBzdGFydFJlc2l6ZTogc3RhcnRSZXNpemUsXG4gICAgICAgICAgICBlbmRSZXNpemU6IGVuZFJlc2l6ZSxcbiAgICAgICAgICAgIGdldENvbHVtbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbldpZHRoKGtleSksXG4gICAgICAgICAgICBnZXRDb2x1bW5NaW5XaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5NaW5XaWR0aChrZXkpLFxuICAgICAgICAgICAgZ2V0Q29sdW1uTWF4V2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWF4V2lkdGgoa2V5KSxcbiAgICAgICAgICAgIHRhYmxlU3RhdGU6IHN0YXRlXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNvbHVtbkxheW91dCxcbiAgICAgICAgcmVzaXppbmdDb2x1bW4sXG4gICAgICAgIHVwZGF0ZVJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICBzdGFydFJlc2l6ZSxcbiAgICAgICAgZW5kUmVzaXplLFxuICAgICAgICBzdGF0ZVxuICAgIF0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jb25zdCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xubGV0ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbndoaWxlKCQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkgPT09ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRykkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5mdW5jdGlvbiAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShrZXlNYXAsIGNvbHVtbk5vZGVzKSB7XG4gICAgaWYgKGNvbHVtbk5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbk5vZGVzKXtcbiAgICAgICAgbGV0IHBhcmVudEtleSA9IGNvbHVtbi5wYXJlbnRLZXk7XG4gICAgICAgIGxldCBjb2wgPSBbXG4gICAgICAgICAgICBjb2x1bW5cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUocGFyZW50S2V5KXtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBrZXlNYXAuZ2V0KHBhcmVudEtleSk7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBwYXJlbnQsIHRoYW4gaXQgaXMgc2hhcmVkXG4gICAgICAgICAgICAvLyB3aXRoIGEgcHJldmlvdXMgY29sdW1uLiBJZiB0aGUgY3VycmVudCBjb2x1bW4gaXMgdGFsbGVyXG4gICAgICAgICAgICAvLyB0aGFuIHRoZSBwcmV2aW91cyBjb2x1bW4sIHRoYW4gd2UgbmVlZCB0byBzaGlmdCB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyBpbiB0aGUgcHJldmlvdXMgY29sdW1uIHNvIGl0J3MgbGV2ZWwgd2l0aCB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jb2xzcGFuKys7XG4gICAgICAgICAgICAgICAgbGV0IHsgY29sdW1uOiBjb2x1bW4sIGluZGV4OiBpbmRleCB9ID0gc2Vlbi5nZXQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBjb2wubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBpbmRleDsgaSA8IGNvbC5sZW5ndGg7IGkrKyljb2x1bW4uc3BsaWNlKGksIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBzaGlmdGVkIGluZGljZXNcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBjb2wubGVuZ3RoOyBpIDwgY29sdW1uLmxlbmd0aDsgaSsrKS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uW2ldICYmIHNlZW4uaGFzKGNvbHVtbltpXSkpIHNlZW4uZ2V0KGNvbHVtbltpXSkuaW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbiA9IDE7XG4gICAgICAgICAgICAgICAgY29sLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICBzZWVuLnNldChwYXJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb2wubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50S2V5ID0gcGFyZW50LnBhcmVudEtleTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgY29sdW1uLmluZGV4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgbWF4TGVuZ3RoID0gTWF0aC5tYXgoLi4uY29sdW1ucy5tYXAoKGMpPT5jLmxlbmd0aCkpO1xuICAgIGxldCBoZWFkZXJSb3dzID0gQXJyYXkobWF4TGVuZ3RoKS5maWxsKDApLm1hcCgoKT0+W10pO1xuICAgIC8vIENvbnZlcnQgY29sdW1ucyBpbnRvIHJvd3MuXG4gICAgbGV0IGNvbEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1ucyl7XG4gICAgICAgIGxldCBpID0gbWF4TGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBjb2x1bW4pe1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBzcGFjZSB1cCB1bnRpbCB0aGUgY3VycmVudCBjb2x1bW4gd2l0aCBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IGhlYWRlclJvd3NbaV07XG4gICAgICAgICAgICAgICAgbGV0IHJvd0xlbmd0aCA9IHJvdy5yZWR1Y2UoKHAsIGMpPT5wICsgYy5jb2xzcGFuLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoIDwgY29sSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgaXRlbS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2xJbmRleCAtIHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLm5leHRLZXkgPSBwbGFjZWhvbGRlci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlci5wcmV2S2V5ID0gcm93W3Jvdy5sZW5ndGggLSAxXS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldktleSA9IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLmxldmVsID0gaTtcbiAgICAgICAgICAgICAgICBpdGVtLmNvbEluZGV4ID0gY29sSW5kZXg7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29sSW5kZXgrKztcbiAgICB9XG4gICAgLy8gQWRkIHBsYWNlaG9sZGVycyBhdCB0aGUgZW5kIG9mIGVhY2ggcm93IHRoYXQgaXMgc2hvcnRlciB0aGFuIHRoZSBtYXhpbXVtXG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHJvdyBvZiBoZWFkZXJSb3dzKXtcbiAgICAgICAgbGV0IHJvd0xlbmd0aCA9IHJvdy5yZWR1Y2UoKHAsIGMpPT5wICsgYy5jb2xzcGFuLCAwKTtcbiAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbHVtbk5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICBrZXk6IFwicGxhY2Vob2xkZXItXCIgKyByb3dbcm93Lmxlbmd0aCAtIDFdLmtleSxcbiAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2x1bW5Ob2Rlcy5sZW5ndGggLSByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBsZXZlbDogaSxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldktleTogcm93W3Jvdy5sZW5ndGggLSAxXS5rZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb3cucHVzaChwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVyUm93cy5tYXAoKGNoaWxkTm9kZXMsIGluZGV4KT0+e1xuICAgICAgICBsZXQgcm93ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXJyb3dcIixcbiAgICAgICAgICAgIGtleTogXCJoZWFkZXJyb3ctXCIgKyBpbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG59XG5jbGFzcyAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCBleHRlbmRzICgwLCAkMUJmalckR3JpZENvbGxlY3Rpb24pIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvZHkuY2hpbGROb2RlcztcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHZhciBfZ2V0Rmlyc3RJdGVtO1xuICAgICAgICByZXR1cm4gKF9nZXRGaXJzdEl0ZW0gPSAoMCwgJDFCZmpXJGdldEZpcnN0SXRlbSkodGhpcy5ib2R5LmNoaWxkTm9kZXMpKSA9PT0gbnVsbCB8fCBfZ2V0Rmlyc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Rmlyc3RJdGVtLmtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgdmFyIF9nZXRMYXN0SXRlbTtcbiAgICAgICAgcmV0dXJuIChfZ2V0TGFzdEl0ZW0gPSAoMCwgJDFCZmpXJGdldExhc3RJdGVtKSh0aGlzLmJvZHkuY2hpbGROb2RlcykpID09PSBudWxsIHx8IF9nZXRMYXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldExhc3RJdGVtLmtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgZ2V0VGV4dFZhbHVlKGtleSkge1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghcm93KSByZXR1cm4gXCJcIjtcbiAgICAgICAgLy8gSWYgdGhlIHJvdyBoYXMgYSB0ZXh0VmFsdWUsIHVzZSB0aGF0LlxuICAgICAgICBpZiAocm93LnRleHRWYWx1ZSkgcmV0dXJuIHJvdy50ZXh0VmFsdWU7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjb21iaW5lIHRoZSB0ZXh0IG9mIGVhY2ggb2YgdGhlIHJvdyBoZWFkZXIgY29sdW1ucy5cbiAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbktleXMgPSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXM7XG4gICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2VsbCBvZiByb3cuY2hpbGROb2Rlcyl7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IHRoaXMuY29sdW1uc1tjZWxsLmluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocm93SGVhZGVyQ29sdW1uS2V5cy5oYXMoY29sdW1uLmtleSkgJiYgY2VsbC50ZXh0VmFsdWUpIHRleHQucHVzaChjZWxsLnRleHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSByb3dIZWFkZXJDb2x1bW5LZXlzLnNpemUpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5vZGVzLCBwcmV2LCBvcHRzKXtcbiAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICAvLyBBZGQgY2VsbCBmb3Igc2VsZWN0aW9uIGNoZWNrYm94ZXMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSB7XG4gICAgICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAga2V5OiAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdChyb3dIZWFkZXJDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjZWxsIGZvciBkcmFnIGJ1dHRvbnMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykge1xuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGtleTogJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc0RyYWdCdXR0b25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdChyb3dIZWFkZXJDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGxldCBjb2x1bW5LZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uS2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wcm9wcy5pc1Jvd0hlYWRlcikgcm93SGVhZGVyQ29sdW1uS2V5cy5hZGQobm9kZS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3QgZ28gaW50byBjaGlsZE5vZGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXZpc2l0KG5vZGUpO1xuICAgICAgICBsZXQgaGVhZGVyUm93cyA9ICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlKGNvbHVtbktleU1hcCwgY29sdW1ucyk7XG4gICAgICAgIGhlYWRlclJvd3MuZm9yRWFjaCgocm93LCBpKT0+cm93cy5zcGxpY2UoaSwgMCwgcm93KSk7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW1zOiByb3dzLFxuICAgICAgICAgICAgdmlzaXROb2RlOiAobm9kZSk9PntcbiAgICAgICAgICAgICAgICBub2RlLmNvbHVtbiA9IGNvbHVtbnNbbm9kZS5pbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzID0gcm93SGVhZGVyQ29sdW1uS2V5cztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5oZWFkZXJSb3dzID0gaGVhZGVyUm93cztcbiAgICAgICAgdGhpcy5fc2l6ZSA9IFtcbiAgICAgICAgICAgIC4uLmJvZHkuY2hpbGROb2Rlc1xuICAgICAgICBdLmxlbmd0aDtcbiAgICAgICAgLy8gRGVmYXVsdCByb3cgaGVhZGVyIGNvbHVtbiB0byB0aGUgZmlyc3Qgb25lLlxuICAgICAgICBpZiAodGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMl0ua2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5hZGQodGhpcy5jb2x1bW5zWzFdLmtleSk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMF0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbmNvbnN0ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiA9IHtcbiAgICBhc2NlbmRpbmc6IFwiZGVzY2VuZGluZ1wiLFxuICAgIGRlc2NlbmRpbmc6IFwiYXNjZW5kaW5nXCJcbn07XG5mdW5jdGlvbiAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNihwcm9wcykge1xuICAgIGxldCBbaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCwgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWRdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyB9ID0gcHJvcHM7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzICYmIHNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29sdW1uczogW11cbiAgICAgICAgfSksIFtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBzaG93RHJhZ0J1dHRvbnNcbiAgICBdKTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKG5vZGVzLCBudWxsLCBjb250ZXh0KSwgW1xuICAgICAgICBjb250ZXh0XG4gICAgXSksIGNvbnRleHQpO1xuICAgIGxldCB7IGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJDFCZmpXJHVzZUdyaWRTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogcHJvcHMuZGlzYWJsZWRCZWhhdmlvciB8fCBcInNlbGVjdGlvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBwcm9wcy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyB8fCBmYWxzZSxcbiAgICAgICAgc29ydERlc2NyaXB0b3I6IHByb3BzLnNvcnREZXNjcmlwdG9yLFxuICAgICAgICBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBjb2xsZWN0aW9uLnNpemUgPT09IDAgfHwgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCxcbiAgICAgICAgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzb3J0IChjb2x1bW5LZXksIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9wcm9wc19zb3J0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHByb3BzLm9uU29ydENoYW5nZSh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5LZXksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gIT09IG51bGwgJiYgZGlyZWN0aW9uICE9PSB2b2lkIDAgPyBkaXJlY3Rpb24gOiAoKF9wcm9wc19zb3J0RGVzY3JpcHRvciA9IHByb3BzLnNvcnREZXNjcmlwdG9yKSA9PT0gbnVsbCB8fCBfcHJvcHNfc29ydERlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wc19zb3J0RGVzY3JpcHRvci5jb2x1bW4pID09PSBjb2x1bW5LZXkgPyAkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT05bcHJvcHMuc29ydERlc2NyaXB0b3IuZGlyZWN0aW9uXSA6IFwiYXNjZW5kaW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlci5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgY29sdW1uczogY29sdW1ucyB9ID0gcHJvcHM7XG4gICAgLy8gQ2xlYXIgY29sdW1ucyBzbyB0aGV5IGFyZW4ndCBkb3VibGUgYWRkZWQgaW4gc3RyaWN0IG1vZGUuXG4gICAgY29udGV4dC5jb2x1bW5zID0gW107XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghY29sdW1ucykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLmNvbHVtbnMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpeWllbGQge1xuICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXG4gICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY29sdW1uKT0+e1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNvbHVtblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCogY29sdW1ucztcbiAgICB9XG59O1xuLyoqXG4gKiBBIFRhYmxlSGVhZGVyIGlzIGEgY29udGFpbmVyIGZvciB0aGUgQ29sdW1uIGVsZW1lbnRzIGluIGEgVGFibGUuIENvbHVtbnMgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGNvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSA9ICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJib2R5XCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFRhYmxlQm9keSBpcyBhIGNvbnRhaW5lciBmb3IgdGhlIFJvdyBlbGVtZW50cyBvZiBhIFRhYmxlLiBSb3dzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWRcbiAqIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGBpdGVtc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3ID0gJDRhZTUzMTRiZjUwZGIxYTMkdmFyJFRhYmxlQm9keTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4sIGNoaWxkQ29sdW1uczogY2hpbGRDb2x1bW5zIH0gPSBwcm9wcztcbiAgICBsZXQgcmVuZGVyZWQgPSB0aXRsZSB8fCBjaGlsZHJlbjtcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgcmVuZGVyZWQgPT09IFwic3RyaW5nXCIgPyByZW5kZXJlZCA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXTtcbiAgICBsZXQgZnVsbE5vZGVzID0geWllbGQge1xuICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAhIWNoaWxkQ29sdW1ucyB8fCB0aXRsZSAmJiAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAwLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENvbHVtbnMpIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkQ29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZENvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRDb2x1bW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IGl0IHdvcmtzLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGVuIHRoZXJlJ3MgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgLy8gQnV0LCB3ZSBuZWVkIHRvIGtlZXAgdGhlIGxpc3Qgb2YgY29sdW1ucyBpbiB0aGUgbmV3IGNvbnRleHQgdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUNvbnRleHQobmV3Q29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB1cGRhdGVDb250ZXh0ID0gKGNvbnRleHQpPT57XG4gICAgICAgIC8vIHJlZ2lzdGVyIGxlYWYgY29sdW1ucyBvbiB0aGUgY29udGV4dCBzbyB0aGF0IDxSb3c+IGNhbiBhY2Nlc3MgdGhlbVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGZ1bGxOb2RlcylpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgY29udGV4dC5jb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpO1xufTtcbi8qKlxuICogQSBDb2x1bW4gcmVwcmVzZW50cyBhIGZpZWxkIG9mIGVhY2ggaXRlbSB3aXRoaW4gYSBUYWJsZS4gQ29sdW1ucyBtYXkgYWxzbyBjb250YWluIG5lc3RlZFxuICogQ29sdW1uIGVsZW1lbnRzIHRvIHJlcHJlc2VudCBjb2x1bW4gZ3JvdXBzLiBOZXN0ZWQgY29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzXG4gKiBjaGlsZHJlbiwgb3IgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGBjaGlsZENvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyA9ICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW47XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdyhwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdy5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsIFVOU1RBQkxFX2NoaWxkSXRlbXM6IFVOU1RBQkxFX2NoaWxkSXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY2VsbHMgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNob3dEcmFnQnV0dG9ucykgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXItZHJhZ1wiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgY29udGV4dC5zZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIikgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbnRleHQuY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZHJlbihjb2x1bW4ua2V5KSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5IC8vIHRoaXMgaXMgY29tYmluZWQgd2l0aCB0aGUgcm93IGtleSBieSBDb2xsZWN0aW9uQnVpbGRlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKFVOU1RBQkxFX2NoaWxkSXRlbXMpIGZvciAobGV0IGNoaWxkIG9mIFVOU1RBQkxFX2NoaWxkSXRlbXMpLy8gTm90ZTogaW4gb3JkZXIgdG8gcmV1c2UgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBUYWJsZUJvZHkgZm9yIG91ciBjaGlsZCByb3dzLCB3ZSBqdXN0IG5lZWQgdG8geWllbGQgYSB0eXBlIGFuZCBhIHZhbHVlIGhlcmUuIENvbGxlY3Rpb25CdWlsZGVyIHdpbGwgdGhlbiBsb29rIHVwXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCByZW5kZXJlciBhbmQgdXNlIHRoYXQgdG8gYnVpbGQgdGhlIGZ1bGwgbm9kZSBvZiB0aGlzIGNoaWxkIHJvdywgdXNpbmcgdGhlIHZhbHVlIHByb3ZpZGVkIGhlcmUgdG8gZ2VuZXJhdGUgdGhlIGNlbGxzXG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUm93cyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChub2RlKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoIDwgY29udGV4dC5jb2x1bW5zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIG9mIGEgUm93J3MgY2hpbGQgQ2VsbHMgbXVzdCBiZSBwb3NpdGlvbmVkIGJlZm9yZSBhbnkgY2hpbGQgUm93cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFJvd3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBjZWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYENlbGwgY291bnQgbXVzdCBtYXRjaCBjb2x1bW4gY291bnQuIEZvdW5kICR7Y2VsbHMubGVuZ3RofSBjZWxscyBhbmQgJHtjb250ZXh0LmNvbHVtbnMubGVuZ3RofSBjb2x1bW5zLmApO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjZWxscztcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRSb3dzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCByb3dzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29udGV4dC5jb2x1bW5zLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCB8fCBuZXdDb250ZXh0LmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBjb250ZXh0LmNvbHVtbnNbaV0ua2V5KSB8fCBuZXdDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzICE9PSBjb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IG5ld0NvbnRleHQuc2hvd0RyYWdCdXR0b25zICE9PSBjb250ZXh0LnNob3dEcmFnQnV0dG9ucyB8fCBuZXdDb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IGNvbnRleHQuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFJvdyByZXByZXNlbnRzIGEgc2luZ2xlIGl0ZW0gaW4gYSBUYWJsZSBhbmQgY29udGFpbnMgQ2VsbCBlbGVtZW50cyBmb3IgZWFjaCBjb2x1bW4uXG4gKiBDZWxscyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvblxuICogYmFzZWQgb24gdGhlIGNvbHVtbnMgZGVmaW5lZCBpbiB0aGUgVGFibGVIZWFkZXIuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiA9ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3c7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbC5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiID8gY2hpbGRyZW4gOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlbixcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlXG4gICAgfTtcbn07XG4vKipcbiAqIEEgQ2VsbCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBDb2x1bW4gd2l0aGluIGEgVGFibGUgUm93LlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgPSAkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbDtcblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQocHJvcHMpIHtcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcywgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsIFVOU1RBQkxFX2V4cGFuZGVkS2V5czogcHJvcEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5czogcHJvcERlZmF1bHRFeHBhbmRlZEtleXMsIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2U6IFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgaWYgKCEoMCwgJDFCZmpXJHRhYmxlTmVzdGVkUm93cykoKSkgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBmbGFnIGZvciB0YWJsZSBuZXN0ZWQgcm93cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIHVzZVRyZWVHcmlkU3RhdGUuXCIpO1xuICAgIGxldCBbZXhwYW5kZWRLZXlzLCBzZXRFeHBhbmRlZEtleXNdID0gKDAsICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BFeHBhbmRlZEtleXMgPyAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKHByb3BFeHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcERlZmF1bHRFeHBhbmRlZEtleXMpIDogbmV3IFNldCgpLCBVTlNUQUJMRV9vbkV4cGFuZGVkQ2hhbmdlKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBidWlsZGVyID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIpKCksIFtdKTtcbiAgICBsZXQgbm9kZXMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5idWlsZGVyLmJ1aWxkKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9LCBjb250ZXh0KSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29udGV4dFxuICAgIF0pO1xuICAgIGxldCB0cmVlR3JpZENvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXNcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBub2RlcyxcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgZXhwYW5kZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IG9uVG9nZ2xlID0gKGtleSk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzKCRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoZXhwYW5kZWRLZXlzLCBrZXksIHRyZWVHcmlkQ29sbGVjdGlvbikpO1xuICAgIH07XG4gICAgbGV0IGNvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwKSh0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2RlcywgbnVsbCwgY29udGV4dCk7XG4gICAgfSwgW1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2Rlc1xuICAgIF0pO1xuICAgIGxldCB0YWJsZVN0YXRlID0gKDAsICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGFibGVTdGF0ZSxcbiAgICAgICAga2V5TWFwOiB0cmVlR3JpZENvbGxlY3Rpb24ua2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHRyZWVHcmlkQ29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxuICAgICAgICB0b2dnbGVLZXk6IG9uVG9nZ2xlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoY3VycmVudEV4cGFuZGVkS2V5cywga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgbGV0IHVwZGF0ZWRFeHBhbmRlZEtleXM7XG4gICAgaWYgKGN1cnJlbnRFeHBhbmRlZEtleXMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoY29sbGVjdGlvbi5mbGF0dGVuZWRSb3dzLmZpbHRlcigocm93KT0+cm93LnByb3BzLlVOU1RBQkxFX2NoaWxkSXRlbXMgfHwgcm93LnByb3BzLmNoaWxkcmVuLmxlbmd0aCA+IGNvbGxlY3Rpb24udXNlckNvbHVtbkNvdW50KS5tYXAoKHJvdyk9PnJvdy5rZXkpKTtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjdXJyZW50RXhwYW5kZWRLZXlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZWRFeHBhbmRlZEtleXMuaGFzKGtleSkpIHVwZGF0ZWRFeHBhbmRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgdXBkYXRlZEV4cGFuZGVkS2V5cy5hZGQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZWRFeHBhbmRlZEtleXM7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKGV4cGFuZGVkKSB7XG4gICAgaWYgKCFleHBhbmRlZCkgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZXhwYW5kZWQgPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3IFNldChleHBhbmRlZCk7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIG9wdHMpIHtcbiAgICBsZXQgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoKSB9ID0gb3B0cztcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgZmxhdHRlbmVkUm93cyA9IFtdO1xuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IHVzZXJDb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IG9yaWdpbmFsQ29sdW1ucyA9IFtdO1xuICAgIGxldCBrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykgY29sdW1uQ291bnQrKztcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgY29sdW1uQ291bnQrKztcbiAgICBsZXQgdG9wTGV2ZWxSb3dzID0gW107XG4gICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICBib2R5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBrZXlNYXAuc2V0KGJvZHkua2V5LCBib2R5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgdXNlckNvbHVtbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgIHRvcExldmVsUm93cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiY29sdW1uXCIpIG9yaWdpbmFsQ29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICB2aXNpdChub2RlKTtcbiAgICB9XG4gICAgY29sdW1uQ291bnQgKz0gdXNlckNvbHVtbkNvdW50O1xuICAgIC8vIFVwZGF0ZSBlYWNoIGdyaWQgbm9kZSBpbiB0aGUgdHJlZWdyaWQgdGFibGUgd2l0aCB2YWx1ZXMgc3BlY2lmaWMgdG8gYSB0cmVlZ3JpZCBzdHJ1Y3R1cmUuIEFsc28gc3RvcmUgYSBzZXQgb2YgZmxhdHRlbmVkIHJvdyBub2RlcyBmb3IgVGFibGVDb2xsZWN0aW9uIHRvIGNvbnN1bWVcbiAgICBsZXQgZ2xvYmFsUm93Q291bnQgPSAwO1xuICAgIGxldCB2aXNpdE5vZGUgPSAobm9kZSwgaSk9PntcbiAgICAgICAgLy8gQ2xvbmUgcm93IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBzbyBtb2RpZmljYXRpb25zIHRvIHRoZSBub2RlIGZvciB0cmVlZ3JpZCBzcGVjaWZpYyB2YWx1ZXMgYXJlbid0IGFwcGxpZWQgb24gdGhlIG5vZGVzIHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIFRhYmxlQ29sbGVjdGlvbi4gSW5kZXgsIGxldmVsLCBhbmQgcGFyZW50IGtleXMgYXJlIGFsbCBjaGFuZ2VkIHRvIHJlZmxlY3QgYSBmbGF0dGVuZWQgcm93IHN0cnVjdHVyZSByYXRoZXIgdGhhbiB0aGUgdHJlZWdyaWQgc3RydWN0dXJlXG4gICAgICAgIC8vIHZhbHVlcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgdmlhIENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmIChjaGlsZC50eXBlID09PSBcImNlbGxcIikge1xuICAgICAgICAgICAgICAgIGxldCBjZWxsQ2xvbmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbENsb25lLmluZGV4ICsgMSA9PT0gY29sdW1uQ291bnQpIGNlbGxDbG9uZS5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAuLi5jZWxsQ2xvbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5OiBib2R5LmtleSxcbiAgICAgICAgICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgICAgICAgICBpbmRleDogZ2xvYmFsUm93Q291bnQrK1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1Byb3BzID0ge307XG4gICAgICAgIC8vIEFzc2lnbiBpbmRleE9mVHlwZSB0byBjZWxscyBhbmQgcm93cyBmb3IgYXJpYS1wb3NpbnNldFxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcInBsYWNlaG9sZGVyXCIgJiYgbm9kZS50eXBlICE9PSBcImNvbHVtblwiKSBuZXdQcm9wc1tcImluZGV4T2ZUeXBlXCJdID0gaTtcbiAgICAgICAgLy8gVXNlIE9iamVjdC5hc3NpZ24gaW5zdGVhZCBvZiBzcHJlYWQgdG8gcHJlc2VydmUgb2JqZWN0IHJlZmVyZW5jZSBmb3Iga2V5TWFwLiBBbHNvIGVuc3VyZXMgcmV0cmlldmluZyBub2Rlc1xuICAgICAgICAvLyB2aWEgLmNoaWxkTm9kZXMgcmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIG9uZSBmb3VuZCB2aWEga2V5TWFwIGxvb2sgdXBcbiAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCBuZXdQcm9wcyk7XG4gICAgICAgIGtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAoIShjaGlsZC50eXBlID09PSBcIml0ZW1cIiAmJiBleHBhbmRlZEtleXMgIT09IFwiYWxsXCIgJiYgIWV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwvZXhwYW5kZWQgcm93L2NvbHVtbiBhbmQgdGhlIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGxhc3ROb2RlLm5leHRLZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3ROb2RlLmtleTtcbiAgICAgICAgICAgIH0gZWxzZSBjaGlsZC5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcIml0ZW1cIikgdmlzaXROb2RlKGNoaWxkLCByb3dJbmRleCsrKTtcbiAgICAgICAgICAgIGVsc2UgLy8gV2UgZW5mb3JjZSB0aGF0IHRoZSBjZWxscyBjb21lIGJlZm9yZSByb3dzIHNvIGNhbiBqdXN0IHJldXNlIGNlbGwgaW5kZXhcbiAgICAgICAgICAgIHZpc2l0Tm9kZShjaGlsZCwgY2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGUpIGxhc3ROb2RlLm5leHRLZXkgPSBudWxsO1xuICAgIH07XG4gICAgbGV0IGxhc3Q7XG4gICAgdG9wTGV2ZWxSb3dzLmZvckVhY2goKG5vZGUsIGkpPT57XG4gICAgICAgIHZpc2l0Tm9kZShub2RlLCBpKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgIH0gZWxzZSBub2RlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICB9KTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlNYXA6IGtleU1hcCxcbiAgICAgICAgdXNlckNvbHVtbkNvdW50OiB1c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGZsYXR0ZW5lZFJvd3M6IGZsYXR0ZW5lZFJvd3MsXG4gICAgICAgIHRhYmxlTm9kZXM6IFtcbiAgICAgICAgICAgIC4uLm9yaWdpbmFsQ29sdW1ucyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZsYXR0ZW5lZFJvd3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkgYXMgdXNlVGFibGVDb2x1bW5SZXNpemVTdGF0ZSwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYgYXMgdXNlVGFibGVTdGF0ZSwgJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUgYXMgVGFibGVIZWFkZXIsICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3IGFzIFRhYmxlQm9keSwgJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMgYXMgQ29sdW1uLCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiBhcyBSb3csICQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIGFzIENlbGwsICQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIGFzIFNlY3Rpb24sICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIGFzIFRhYmxlQ29sbGVjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUgYXMgYnVpbGRIZWFkZXJSb3dzLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSBhcyBUYWJsZUNvbHVtbkxheW91dCwgJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQgYXMgVU5TVEFCTEVfdXNlVHJlZUdyaWRTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiU2VjdGlvbiIsIiQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIiwidXNlQ29sbGVjdGlvbiIsIiQxQmZqVyR1c2VDb2xsZWN0aW9uIiwiZ2V0Rmlyc3RJdGVtIiwiJDFCZmpXJGdldEZpcnN0SXRlbSIsImdldExhc3RJdGVtIiwiJDFCZmpXJGdldExhc3RJdGVtIiwiQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckcmVhY3QiLCJ1c2VTdGF0ZSIsIiQxQmZqVyR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkMUJmalckdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDFCZmpXJHVzZUNhbGxiYWNrIiwidXNlR3JpZFN0YXRlIiwiJDFCZmpXJHVzZUdyaWRTdGF0ZSIsIkdyaWRDb2xsZWN0aW9uIiwiJDFCZmpXJEdyaWRDb2xsZWN0aW9uIiwidGFibGVOZXN0ZWRSb3dzIiwiJDFCZmpXJHRhYmxlTmVzdGVkUm93cyIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSIsIndpZHRoIiwiaXNOYU4iLCJTdHJpbmciLCJtYXRjaCIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0IiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUZsb2F0IiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYiLCJ0YWJsZVdpZHRoIiwiRXJyb3IiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxIiwibWluV2lkdGgiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSIsImF2YWlsYWJsZVdpZHRoIiwiY29sdW1ucyIsImNoYW5nZWRDb2x1bW5zIiwiZ2V0RGVmYXVsdFdpZHRoIiwiZ2V0RGVmYXVsdE1pbldpZHRoIiwiaGFzTm9uRnJvemVuSXRlbXMiLCJmbGV4SXRlbXMiLCJtYXAiLCJjb2x1bW4iLCJpbmRleCIsIl9jb2x1bW5fd2lkdGgiLCJfcmVmIiwiX3JlZjEiLCJnZXQiLCJrZXkiLCJkZWZhdWx0V2lkdGgiLCJmcm96ZW4iLCJiYXNlU2l6ZSIsImZsZXgiLCJ0YXJnZXRNYWluU2l6ZSIsIl9jb2x1bW5fbWluV2lkdGgiLCJfcmVmMiIsIm1pbiIsIm1heCIsImh5cG90aGV0aWNhbE1haW5TaXplIiwiTWF0aCIsInZpb2xhdGlvbiIsInVzZWRXaWR0aCIsImZsZXhGYWN0b3JzIiwiZm9yRWFjaCIsIml0ZW0iLCJyZW1haW5pbmdGcmVlU3BhY2UiLCJyYXRpbyIsInRvdGFsVmlvbGF0aW9uIiwic2lnbiIsIiQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmciLCJmcFRvdGFsIiwiaW50VG90YWwiLCJyb3VuZGVkQXJyYXkiLCJmbG9hdCIsImludGVnZXIiLCJyb3VuZCIsInB1c2giLCIkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSIsInNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkIiwicmVkdWNlIiwiYWNjIiwiY29sIiwicHJvcHMiLCJzZXQiLCJNYXAiLCJyZWNvbWJpbmVDb2x1bW5zIiwidW5jb250cm9sbGVkV2lkdGhzIiwidW5jb250cm9sbGVkQ29sdW1ucyIsImNvbnRyb2xsZWRDb2x1bW5zIiwiaGFzIiwiZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyIsIkFycmF5IiwiZnJvbSIsIl90aGlzX2dldERlZmF1bHRXaWR0aCIsIl90aGlzIiwiX2NvbF9wcm9wc19kZWZhdWx0V2lkdGgiLCJjYWxsIiwiZ2V0Q29sdW1uV2lkdGgiLCJfdGhpc19jb2x1bW5XaWR0aHNfZ2V0IiwiY29sdW1uV2lkdGhzIiwiZ2V0Q29sdW1uTWluV2lkdGgiLCJfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0IiwiY29sdW1uTWluV2lkdGhzIiwiZ2V0Q29sdW1uTWF4V2lkdGgiLCJfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0IiwiY29sdW1uTWF4V2lkdGhzIiwicmVzaXplQ29sdW1uV2lkdGgiLCJjb2xsZWN0aW9uIiwiY29udHJvbGxlZFdpZHRocyIsInByZXZDb2x1bW5XaWR0aHMiLCJyZXNpemVJbmRleCIsIkluZmluaXR5IiwicmVzaXppbmdDaGFuZ2VkIiwicGVyY2VudEtleXMiLCJmcktleXNUb1RoZVJpZ2h0IiwibWluV2lkdGhzIiwiaSIsIl9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGgiLCJfY29sdW1uX3Byb3BzX3dpZHRoIiwiZnJLZXkiLCJmclZhbHVlIiwiZW5kc1dpdGgiLCJmbG9vciIsIm5ld1dpZHRocyIsImJ1aWxkQ29sdW1uV2lkdGhzIiwid2lkdGhzIiwiX2NvbHVtbl9wcm9wc19taW5XaWR0aCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9vcHRpb25zX2dldERlZmF1bHRXaWR0aCIsIl9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCIsIiQyOTJiYzRlMDljZDBlYjYyJGV4cG9ydCRjYjg5NWRjZjg1ZGIxMzE5Iiwic3RhdGUiLCJyZXNpemluZ0NvbHVtbiIsInNldFJlc2l6aW5nQ29sdW1uIiwiY29sdW1uTGF5b3V0Iiwic2V0VW5jb250cm9sbGVkV2lkdGhzIiwibGFzdENvbHVtbnMiLCJzZXRMYXN0Q29sdW1ucyIsImxlbmd0aCIsInNvbWUiLCJjIiwibmV3VW5jb250cm9sbGVkV2lkdGhzIiwiY29sV2lkdGhzIiwic3RhcnRSZXNpemUiLCJ1cGRhdGVSZXNpemVkQ29sdW1ucyIsIm5ld0NvbnRyb2xsZWQiLCJlbnRyeSIsIm5ld1NpemVzIiwiZW5kUmVzaXplIiwidGFibGVTdGF0ZSIsIiQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHIiwiJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUiLCJrZXlNYXAiLCJjb2x1bW5Ob2RlcyIsInNlZW4iLCJwYXJlbnRLZXkiLCJwYXJlbnQiLCJjb2xzcGFuIiwic3BsaWNlIiwibWF4TGVuZ3RoIiwiaGVhZGVyUm93cyIsImZpbGwiLCJjb2xJbmRleCIsInJvdyIsInJvd0xlbmd0aCIsInAiLCJwbGFjZWhvbGRlciIsInR5cGUiLCJ2YWx1ZSIsInJlbmRlcmVkIiwibGV2ZWwiLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGROb2RlcyIsInRleHRWYWx1ZSIsIm5leHRLZXkiLCJwcmV2S2V5IiwiJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAiLCJTeW1ib2wiLCJpdGVyYXRvciIsImJvZHkiLCJzaXplIiwiX3NpemUiLCJnZXRLZXlzIiwia2V5cyIsImdldEtleUJlZm9yZSIsIm5vZGUiLCJnZXRLZXlBZnRlciIsImdldEZpcnN0S2V5IiwiX2dldEZpcnN0SXRlbSIsImdldExhc3RLZXkiLCJfZ2V0TGFzdEl0ZW0iLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJnZXRUZXh0VmFsdWUiLCJyb3dIZWFkZXJDb2x1bW5LZXlzIiwidGV4dCIsImNlbGwiLCJqb2luIiwibm9kZXMiLCJwcmV2Iiwib3B0cyIsIlNldCIsInNob3dTZWxlY3Rpb25DaGVja2JveGVzIiwicm93SGVhZGVyQ29sdW1uIiwic2hvd0RyYWdCdXR0b25zIiwiaXNTZWxlY3Rpb25DZWxsIiwidW5zaGlmdCIsImlzRHJhZ0J1dHRvbkNlbGwiLCJyb3dzIiwiY29sdW1uS2V5TWFwIiwidmlzaXQiLCJpc1Jvd0hlYWRlciIsImFkZCIsImNoaWxkIiwiY29sdW1uQ291bnQiLCJpdGVtcyIsInZpc2l0Tm9kZSIsIiQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCIkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNiIsImlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCJzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCIsInNlbGVjdGlvbk1vZGUiLCJjb250ZXh0IiwiY2hpbGRyZW4iLCJkaXNhYmxlZEtleXMiLCJzZWxlY3Rpb25NYW5hZ2VyIiwiZGlzYWJsZWRCZWhhdmlvciIsInNvcnREZXNjcmlwdG9yIiwic29ydCIsImNvbHVtbktleSIsImRpcmVjdGlvbiIsIl9wcm9wc19zb3J0RGVzY3JpcHRvciIsIm9uU29ydENoYW5nZSIsIiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlciIsImdldENvbGxlY3Rpb25Ob2RlIiwicmVuZGVyZXIiLCJDaGlsZHJlbiIsImVsZW1lbnQiLCIkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSIsIiQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHkiLCIkNGFlNTMxNGJmNTBkYjFhMyRleHBvcnQkNzZjY2QyMTBiOTAyOTkxNyIsIiQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW4iLCJ0aXRsZSIsImNoaWxkQ29sdW1ucyIsImZ1bGxOb2RlcyIsImNvdW50Iiwic2hvdWxkSW52YWxpZGF0ZSIsIm5ld0NvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwiJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMiLCIkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93IiwiVU5TVEFCTEVfY2hpbGRJdGVtcyIsImNlbGxzIiwiY2hpbGRSb3dzIiwiJDcwZDcwZWIxNmVhNDg0MjgkZXhwb3J0JGI1OWJkYmVmOWNlNzBkZTIiLCIkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbCIsIiQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIiwiJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQiLCJVTlNUQUJMRV9leHBhbmRlZEtleXMiLCJwcm9wRXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5cyIsInByb3BEZWZhdWx0RXhwYW5kZWRLZXlzIiwiVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSIsImV4cGFuZGVkS2V5cyIsInNldEV4cGFuZGVkS2V5cyIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQiLCJ1bmRlZmluZWQiLCJidWlsZGVyIiwiYnVpbGQiLCJ0cmVlR3JpZENvbGxlY3Rpb24iLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24iLCJvblRvZ2dsZSIsIiRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkiLCJ0YWJsZU5vZGVzIiwidXNlckNvbHVtbkNvdW50IiwidG9nZ2xlS2V5IiwiY3VycmVudEV4cGFuZGVkS2V5cyIsInVwZGF0ZWRFeHBhbmRlZEtleXMiLCJmbGF0dGVuZWRSb3dzIiwiZmlsdGVyIiwiZGVsZXRlIiwiZXhwYW5kZWQiLCJvcmlnaW5hbENvbHVtbnMiLCJ0b3BMZXZlbFJvd3MiLCJnbG9iYWxSb3dDb3VudCIsImNlbGxDbG9uZSIsImNsb25lIiwibmV3UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0Tm9kZSIsInJvd0luZGV4IiwibGFzdCIsInVzZVRhYmxlQ29sdW1uUmVzaXplU3RhdGUiLCJ1c2VUYWJsZVN0YXRlIiwiVGFibGVIZWFkZXIiLCJUYWJsZUJvZHkiLCJDb2x1bW4iLCJSb3ciLCJDZWxsIiwiVGFibGVDb2xsZWN0aW9uIiwiYnVpbGRIZWFkZXJSb3dzIiwiVGFibGVDb2x1bW5MYXlvdXQiLCJVTlNUQUJMRV91c2VUcmVlR3JpZFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQ25CO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBRUQsU0FBU00sd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDLEdBQUdSLHlFQUE4QixFQUFHO1FBQzdDLEdBQUdNLEtBQUs7UUFDUkcsMEJBQTBCO1FBQzFCQyxvQkFBb0IsQ0FBQ0gsNEJBQTRCRCxNQUFNSSxrQkFBa0IsTUFBTSxRQUFRSCw4QkFBOEIsS0FBSyxJQUFJQSw0QkFBNEJJLDZDQUE2Q0wsTUFBTU0sVUFBVSxFQUFFTixNQUFNTyxZQUFZLEdBQUcsSUFBSUMsSUFBSVIsTUFBTU8sWUFBWSxJQUFJLElBQUlDO0lBQ3BSO0lBQ0EsSUFBSSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFSCxZQUFZQSxVQUFVLEVBQUVJLGFBQWFDLGtCQUFrQixFQUFFLEdBQUdUO0lBQ3RHLElBQUlVLGtCQUFrQixDQUFDLEdBQUdoQix5Q0FBWSxFQUFHZTtJQUN4QyxJQUFHYiw0Q0FBZSxFQUFHO1FBQ2xCLDBIQUEwSDtRQUMxSCxJQUFJWSxjQUFjQztRQUNsQixJQUFJRixpQkFBaUJJLE9BQU8sSUFBSSxDQUFDUCxXQUFXUSxPQUFPLENBQUNKLGNBQWM7WUFDOURBLGNBQWNMLDZDQUE2Q0MsWUFBWUosTUFBTUssWUFBWTtZQUN6RixJQUFJRyxlQUFlLE1BQ25CRCxpQkFBaUJNLGVBQWUsQ0FBQztnQkFDN0JMO2FBQ0g7UUFDTDtRQUNBLDJKQUEySjtRQUMzSixJQUFJQSxlQUFlLFFBQVFELGlCQUFpQk8sVUFBVSxJQUFJLFFBQVEsQ0FBQ1AsaUJBQWlCUSxTQUFTLElBQUlQLGdCQUFnQkUsZ0JBQWdCTSxPQUFPLEVBQUVULGlCQUFpQlUsYUFBYSxDQUFDVDtRQUN6S0UsZ0JBQWdCTSxPQUFPLEdBQUdSO0lBQzlCO0lBQ0EsT0FBTztRQUNILEdBQUdSLEtBQUs7UUFDUmtCLFlBQVlwQixNQUFNb0IsVUFBVSxJQUFJO0lBQ3BDO0FBQ0o7QUFDQSxTQUFTZiw2Q0FBNkNDLFVBQVUsRUFBRUMsWUFBWTtJQUMxRSxJQUFJRyxjQUFjO0lBQ2xCLElBQUlKLFlBQVk7UUFDWkksY0FBY0osV0FBV2UsV0FBVztRQUNwQyx1RUFBdUU7UUFDdkUsTUFBTWQsYUFBYWUsR0FBRyxDQUFDWixnQkFBZ0JBLGdCQUFnQkosV0FBV2lCLFVBQVUsR0FBR2IsY0FBY0osV0FBV2tCLFdBQVcsQ0FBQ2Q7UUFDcEgsb0hBQW9IO1FBQ3BILElBQUlILGFBQWFlLEdBQUcsQ0FBQ1osZ0JBQWdCQSxnQkFBZ0JKLFdBQVdpQixVQUFVLElBQUliLGNBQWNKLFdBQVdlLFdBQVc7SUFDdEg7SUFDQSxPQUFPWDtBQUNYO0FBS29FLENBQ3BFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJzL2Rpc3QvaW1wb3J0Lm1qcz85YzhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIGFzICRpakhLWiR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9saXN0XCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkaWpIS1okdXNlUmVmLCB1c2VFZmZlY3QgYXMgJGlqSEtaJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ3NmY5MTlhMDRjNWE3ZDE0JGV4cG9ydCQ0YmEwNzFkYWY0ZTQ4Nihwcm9wcykge1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5O1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkaWpIS1okdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmc6IHRydWUsXG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZEtleTogKF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgPSBwcm9wcy5kZWZhdWx0U2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgIT09IHZvaWQgMCA/IF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkgOiAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShwcm9wcy5jb2xsZWN0aW9uLCBwcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCkpXG4gICAgfSk7XG4gICAgbGV0IHsgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciwgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgc2VsZWN0ZWRLZXk6IGN1cnJlbnRTZWxlY3RlZEtleSB9ID0gc3RhdGU7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleSA9ICgwLCAkaWpIS1okdXNlUmVmKShjdXJyZW50U2VsZWN0ZWRLZXkpO1xuICAgICgwLCAkaWpIS1okdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgYSB0YWIgaXMgYWx3YXlzIHNlbGVjdGVkIChpbiBjYXNlIG5vIHNlbGVjdGVkIGtleSB3YXMgc3BlY2lmaWVkIG9yIGlmIHNlbGVjdGVkIGl0ZW0gd2FzIGRlbGV0ZWQgZnJvbSBjb2xsZWN0aW9uKVxuICAgICAgICBsZXQgc2VsZWN0ZWRLZXkgPSBjdXJyZW50U2VsZWN0ZWRLZXk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25NYW5hZ2VyLmlzRW1wdHkgfHwgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5ID0gJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkoY29sbGVjdGlvbiwgc3RhdGUuZGlzYWJsZWRLZXlzKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEtleSAhPSBudWxsKSAvLyBkaXJlY3RseSBzZXQgc2VsZWN0aW9uIGJlY2F1c2UgcmVwbGFjZS90b2dnbGUgc2VsZWN0aW9uIHdvbid0IGNvbnNpZGVyIGRpc2FibGVkIGtleXNcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0U2VsZWN0ZWRLZXlzKFtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEtleVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHRhYmxpc3QgZG9lc24ndCBoYXZlIGZvY3VzIGFuZCB0aGUgc2VsZWN0ZWQga2V5IGNoYW5nZXMgb3IgaWYgdGhlcmUgaXNuJ3QgYSBmb2N1c2VkIGtleSB5ZXQsIGNoYW5nZSBmb2N1c2VkIGtleSB0byB0aGUgc2VsZWN0ZWQga2V5IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5ID09IG51bGwgfHwgIXNlbGVjdGlvbk1hbmFnZXIuaXNGb2N1c2VkICYmIHNlbGVjdGVkS2V5ICE9PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCkgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkS2V5KHNlbGVjdGVkS2V5KTtcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBzZWxlY3RlZEtleTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNEaXNhYmxlZCB8fCBmYWxzZVxuICAgIH07XG59XG5mdW5jdGlvbiAkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleShjb2xsZWN0aW9uLCBkaXNhYmxlZEtleXMpIHtcbiAgICBsZXQgc2VsZWN0ZWRLZXkgPSBudWxsO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpO1xuICAgICAgICAvLyBsb29wIG92ZXIgdGFicyB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGlzbid0IGRpc2FibGVkIGFuZCBzZWxlY3QgdGhhdFxuICAgICAgICB3aGlsZShkaXNhYmxlZEtleXMuaGFzKHNlbGVjdGVkS2V5KSAmJiBzZWxlY3RlZEtleSAhPT0gY29sbGVjdGlvbi5nZXRMYXN0S2V5KCkpc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEtleUFmdGVyKHNlbGVjdGVkS2V5KTtcbiAgICAgICAgLy8gaWYgdGhpcyBjaGVjayBpcyB0cnVlLCB0aGVuIGV2ZXJ5IGl0ZW0gaXMgZGlzYWJsZWQsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byB0aGUgZmlyc3Qga2V5IHRoYW4gdGhlIGxhc3RcbiAgICAgICAgaWYgKGRpc2FibGVkS2V5cy5oYXMoc2VsZWN0ZWRLZXkpICYmIHNlbGVjdGVkS2V5ID09PSBjb2xsZWN0aW9uLmdldExhc3RLZXkoKSkgc2VsZWN0ZWRLZXkgPSBjb2xsZWN0aW9uLmdldEZpcnN0S2V5KCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZEtleTtcbn1cblxuXG5cblxuZXhwb3J0IHskNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYgYXMgdXNlVGFiTGlzdFN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUiLCIkaWpIS1okdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwidXNlUmVmIiwiJGlqSEtaJHVzZVJlZiIsInVzZUVmZmVjdCIsIiRpakhLWiR1c2VFZmZlY3QiLCIkNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYiLCJwcm9wcyIsIl9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXkiLCJzdGF0ZSIsInN1cHByZXNzVGV4dFZhbHVlV2FybmluZyIsImRlZmF1bHRTZWxlY3RlZEtleSIsIiQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5IiwiY29sbGVjdGlvbiIsImRpc2FibGVkS2V5cyIsIlNldCIsInNlbGVjdGlvbk1hbmFnZXIiLCJzZWxlY3RlZEtleSIsImN1cnJlbnRTZWxlY3RlZEtleSIsImxhc3RTZWxlY3RlZEtleSIsImlzRW1wdHkiLCJnZXRJdGVtIiwic2V0U2VsZWN0ZWRLZXlzIiwiZm9jdXNlZEtleSIsImlzRm9jdXNlZCIsImN1cnJlbnQiLCJzZXRGb2N1c2VkS2V5IiwiaXNEaXNhYmxlZCIsImdldEZpcnN0S2V5IiwiaGFzIiwiZ2V0TGFzdEtleSIsImdldEtleUFmdGVyIiwidXNlVGFiTGlzdFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELFNBQVNFLDBDQUEwQ0MsUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR0Q7SUFDakMsOEVBQThFO0lBQzlFLCtGQUErRjtJQUMvRixJQUFJLENBQUNFLFlBQVlDLFlBQVksR0FBRyxDQUFDLEdBQUdMLG9FQUF3QixFQUFHRSxNQUFNRSxVQUFVLEVBQUVGLE1BQU1JLGVBQWUsSUFBSSxPQUFPSixNQUFNSyxRQUFRO0lBQy9ILFNBQVNDLGVBQWVDLEtBQUs7UUFDekIsSUFBSSxDQUFDTixZQUFZRSxZQUFZSTtJQUNqQztJQUNBLFNBQVNDO1FBQ0wsSUFBSSxDQUFDUCxZQUFZRSxZQUFZLENBQUNEO0lBQ2xDO0lBQ0EsT0FBTztRQUNIQSxZQUFZQTtRQUNaQyxhQUFhRztRQUNiRyxRQUFRRDtJQUNaO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RvZ2dsZS9kaXN0L2ltcG9ydC5tanM/Zjg1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2KHByb3BzID0ge30pIHtcbiAgICBsZXQgeyBpc1JlYWRPbmx5OiBpc1JlYWRPbmx5IH0gPSBwcm9wcztcbiAgICAvLyBoYXZlIHRvIHByb3ZpZGUgYW4gZW1wdHkgZnVuY3Rpb24gc28gdXNlQ29udHJvbGxlZFN0YXRlIGRvZXNuJ3QgdGhyb3cgYSBmaXRcbiAgICAvLyBjYW4ndCB1c2UgdXNlQ29udHJvbGxlZFN0YXRlJ3MgcHJvcCBjYWxsaW5nIGJlY2F1c2Ugd2UgbmVlZCB0aGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGNoYW5nZVxuICAgIGxldCBbaXNTZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gKDAsICRiT2thZSR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLmlzU2VsZWN0ZWQsIHByb3BzLmRlZmF1bHRTZWxlY3RlZCB8fCBmYWxzZSwgcHJvcHMub25DaGFuZ2UpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNSZWFkT25seSkgc2V0U2VsZWN0ZWQodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2dnbGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSBzZXRTZWxlY3RlZCghaXNTZWxlY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgICAgIHNldFNlbGVjdGVkOiB1cGRhdGVTZWxlY3RlZCxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGVTdGF0ZVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYgYXMgdXNlVG9nZ2xlU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRiT2thZSR1c2VDb250cm9sbGVkU3RhdGUiLCIkMzAxN2ZhN2ZmZGRkZWM3NCRleHBvcnQkODA0MmM2YzAxM2ZkNTIyNiIsInByb3BzIiwiaXNSZWFkT25seSIsImlzU2VsZWN0ZWQiLCJzZXRTZWxlY3RlZCIsImRlZmF1bHRTZWxlY3RlZCIsIm9uQ2hhbmdlIiwidXBkYXRlU2VsZWN0ZWQiLCJ2YWx1ZSIsInRvZ2dsZVN0YXRlIiwidG9nZ2xlIiwidXNlVG9nZ2xlU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7QUFFaEc7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxNQUFNUSxzQ0FBc0MsTUFBTSx5REFBeUQ7QUFDM0csTUFBTUMseUNBQXlDO0FBQy9DLElBQUlDLGlDQUFpQyxDQUFDO0FBQ3RDLElBQUlDLGtDQUFrQztBQUN0QyxJQUFJQyx1Q0FBdUM7QUFDM0MsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLDhDQUE4QztBQUNsRCxTQUFTQywwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksRUFBRUMsT0FBT0EsUUFBUVQsbUNBQW1DLEVBQUVVLFlBQVlBLGFBQWFULHNDQUFzQyxFQUFFLEdBQUdPO0lBQzlILElBQUksRUFBRUcsUUFBUUEsTUFBTSxFQUFFQyxNQUFNQSxJQUFJLEVBQUVDLE9BQU9BLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBR2QsMkVBQTRCLEVBQUdTO0lBQ3RGLElBQUlNLEtBQUssQ0FBQyxHQUFHckIsMENBQWEsRUFBRyxJQUFJLENBQUMsRUFBRSxFQUFFVSxnQ0FBZ0MsQ0FBQyxFQUFFLEVBQUU7SUFDM0UsSUFBSVksZUFBZSxDQUFDLEdBQUdwQix5Q0FBWTtJQUNuQyxJQUFJcUIscUJBQXFCO1FBQ3JCZCw4QkFBOEIsQ0FBQ1ksR0FBRyxHQUFHRztJQUN6QztJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixJQUFJLElBQUlDLGlCQUFpQmpCLCtCQUErQixJQUFJaUIsa0JBQWtCTCxJQUFJO1lBQzlFWiw4QkFBOEIsQ0FBQ2lCLGNBQWMsQ0FBQztZQUM5QyxPQUFPakIsOEJBQThCLENBQUNpQixjQUFjO1FBQ3hEO0lBQ0o7SUFDQSxJQUFJQyxjQUFjO1FBQ2RDLGFBQWFOLGFBQWFPLE9BQU87UUFDakNQLGFBQWFPLE9BQU8sR0FBRztRQUN2Qko7UUFDQUY7UUFDQVosdUNBQXVDO1FBQ3ZDUTtRQUNBLElBQUlQLDJDQUEyQztZQUMzQ2dCLGFBQWFoQjtZQUNiQSw0Q0FBNEM7UUFDaEQ7UUFDQSxJQUFJQyw2Q0FBNkM7WUFDN0NlLGFBQWFmO1lBQ2JBLDhDQUE4QztRQUNsRDtJQUNKO0lBQ0EsSUFBSVcsY0FBYyxDQUFDTTtRQUNmLElBQUlBLGFBQWFiLGNBQWMsR0FBRztZQUM5QlcsYUFBYU4sYUFBYU8sT0FBTztZQUNqQ1AsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLE9BQU8sSUFBSSxDQUFDRSxhQUFhTyxPQUFPLEVBQUVQLGFBQWFPLE9BQU8sR0FBR0UsV0FBVztZQUNoRVQsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLEdBQUdIO1FBQ0gsSUFBSUwsMkNBQTJDO1lBQzNDZ0IsYUFBYWhCO1lBQ2JBLDRDQUE0QztRQUNoRDtRQUNBLElBQUlELHNDQUFzQztZQUN0QyxJQUFJRSw2Q0FBNkNlLGFBQWFmO1lBQzlEQSw4Q0FBOENrQixXQUFXO2dCQUNyRCxPQUFPdEIsOEJBQThCLENBQUNZLEdBQUc7Z0JBQ3pDUiw4Q0FBOEM7Z0JBQzlDRix1Q0FBdUM7WUFDM0MsR0FBR3FCLEtBQUtDLEdBQUcsQ0FBQ3pCLHdDQUF3Q1M7UUFDeEQ7SUFDSjtJQUNBLElBQUlpQixnQkFBZ0I7UUFDaEJUO1FBQ0FGO1FBQ0EsSUFBSSxDQUFDTCxVQUFVLENBQUNOLDZDQUE2QyxDQUFDRCxzQ0FBc0NDLDRDQUE0Q21CLFdBQVc7WUFDdkpuQiw0Q0FBNEM7WUFDNUNELHVDQUF1QztZQUN2Q2dCO1FBQ0osR0FBR1g7YUFDRSxJQUFJLENBQUNFLFFBQVFTO0lBQ3RCO0lBQ0EsNENBQTRDO0lBQzNDLElBQUd2Qiw0Q0FBZSxFQUFHO1FBQ2xCLE9BQU87WUFDSHdCLGFBQWFOLGFBQWFPLE9BQU87WUFDakMsSUFBSU0sVUFBVTFCLDhCQUE4QixDQUFDWSxHQUFHO1lBQ2hELElBQUljLFNBQVMsT0FBTzFCLDhCQUE4QixDQUFDWSxHQUFHO1FBQzFEO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBTztRQUNISCxRQUFRQTtRQUNSQyxNQUFNLENBQUNXO1lBQ0gsSUFBSSxDQUFDQSxhQUFhZCxRQUFRLEtBQUssQ0FBQ00sYUFBYU8sT0FBTyxFQUFFSztpQkFDakRQO1FBQ1Q7UUFDQVAsT0FBT0k7SUFDWDtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90b29sdGlwL2Rpc3QvaW1wb3J0Lm1qcz8xNThhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTWVtbyBhcyAkMU9oRHEkdXNlTWVtbywgdXNlUmVmIGFzICQxT2hEcSR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkMU9oRHEkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0RFTEFZID0gMTUwMDsgLy8gdGhpcyBzZWVtcyB0byBiZSBhIDEuNSBzZWNvbmQgZGVsYXksIGNoZWNrIHdpdGggZGVzaWduXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiA9IDUwMDtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMgPSB7fTtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkID0gMDtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcbmxldCAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG5mdW5jdGlvbiAkODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgZGVsYXk6IGRlbGF5ID0gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfREVMQVksIGNsb3NlRGVsYXk6IGNsb3NlRGVsYXkgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiB9ID0gcHJvcHM7XG4gICAgbGV0IHsgaXNPcGVuOiBpc09wZW4sIG9wZW46IG9wZW4sIGNsb3NlOiBjbG9zZSB9ID0gKDAsICQxT2hEcSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGlkID0gKDAsICQxT2hEcSR1c2VNZW1vKSgoKT0+YCR7KyskODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkfWAsIFtdKTtcbiAgICBsZXQgY2xvc2VUaW1lb3V0ID0gKDAsICQxT2hEcSR1c2VSZWYpKCk7XG4gICAgbGV0IGVuc3VyZVRvb2x0aXBFbnRyeSA9ICgpPT57XG4gICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF0gPSBoaWRlVG9vbHRpcDtcbiAgICB9O1xuICAgIGxldCBjbG9zZU9wZW5Ub29sdGlwcyA9ICgpPT57XG4gICAgICAgIGZvcihsZXQgaGlkZVRvb2x0aXBJZCBpbiAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMpaWYgKGhpZGVUb29sdGlwSWQgIT09IGlkKSB7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaGlkZVRvb2x0aXBJZF0odHJ1ZSk7XG4gICAgICAgICAgICBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2hpZGVUb29sdGlwSWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc2hvd1Rvb2x0aXAgPSAoKT0+e1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICBjbG9zZVRpbWVvdXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGNsb3NlT3BlblRvb2x0aXBzKCk7XG4gICAgICAgIGVuc3VyZVRvb2x0aXBFbnRyeSgpO1xuICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSB0cnVlO1xuICAgICAgICBvcGVuKCk7XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBoaWRlVG9vbHRpcCA9IChpbW1lZGlhdGUpPT57XG4gICAgICAgIGlmIChpbW1lZGlhdGUgfHwgY2xvc2VEZWxheSA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2xvc2VUaW1lb3V0LmN1cnJlbnQpIGNsb3NlVGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSwgY2xvc2VEZWxheSk7XG4gICAgICAgIGlmICgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwKSB7XG4gICAgICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCkgY2xlYXJUaW1lb3V0KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpO1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICBkZWxldGUgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2lkXTtcbiAgICAgICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIE1hdGgubWF4KCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0NPT0xET1dOLCBjbG9zZURlbGF5KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB3YXJtdXBUb29sdGlwID0gKCk9PntcbiAgICAgICAgY2xvc2VPcGVuVG9vbHRpcHMoKTtcbiAgICAgICAgZW5zdXJlVG9vbHRpcEVudHJ5KCk7XG4gICAgICAgIGlmICghaXNPcGVuICYmICEkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCAmJiAhJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwKSAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtVXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCA9IHRydWU7XG4gICAgICAgICAgICBzaG93VG9vbHRpcCgpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGVsc2UgaWYgKCFpc09wZW4pIHNob3dUb29sdGlwKCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuICAgICgwLCAkMU9oRHEkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQuY3VycmVudCk7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgICAgICBpZiAodG9vbHRpcCkgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpZFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogaXNPcGVuLFxuICAgICAgICBvcGVuOiAoaW1tZWRpYXRlKT0+e1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgZGVsYXkgPiAwICYmICFjbG9zZVRpbWVvdXQuY3VycmVudCkgd2FybXVwVG9vbHRpcCgpO1xuICAgICAgICAgICAgZWxzZSBzaG93VG9vbHRpcCgpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogaGlkZVRvb2x0aXBcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQ4Nzk2ZjkwNzM2ZTE3NWNiJGV4cG9ydCQ0ZDQwNjU5YzI1ZWNiNTBiIGFzIHVzZVRvb2x0aXBUcmlnZ2VyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU1lbW8iLCIkMU9oRHEkdXNlTWVtbyIsInVzZVJlZiIsIiQxT2hEcSR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkMU9oRHEkdXNlRWZmZWN0IiwidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiQxT2hEcSR1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfREVMQVkiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwcyIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwSWQiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQiLCIkODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYiIsInByb3BzIiwiZGVsYXkiLCJjbG9zZURlbGF5IiwiaXNPcGVuIiwib3BlbiIsImNsb3NlIiwiaWQiLCJjbG9zZVRpbWVvdXQiLCJlbnN1cmVUb29sdGlwRW50cnkiLCJoaWRlVG9vbHRpcCIsImNsb3NlT3BlblRvb2x0aXBzIiwiaGlkZVRvb2x0aXBJZCIsInNob3dUb29sdGlwIiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudCIsImltbWVkaWF0ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwibWF4Iiwid2FybXVwVG9vbHRpcCIsInRvb2x0aXAiLCJ1c2VUb29sdGlwVHJpZ2dlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9KO0FBQ2xDO0FBQ2pDO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQUcsTUFBTWM7SUFDTixDQUFDLENBQUNDLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNELElBQUk7SUFDM0I7SUFDQUUsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDRCxNQUFNLENBQUNFLElBQUk7SUFDM0I7SUFDQUMsYUFBYUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLRSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsWUFBWUosR0FBRyxFQUFFO1FBQ2IsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLSSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQyxRQUFRVixHQUFHLEVBQUU7UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTSxHQUFHLENBQUNGO0lBQzNCO0lBQ0FXLEdBQUdDLEdBQUcsRUFBRTtRQUNKLE1BQU1kLE9BQU87ZUFDTixJQUFJLENBQUNELE9BQU87U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQ2EsT0FBTyxDQUFDWixJQUFJLENBQUNjLElBQUk7SUFDakM7SUFDQUMsWUFBWUMsS0FBSyxFQUFFLEVBQUVD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TUFBTSxJQUFJekIsSUFBSUU7SUFDbEIsSUFBSXVCLElBQUlwQixHQUFHLENBQUN0QixNQUFNMEMsSUFBSUMsTUFBTSxDQUFDM0M7U0FDeEIwQyxJQUFJRSxHQUFHLENBQUM1QztJQUNiLE9BQU8wQztBQUNYO0FBTWdJLENBQ2hJLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rlc2lnbi1lbmdpbmVlci8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90cmVlL2Rpc3QvaW1wb3J0Lm1qcz9iMDlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSBhcyAkMU9vVGokdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSwgU2VsZWN0aW9uTWFuYWdlciBhcyAkMU9vVGokU2VsZWN0aW9uTWFuYWdlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3NlbGVjdGlvblwiO1xuaW1wb3J0IHt1c2VNZW1vIGFzICQxT29UaiR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkMU9vVGokdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCBhcyAkMU9vVGokdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29sbGVjdGlvbiBhcyAkMU9vVGokdXNlQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5pdGVyYWJsZTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0S2V5O1xuICAgIH1cbiAgICBnZXRMYXN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0S2V5O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGF0KGlkeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5nZXRLZXlzKClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShrZXlzW2lkeF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyB9ID0ge30pe1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG5vZGVzO1xuICAgICAgICBleHBhbmRlZEtleXMgPSBleHBhbmRlZEtleXMgfHwgbmV3IFNldCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIChub2RlLnR5cGUgPT09IFwic2VjdGlvblwiIHx8IGV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSBub2RlLmluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xuICAgICAgICAgICAgLy8gU2V0IG5leHRLZXkgYXMgdW5kZWZpbmVkIHNpbmNlIHRoaXMgbWlnaHQgYmUgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgdGhlIGxhc3Qgbm9kZSwgbGFzdC5uZXh0S2V5IHdpbGwgcHJvcGVybHkgc2V0IGF0IHN0YXJ0IG9mIG5ldyBsb29wXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0S2V5ID0gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG59XG5cblxuXG5cblxuZnVuY3Rpb24gJDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYocHJvcHMpIHtcbiAgICBsZXQgW2V4cGFuZGVkS2V5cywgc2V0RXhwYW5kZWRLZXlzXSA9ICgwLCAkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5leHBhbmRlZEtleXMgPyBuZXcgU2V0KHByb3BzLmV4cGFuZGVkS2V5cykgOiB1bmRlZmluZWQsIHByb3BzLmRlZmF1bHRFeHBhbmRlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRlZmF1bHRFeHBhbmRlZEtleXMpIDogbmV3IFNldCgpLCBwcm9wcy5vbkV4cGFuZGVkQ2hhbmdlKTtcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICQxT29UaiR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCB0cmVlID0gKDAsICQxT29UaiR1c2VDb2xsZWN0aW9uKShwcm9wcywgKDAsICQxT29UaiR1c2VDYWxsYmFjaykoKG5vZGVzKT0+bmV3ICgwLCAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSkobm9kZXMsIHtcbiAgICAgICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGV4cGFuZGVkS2V5c1xuICAgIF0pLCBudWxsKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICgwLCAkMU9vVGokdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSAhPSBudWxsICYmICF0cmVlLmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSkpIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleVxuICAgIF0pO1xuICAgIGxldCBvblRvZ2dsZSA9IChrZXkpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5cygkODc1ZDY2OTNlMTJhZjA3MSR2YXIkdG9nZ2xlS2V5KGV4cGFuZGVkS2V5cywga2V5KSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiB0cmVlLFxuICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyxcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHRvZ2dsZUtleTogb25Ub2dnbGUsXG4gICAgICAgIHNldEV4cGFuZGVkS2V5czogc2V0RXhwYW5kZWRLZXlzLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBuZXcgKDAsICQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyKSh0cmVlLCBzZWxlY3Rpb25TdGF0ZSlcbiAgICB9O1xufVxuZnVuY3Rpb24gJDg3NWQ2NjkzZTEyYWYwNzEkdmFyJHRvZ2dsZUtleShzZXQsIGtleSkge1xuICAgIGxldCByZXMgPSBuZXcgU2V0KHNldCk7XG4gICAgaWYgKHJlcy5oYXMoa2V5KSkgcmVzLmRlbGV0ZShrZXkpO1xuICAgIGVsc2UgcmVzLmFkZChrZXkpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuXG5cblxuZXhwb3J0IHskODc1ZDY2OTNlMTJhZjA3MSRleHBvcnQkNzI4ZDZiYTUzNDQwMzc1NiBhcyB1c2VUcmVlU3RhdGUsICQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhIGFzIFRyZWVDb2xsZWN0aW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIiwiJDFPb1RqJFNlbGVjdGlvbk1hbmFnZXIiLCJ1c2VNZW1vIiwiJDFPb1RqJHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiQxT29UaiR1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsIiQxT29UaiR1c2VFZmZlY3QiLCJ1c2VDb2xsZWN0aW9uIiwiJDFPb1RqJHVzZUNvbGxlY3Rpb24iLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkMU9vVGokdXNlQ29udHJvbGxlZFN0YXRlIiwiJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEiLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZXJhYmxlIiwic2l6ZSIsImtleU1hcCIsImdldEtleXMiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwia2V5Iiwibm9kZSIsImdldCIsInByZXZLZXkiLCJnZXRLZXlBZnRlciIsIm5leHRLZXkiLCJnZXRGaXJzdEtleSIsImZpcnN0S2V5IiwiZ2V0TGFzdEtleSIsImxhc3RLZXkiLCJnZXRJdGVtIiwiYXQiLCJpZHgiLCJjb25zdHJ1Y3RvciIsIm5vZGVzIiwiZXhwYW5kZWRLZXlzIiwiTWFwIiwiU2V0IiwidmlzaXQiLCJzZXQiLCJjaGlsZE5vZGVzIiwidHlwZSIsImhhcyIsImNoaWxkIiwibGFzdCIsImluZGV4IiwidW5kZWZpbmVkIiwiJDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYiLCJwcm9wcyIsInNldEV4cGFuZGVkS2V5cyIsImRlZmF1bHRFeHBhbmRlZEtleXMiLCJvbkV4cGFuZGVkQ2hhbmdlIiwic2VsZWN0aW9uU3RhdGUiLCJkaXNhYmxlZEtleXMiLCJ0cmVlIiwiZm9jdXNlZEtleSIsInNldEZvY3VzZWRLZXkiLCJvblRvZ2dsZSIsIiQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkiLCJjb2xsZWN0aW9uIiwidG9nZ2xlS2V5Iiwic2VsZWN0aW9uTWFuYWdlciIsInJlcyIsImRlbGV0ZSIsImFkZCIsInVzZVRyZWVTdGF0ZSIsIlRyZWVDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNpZ24tZW5naW5lZXIvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzP2UzZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VTdGF0ZSBhcyAkNmltdWgkdXNlU3RhdGUsIHVzZVJlZiBhcyAkNmltdWgkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDZpbXVoJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJDZpbXVoJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1KHZhbHVlLCBkZWZhdWx0VmFsdWUsIG9uQ2hhbmdlKSB7XG4gICAgbGV0IFtzdGF0ZVZhbHVlLCBzZXRTdGF0ZVZhbHVlXSA9ICgwLCAkNmltdWgkdXNlU3RhdGUpKHZhbHVlIHx8IGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IGlzQ29udHJvbGxlZFJlZiA9ICgwLCAkNmltdWgkdXNlUmVmKSh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBsZXQgaXNDb250cm9sbGVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAoMCwgJDZpbXVoJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IHdhc0NvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHdhc0NvbnRyb2xsZWQgIT09IGlzQ29udHJvbGxlZCkgY29uc29sZS53YXJuKGBXQVJOOiBBIGNvbXBvbmVudCBjaGFuZ2VkIGZyb20gJHt3YXNDb250cm9sbGVkID8gXCJjb250cm9sbGVkXCIgOiBcInVuY29udHJvbGxlZFwifSB0byAke2lzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0uYCk7XG4gICAgICAgIGlzQ29udHJvbGxlZFJlZi5jdXJyZW50ID0gaXNDb250cm9sbGVkO1xuICAgIH0sIFtcbiAgICAgICAgaXNDb250cm9sbGVkXG4gICAgXSk7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGlzQ29udHJvbGxlZCA/IHZhbHVlIDogc3RhdGVWYWx1ZTtcbiAgICBsZXQgc2V0VmFsdWUgPSAoMCwgJDZpbXVoJHVzZUNhbGxiYWNrKSgodmFsdWUsIC4uLmFyZ3MpPT57XG4gICAgICAgIGxldCBvbkNoYW5nZUNhbGxlciA9ICh2YWx1ZSwgLi4ub25DaGFuZ2VBcmdzKT0+e1xuICAgICAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaXMoY3VycmVudFZhbHVlLCB2YWx1ZSkpIG9uQ2hhbmdlKHZhbHVlLCAuLi5vbkNoYW5nZUFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIC8vIElmIHVuY29udHJvbGxlZCwgbXV0YXRlIHRoZSBjdXJyZW50VmFsdWUgbG9jYWwgdmFyaWFibGUgc28gdGhhdFxuICAgICAgICAgICAgLy8gY2FsbGluZyBzZXRTdGF0ZSBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIHZhbHVlIG9ubHkgZW1pdHMgb25DaGFuZ2Ugb25jZS5cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSByZWYgZm9yIHRoaXMgYmVjYXVzZSB3ZSBzcGVjaWZpY2FsbHkgX2RvXyB3YW50IHRoZSB2YWx1ZSB0b1xuICAgICAgICAgICAgLy8gcmVzZXQgZXZlcnkgcmVuZGVyLCBhbmQgYXNzaWduaW5nIHRvIGEgcmVmIGluIHJlbmRlciBicmVha3MgYWJvcnRlZCBzdXNwZW5kZWQgcmVuZGVycy5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldlIGNhbiBub3Qgc3VwcG9ydCBhIGZ1bmN0aW9uIGNhbGxiYWNrLiBTZWUgR2l0aHViIElzc3VlcyBmb3IgZGV0YWlscyBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vaXNzdWVzLzIzMjBcIik7XG4gICAgICAgICAgICAvLyB0aGlzIHN1cHBvcnRzIGZ1bmN0aW9uYWwgdXBkYXRlcyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjZnVuY3Rpb25hbC11cGRhdGVzXG4gICAgICAgICAgICAvLyB3aGVuIHNvbWVvbmUgdXNpbmcgdXNlQ29udHJvbGxlZFN0YXRlIGNhbGxzIHNldENvbnRyb2xsZWRTdGF0ZShteUZ1bmMpXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY2FsbCBvdXIgdXNlU3RhdGUgc2V0U3RhdGUgd2l0aCBhIGZ1bmN0aW9uIGFzIHdlbGwgd2hpY2ggaW52b2tlcyBteUZ1bmMgYW5kIGNhbGxzIG9uQ2hhbmdlIHdpdGggdGhlIHZhbHVlIGZyb20gbXlGdW5jXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBhbiB1bmNvbnRyb2xsZWQgc3RhdGUsIHRoZW4gd2UgYWxzbyByZXR1cm4gdGhlIHZhbHVlIG9mIG15RnVuYyB3aGljaCB0byBzZXRTdGF0ZSBsb29rcyBhcyB0aG91Z2ggaXQgd2FzIGp1c3QgY2FsbGVkIHdpdGggbXlGdW5jIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBjb250cm9sbGVkIHZhbHVlLCB3aGljaCB3b24ndCBjYXVzZSBhIHJlcmVuZGVyIGJlY2F1c2UgUmVhY3Qga25vd3MgdG8gYmFpbCBvdXQgd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jdGlvbiA9IChvbGRWYWx1ZSwgLi4uZnVuY3Rpb25BcmdzKT0+e1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmNlcHRlZFZhbHVlID0gdmFsdWUoaXNDb250cm9sbGVkID8gY3VycmVudFZhbHVlIDogb2xkVmFsdWUsIC4uLmZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsZXIoaW50ZXJjZXB0ZWRWYWx1ZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWQpIHJldHVybiBpbnRlcmNlcHRlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRTdGF0ZVZhbHVlKHVwZGF0ZUZ1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSBzZXRTdGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGVyKHZhbHVlLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNDb250cm9sbGVkLFxuICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgIG9uQ2hhbmdlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICBzZXRWYWx1ZVxuICAgIF07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qKlxuICogVGFrZXMgYSB2YWx1ZSBhbmQgZm9yY2VzIGl0IHRvIHRoZSBjbG9zZXN0IG1pbi9tYXggaWYgaXQncyBvdXRzaWRlLiBBbHNvIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCB2YWxpZCBzdGVwLlxuICovIGZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0KHZhbHVlLCBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5KSB7XG4gICAgbGV0IG5ld1ZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjModmFsdWUsIG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgbWluID0gTnVtYmVyKG1pbik7XG4gICAgbWF4ID0gTnVtYmVyKG1heCk7XG4gICAgbGV0IHJlbWFpbmRlciA9ICh2YWx1ZSAtIChpc05hTihtaW4pID8gMCA6IG1pbikpICUgc3RlcDtcbiAgICBsZXQgc25hcHBlZFZhbHVlID0gTWF0aC5hYnMocmVtYWluZGVyKSAqIDIgPj0gc3RlcCA/IHZhbHVlICsgTWF0aC5zaWduKHJlbWFpbmRlcikgKiAoc3RlcCAtIE1hdGguYWJzKHJlbWFpbmRlcikpIDogdmFsdWUgLSByZW1haW5kZXI7XG4gICAgaWYgKCFpc05hTihtaW4pKSB7XG4gICAgICAgIGlmIChzbmFwcGVkVmFsdWUgPCBtaW4pIHNuYXBwZWRWYWx1ZSA9IG1pbjtcbiAgICAgICAgZWxzZSBpZiAoIWlzTmFOKG1heCkgJiYgc25hcHBlZFZhbHVlID4gbWF4KSBzbmFwcGVkVmFsdWUgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gc3RlcCkgKiBzdGVwO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1heCkgJiYgc25hcHBlZFZhbHVlID4gbWF4KSBzbmFwcGVkVmFsdWUgPSBNYXRoLmZsb29yKG1heCAvIHN0ZXApICogc3RlcDtcbiAgICAvLyBjb3JyZWN0IGZsb2F0aW5nIHBvaW50IGJlaGF2aW9yIGJ5IHJvdW5kaW5nIHRvIHN0ZXAgcHJlY2lzaW9uXG4gICAgbGV0IHN0cmluZyA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICBsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gICAgbGV0IHByZWNpc2lvbiA9IGluZGV4ID49IDAgPyBzdHJpbmcubGVuZ3RoIC0gaW5kZXggOiAwO1xuICAgIGlmIChwcmVjaXNpb24gPiAwKSB7XG4gICAgICAgIGxldCBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgc25hcHBlZFZhbHVlID0gTWF0aC5yb3VuZChzbmFwcGVkVmFsdWUgKiBwb3cpIC8gcG93O1xuICAgIH1cbiAgICByZXR1cm4gc25hcHBlZFZhbHVlO1xufVxuZnVuY3Rpb24gJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGI2MjY4NTU0ZmJhNDUxZih2YWx1ZSwgZGlnaXRzLCBiYXNlID0gMTApIHtcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdyhiYXNlLCBkaWdpdHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcG93KSAvIHBvdztcbn1cblxuXG5cblxuZXhwb3J0IHskNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSBhcyB1c2VDb250cm9sbGVkU3RhdGUsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0IGFzIGNsYW1wLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2MyBhcyBzbmFwVmFsdWVUb1N0ZXAsICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYgYXMgdG9GaXhlZE51bWJlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCIkNmltdWgkdXNlU3RhdGUiLCJ1c2VSZWYiLCIkNmltdWgkdXNlUmVmIiwidXNlRWZmZWN0IiwiJDZpbXVoJHVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiJDZpbXVoJHVzZUNhbGxiYWNrIiwiJDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUiLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwic3RhdGVWYWx1ZSIsInNldFN0YXRlVmFsdWUiLCJpc0NvbnRyb2xsZWRSZWYiLCJ1bmRlZmluZWQiLCJpc0NvbnRyb2xsZWQiLCJ3YXNDb250cm9sbGVkIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwiY3VycmVudFZhbHVlIiwic2V0VmFsdWUiLCJhcmdzIiwib25DaGFuZ2VDYWxsZXIiLCJvbkNoYW5nZUFyZ3MiLCJPYmplY3QiLCJpcyIsInVwZGF0ZUZ1bmN0aW9uIiwib2xkVmFsdWUiLCJmdW5jdGlvbkFyZ3MiLCJpbnRlcmNlcHRlZFZhbHVlIiwiJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JDdkMTViNjRjZjVhM2E0YzQiLCJtaW4iLCJJbmZpbml0eSIsIm1heCIsIm5ld1ZhbHVlIiwiTWF0aCIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzIiwic3RlcCIsIk51bWJlciIsInJlbWFpbmRlciIsImlzTmFOIiwic25hcHBlZFZhbHVlIiwiYWJzIiwic2lnbiIsImZsb29yIiwic3RyaW5nIiwidG9TdHJpbmciLCJpbmRleCIsImluZGV4T2YiLCJwcmVjaXNpb24iLCJsZW5ndGgiLCJwb3ciLCJyb3VuZCIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYiLCJkaWdpdHMiLCJiYXNlIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiY2xhbXAiLCJzbmFwVmFsdWVUb1N0ZXAiLCJ0b0ZpeGVkTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTtBQUU1RTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLE1BQU1VO0lBQ047Ozs7O0dBS0QsR0FBR0MsaUJBQWlCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNqQywrQ0FBK0M7UUFDL0MsT0FBT0QsUUFBUUUsS0FBSyxLQUFLRCxRQUFRQyxLQUFLLElBQUlGLFFBQVFHLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUMvRTtJQUNBOzs7OztHQUtELEdBQUdDLFNBQVNDLG1CQUFtQixFQUFFLENBQUM7SUFDakM7Ozs7R0FJRCxHQUFHLG1EQUFtRDtJQUNyRCxxREFBcUQ7SUFDckQsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04sYUFBYTtJQUNiLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFDbEIsT0FBTztJQUNQLElBQUk7SUFDSjs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELGlCQUFpQjtJQUNqQixJQUFJO0lBQ0o7Ozs7OztHQU1ELEdBQUdDLHFCQUFxQkMsVUFBVSxFQUFFO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0dBTUQsR0FBR0MsbUJBQW1CRCxVQUFVLEVBQUU7UUFDN0IsT0FBT0E7SUFDWDtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLE1BQU1FO0lBQ047O0dBRUQsR0FBR0MsT0FBTztRQUNMLElBQUlDLE1BQU0sSUFBSUYsMENBQTBDLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSixJQUFJO1FBQzNGQyxJQUFJSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3RDSixJQUFJSyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBQzFCTCxJQUFJTSxTQUFT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LDhDQUFpQixFQUFHLENBQUNtQjtRQUMxQzBDLFlBQVlrRSxXQUFXLEdBQUc1RztJQUM5QixHQUFHO1FBQ0MwQztLQUNIO0lBQ0QsSUFBSXVPLGlCQUFpQixDQUFDLEdBQUdwUyw4Q0FBaUIsRUFBRztRQUN6QzZELFlBQVl1TyxjQUFjO1FBQzFCNkIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXdPLGVBQWUsQ0FBQyxHQUFHclMsOENBQWlCLEVBQUc7UUFDdkM2RCxZQUFZd08sWUFBWTtRQUN4QjRCLGFBQWE7SUFDakIsR0FBRztRQUNDcFE7S0FDSDtJQUNELElBQUlzUSxRQUFRLENBQUMsR0FBR3ZVLDBDQUFhLEVBQUcsSUFBSztZQUM3QmlFLGFBQWFBO1lBQ2JnSixjQUFjQTtZQUNkbEYsZ0JBQWdCQTtZQUNoQmlDLGFBQWFBO1lBQ2JrSyxhQUFhQTtZQUNiRSxhQUFhQTtZQUNiNUIsZ0JBQWdCQTtZQUNoQkMsY0FBY0E7UUFDbEIsSUFBSTtRQUNKeE87UUFDQWdKO1FBQ0FsRjtRQUNBaUM7UUFDQWtLO1FBQ0FFO1FBQ0E1QjtRQUNBQztLQUNIO0lBQ0QsT0FBTzhCO0FBQ1g7QUFLNFksQ0FDNVksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVzaWduLWVuZ2luZWVyLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3ZpcnR1YWxpemVyL2Rpc3QvaW1wb3J0Lm1qcz9lOWExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3RhdGUgYXMgJDhEM25yJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ4RDNuciR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJDhEM25yJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJDhEM25yJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlTGF5b3V0RWZmZWN0IGFzICQ4RDNuciR1c2VMYXlvdXRFZmZlY3R9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2Ege1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgaW52YWxpZGF0ZSBpbiByZXNwb25zZSB0b1xuICAgKiB2aXNpYmxlIHJlY3RhbmdsZSBjaGFuZ2VzLiBCeSBkZWZhdWx0LCBpdCBvbmx5IGludmFsaWRhdGVzXG4gICAqIHdoZW4gdGhlIGNvbGxlY3Rpb24gdmlldydzIHNpemUgY2hhbmdlcy4gUmV0dXJuIHRydWUgYWx3YXlzXG4gICAqIHRvIG1ha2UgdGhlIGxheW91dCBpbnZhbGlkYXRlIHdoaWxlIHNjcm9sbGluZyAoZS5nLiBzdGlja3kgaGVhZGVycykuXG4gICAqLyBzaG91bGRJbnZhbGlkYXRlKG5ld1JlY3QsIG9sZFJlY3QpIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgaW52YWxpZGF0ZSB3aGVuIHRoZSBzaXplIGNoYW5nZXNcbiAgICAgICAgcmV0dXJuIG5ld1JlY3Qud2lkdGggIT09IG9sZFJlY3Qud2lkdGggfHwgbmV3UmVjdC5oZWlnaHQgIT09IG9sZFJlY3QuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHRoZSBsYXlvdXQgdG8gcGVyZm9ybSBhbnkgcHJlLWNvbXB1dGF0aW9uXG4gICAqIGl0IG5lZWRzIHRvIGluIG9yZGVyIHRvIHByZXBhcmUge0BsaW5rIExheW91dEluZm99cyBmb3IgcmV0cmlldmFsLlxuICAgKiBDYWxsZWQgYnkgdGhlIGNvbGxlY3Rpb24gdmlldyBiZWZvcmUge0BsaW5rIGdldFZpc2libGVMYXlvdXRJbmZvc31cbiAgICogb3Ige0BsaW5rIGdldExheW91dEluZm99IGFyZSBjYWxsZWQuXG4gICAqLyB2YWxpZGF0ZShpbnZhbGlkYXRpb25Db250ZXh0KSB7fVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIERyYWdUYXJnZXR9IGRlc2NyaWJpbmcgYSB2aWV3IGF0IHRoZSBnaXZlbiBwb2ludCB0byBiZSBkcmFnZ2VkLlxuICAgKiBSZXR1cm4gYG51bGxgIHRvIGNhbmNlbCB0aGUgZHJhZy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGRyYWcgb2NjdXJyZWQuXG4gICAqLyAvLyBnZXREcmFnVGFyZ2V0KHBvaW50OiBQb2ludCk6IERyYWdUYXJnZXQgfCBudWxsIHtcbiAgICAvLyAgIGxldCB0YXJnZXQgPSB0aGlzLnZpcnR1YWxpemVyLmtleUF0UG9pbnQocG9pbnQpO1xuICAgIC8vICAgaWYgKCF0YXJnZXQpIHtcbiAgICAvLyAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4ge1xuICAgIC8vICAgICB0eXBlOiAnaXRlbScsXG4gICAgLy8gICAgIGtleTogdGFyZ2V0XG4gICAgLy8gICB9O1xuICAgIC8vIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBvYmplY3QgZGVzY3JpYmluZyB3aGVyZSBhIGRyb3Agc2hvdWxkIG9jY3VyLiBSZXR1cm4gYG51bGxgXG4gICAqIHRvIHJlamVjdCB0aGUgZHJvcC4gVGhlIGRyb3BwZWQgaXRlbXMgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIHJlc3VsdGluZyB0YXJnZXQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGRyb3Agb2NjdXJyZWQuXG4gICAqLyAvLyBnZXREcm9wVGFyZ2V0KHBvaW50OiBQb2ludCk6IERyb3BUYXJnZXQgfCBudWxsIHtcbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgaW5zZXJ0aW9uLlxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoaXMge0BsaW5rIExheW91dEluZm99IHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99LlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgaXRzIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgcHJvcG9zZWQgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxuICAgKi8gZ2V0SW5pdGlhbExheW91dEluZm8obGF5b3V0SW5mbykge1xuICAgICAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZGluZyBhdHRyaWJ1dGVzIGZvciBhbiBhbmltYXRlZCByZW1vdmFsLlxuICAgKiBUaGUgdmlldyBpcyBhbmltYXRlZCBmcm9tIHRoZSB7QGxpbmsgTGF5b3V0SW5mb30gcmV0dXJuZWQgYnkge0BsaW5rIGdldExheW91dEluZm99XG4gICAqIHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgaXRzIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gbGF5b3V0SW5mbyBUaGUgb3JpZ2luYWwgTGF5b3V0SW5mbyBmb3IgdGhpcyB2aWV3LlxuICAgKi8gZ2V0RmluYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBMYXlvdXRJbmZvLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSh0aGlzLnR5cGUsIHRoaXMua2V5LCB0aGlzLnJlY3QuY29weSgpKTtcbiAgICAgICAgcmVzLmVzdGltYXRlZFNpemUgPSB0aGlzLmVzdGltYXRlZFNpemU7XG4gICAgICAgIHJlcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICByZXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHJlcy5wYXJlbnRLZXkgPSB0aGlzLnBhcmVudEtleTtcbiAgICAgICAgcmVzLmlzU3RpY2t5ID0gdGhpcy5pc1N0aWNreTtcbiAgICAgICAgcmVzLnpJbmRleCA9IHRoaXMuekluZGV4O1xuICAgICAgICByZXMuYWxsb3dPdmVyZmxvdyA9IHRoaXMuYWxsb3dPdmVyZmxvdztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmlldyB0eXBlLiBTaG91bGQgYmUgYCdpdGVtJ2AgZm9yIGl0ZW0gdmlld3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3RoZXIgdHlwZXMgYXJlIHVzZWQgYnkgc3VwcGxlbWVudGFyeSB2aWV3cy5cbiAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleSBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoaXMgdmlldy5cbiAgICovIGNvbnN0cnVjdG9yKHR5cGUsIGtleSwgcmVjdCl7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBhcmVudEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjdCA9IHJlY3Q7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RpY2t5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy56SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFsbG93T3ZlcmZsb3cgPSBmYWxzZTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb2ludC5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsLlxuICAgKi8gZXF1YWxzKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgdGhlIG9yaWdpbi5cbiAgICovIGlzT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY2xhc3MgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2Qge1xuICAgIC8qKlxuICAgKiBUaGUgbWF4aW11bSB4LWNvb3JkaW5hdGUgaW4gdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBtYXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHktY29vcmRpbmF0ZSBpbiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IG1heFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBhcmVhIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCB0b3BMZWZ0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCB0b3BSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMubWF4WCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBib3R0b21MZWZ0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkodGhpcy54LCB0aGlzLm1heFkpO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBib3R0b21SaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMubWF4WCwgdGhpcy5tYXhZKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHJlY3RhbmdsZSBpbnRlcnNlY3RzIGFub3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBpbnRlcnNlY3RzKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCAmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgZnVsbHkgY29udGFpbnMgYW5vdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGNvbnRhaW5zUmVjdChyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICYmIHRoaXMueSA8PSByZWN0LnkgJiYgdGhpcy5tYXhYID49IHJlY3QubWF4WCAmJiB0aGlzLm1heFkgPj0gcmVjdC5tYXhZO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2hlY2suXG4gICAqLyBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcG9pbnQueCAmJiB0aGlzLnkgPD0gcG9pbnQueSAmJiB0aGlzLm1heFggPj0gcG9pbnQueCAmJiB0aGlzLm1heFkgPj0gcG9pbnQueTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGNvcm5lciBvZiB0aGlzIHJlY3RhbmdsZSAoZnJvbSB0b3AgdG8gYm90dG9tLCBsZWZ0IHRvIHJpZ2h0KVxuICAgKiB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLCBvciBudWxsIG9mIHRoZSByZWN0YW5nbGVzIGRvIG5vdCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBjaGVjay5cbiAgICovIGdldENvcm5lckluUmVjdChyZWN0KSB7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXG4gICAgICAgICAgICBcInRvcExlZnRcIixcbiAgICAgICAgICAgIFwidG9wUmlnaHRcIixcbiAgICAgICAgICAgIFwiYm90dG9tTGVmdFwiLFxuICAgICAgICAgICAgXCJib3R0b21SaWdodFwiXG4gICAgICAgIF0pe1xuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbnNQb2ludCh0aGlzW2tleV0pKSByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlcXVhbHMocmVjdCkge1xuICAgICAgICByZXR1cm4gcmVjdC54ID09PSB0aGlzLnggJiYgcmVjdC55ID09PSB0aGlzLnkgJiYgcmVjdC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiByZWN0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIHBvaW50RXF1YWxzKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55O1xuICAgIH1cbiAgICBzaXplRXF1YWxzKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IHNpemUud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5pb24gb2YgdGhpcyBSZWN0IGFuZCBhbm90aGVyLlxuICAgKi8gdW5pb24ob3RoZXIpIHtcbiAgICAgICAgbGV0IHggPSBNYXRoLm1pbih0aGlzLngsIG90aGVyLngpO1xuICAgICAgICBsZXQgeSA9IE1hdGgubWluKHRoaXMueSwgb3RoZXIueSk7XG4gICAgICAgIGxldCB3aWR0aCA9IE1hdGgubWF4KHRoaXMubWF4WCwgb3RoZXIubWF4WCkgLSB4O1xuICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5tYXhZLCBvdGhlci5tYXhZKSAtIHk7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBSZWN0IHdpdGggYW5vdGhlci5cbiAgICogSWYgdGhlIHJlY3RhbmdsZXMgZG8gbm90IGludGVyc2VjdCwgYW4gYWxsIHplcm8gUmVjdCBpcyByZXR1cm5lZC5cbiAgICovIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvdGhlcikpIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QoMCwgMCwgMCwgMCk7XG4gICAgICAgIGxldCB4ID0gTWF0aC5tYXgodGhpcy54LCBvdGhlci54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLm1heCh0aGlzLnksIG90aGVyLnkpO1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIE1hdGgubWluKHRoaXMubWF4WCwgb3RoZXIubWF4WCkgLSB4LCBNYXRoLm1pbih0aGlzLm1heFksIG90aGVyLm1heFkpIC0geSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJlY3RhbmdsZS5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHNpemUuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHNpemUgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gICAqLyBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG90YWwgYXJlYSBvZiB0aGUgU2l6ZS5cbiAgICovIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApe1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRhZDFkOThhYThmMGMzMWI0JHZhciRLRVkgPSAwO1xuY2xhc3MgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEge1xuICAgIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgdmlldyBmb3IgcmV1c2UuIENhbGxlZCBqdXN0IGJlZm9yZSB0aGUgdmlldyBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICovIHByZXBhcmVGb3JSZXVzZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF5b3V0SW5mbyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpcnR1YWxpemVyKXtcbiAgICAgICAgdGhpcy52aXJ0dWFsaXplciA9IHZpcnR1YWxpemVyO1xuICAgICAgICB0aGlzLmtleSA9ICsrJGFkMWQ5OGFhOGYwYzMxYjQkdmFyJEtFWTtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vLyB1c2UgaGlnaCByZXMgdGltZXIgaWYgYXZhaWxhYmxlXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcbi8vIEB0cy1pZ25vcmVcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmICYmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5ub3cgfHwgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYud2Via2l0Tm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm1zTm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLm1vek5vdyk7XG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyA/ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93LmJpbmQoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYpIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcbmxldCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHM7XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyhiZWdpbiwgZW5kLCBkdXJhdGlvbiwgZWFzZSwgZm4pIHtcbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBsZXQgcmFmX2lkO1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGxldCBzdGFydCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XG4gICAgICAgIGxldCBkaWZmWCA9IGVuZC54IC0gYmVnaW4ueDtcbiAgICAgICAgbGV0IGRpZmZZID0gZW5kLnkgLSBiZWdpbi55O1xuICAgICAgICByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gcnVuKHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHVzaW5nIGEgaGlnaCByZXMgdGltZXIsIG1ha2Ugc3VyZSB0aW1lc3RhbXAgaXMgbm90IHRoZSBvbGQgZXBvY2gtYmFzZWQgdmFsdWUuXG4gICAgICAgICAgICAvLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA1L3JlcXVlc3RBbmltYXRpb25GcmFtZS1BUEktbm93LXdpdGgtc3ViLW1pbGxpc2Vjb25kLXByZWNpc2lvblxuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyA9PSBudWxsKSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMgPSB0ID4gMWUxMiAhPT0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKSA+IDFlMTI7XG4gICAgICAgICAgICBpZiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzKSB0ID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IHQgLSBzdGFydDtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm4oZW5kKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZnJhbWUgY2FsbGJhY2sgYWZ0ZXIgY29tcHV0aW5nIGVhc2VkIHRpbWUgYW5kIGdldCB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAgICAgICAgIGxldCBwcm9jZWVkID0gZm4obmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoYmVnaW4ueCArIGRpZmZYICogZWFzZShkZWx0YSAvIGR1cmF0aW9uKSwgYmVnaW4ueSArIGRpZmZZICogZWFzZShkZWx0YSAvIGR1cmF0aW9uKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZWVkICE9PSBmYWxzZSAmJiAhY2FuY2VsZWQpIHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZl9pZCk7XG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlKHQpIHtcbiAgICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ1NzYzNmJiNDNiMWNjYmIwKHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4odCAqIE1hdGguUEkgLyAyKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYikge1xuICAgIGxldCByZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQga2V5IG9mIGEua2V5cygpKWlmICghYi5oYXMoa2V5KSkgcmVzLmFkZChrZXkpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YihhLCBiKSB7XG4gICAgbGV0IHRvUmVtb3ZlID0gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYSwgYik7XG4gICAgbGV0IHRvQWRkID0gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUoYiwgYSk7XG4gICAgbGV0IHRvVXBkYXRlID0gbmV3IFNldDtcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKCkpaWYgKGIuaGFzKGtleSkpIHRvVXBkYXRlLmFkZChrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvUmVtb3ZlOiB0b1JlbW92ZSxcbiAgICAgICAgdG9BZGQ6IHRvQWRkLFxuICAgICAgICB0b1VwZGF0ZTogdG9VcGRhdGVcbiAgICB9O1xufVxuZnVuY3Rpb24qICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRjZmMxNDA4OGRmZWZjZTVmKC4uLml0ZXJhdG9ycykge1xuICAgIGZvciAobGV0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycyl5aWVsZCogaXRlcmF0b3I7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkNjg5N2MyODRiNmY5ZjRkYyhvYmplY3QpIHtcbiAgICBsZXQgcmVzID0ge307XG4gICAgZm9yKGxldCBrZXkgaW4gb2JqZWN0KXJlc1tvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGEpe1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2Uge1xuICAgIGFkZFNhbXBsZShzYW1wbGUpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB0aGlzLnZhbHVlICs9IChzYW1wbGUgLSB0aGlzLnZhbHVlKSAvIHRoaXMuY291bnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB9XG59XG5jbGFzcyAkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYiB7XG4gICAgc2V0VmlzaWJsZVJlY3QocmVjdCkge1xuICAgICAgICBsZXQgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lIDwgNTAwKSB7XG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2VUaW1lLmFkZFNhbXBsZSh0aW1lKTtcbiAgICAgICAgICAgIGlmIChyZWN0LnggIT09IHRoaXMudmlzaWJsZVJlY3QueCAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS54ID0gKHJlY3QueCAtIHRoaXMudmlzaWJsZVJlY3QueCkgLyB0aW1lO1xuICAgICAgICAgICAgaWYgKHJlY3QueSAhPT0gdGhpcy52aXNpYmxlUmVjdC55ICYmIHRpbWUgPiAwKSB0aGlzLnZlbG9jaXR5LnkgPSAocmVjdC55IC0gdGhpcy52aXNpYmxlUmVjdC55KSAvIHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgfVxuICAgIGNvbGxlY3RNZXRyaWNzKCkge1xuICAgICAgICBsZXQgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lIDwgNTAwKSB0aGlzLmF2ZXJhZ2VQZXJmLmFkZFNhbXBsZSh0aW1lKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG8gPSBNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnkgKiAodGhpcy5hdmVyYWdlVGltZS52YWx1ZSArIHRoaXMuYXZlcmFnZVBlcmYudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcnNjYW5ZLmFkZFNhbXBsZShvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXNpYmxlUmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS54ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJzY2FuWC5hZGRTYW1wbGUobyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3ZlcnNjYW5uZWRSZWN0KCkge1xuICAgICAgICBsZXQgb3ZlcnNjYW5uZWQgPSB0aGlzLnZpc2libGVSZWN0LmNvcHkoKTtcbiAgICAgICAgbGV0IG92ZXJzY2FuWSA9IE1hdGgucm91bmQoTWF0aC5taW4odGhpcy52aXNpYmxlUmVjdC5oZWlnaHQgKiAyLCB0aGlzLm92ZXJzY2FuWS52YWx1ZSkgLyAxMDApICogMTAwO1xuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eS55ID4gMCkge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueSAtPSBvdmVyc2NhblkgKiAwLjI7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueSAtPSBvdmVyc2Nhblk7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC5oZWlnaHQgKz0gb3ZlcnNjYW5ZICsgb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyc2NhblggPSBNYXRoLnJvdW5kKE1hdGgubWluKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggKiAyLCB0aGlzLm92ZXJzY2FuWC52YWx1ZSkgLyAxMDApICogMTAwO1xuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eS54ID4gMCkge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueCAtPSBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC54IC09IG92ZXJzY2FuWDtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLndpZHRoICs9IG92ZXJzY2FuWCArIG92ZXJzY2FuWCAqIDAuMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcnNjYW5uZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5hdmVyYWdlUGVyZiA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy5hdmVyYWdlVGltZSA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDUsIDUpO1xuICAgICAgICB0aGlzLm92ZXJzY2FuWCA9IG5ldyAkMzY0MTkxYjNkZWNmMzY5NyR2YXIkUm9sbGluZ0F2ZXJhZ2UoKTtcbiAgICAgICAgdGhpcy5vdmVyc2NhblkgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSgpO1xuICAgIH1cbn1cblxuXG5cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbml0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxMYXlvdXRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZpbmFsTGF5b3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRvUmVtb3ZlID0gbmV3IE1hcCgpO1xuICAgIH1cbn1cblxuXG5jbGFzcyAkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMiB7XG4gICAgX3NldENvbnRlbnRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudFNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldENvbnRlbnRTaXplKHNpemUpO1xuICAgIH1cbiAgICBfc2V0Q29udGVudE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKShvZmZzZXQueCwgb2Zmc2V0LnksIHRoaXMuX3Zpc2libGVSZWN0LndpZHRoLCB0aGlzLl92aXNpYmxlUmVjdC5oZWlnaHQpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZpc2libGVSZWN0KHJlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnQuXG4gICAqLyBnZXQgY29udGVudFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgY3VycmVudGx5IHZpc2libGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IHZpc2libGVSZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cbiAgICovIHNldCB2aXNpYmxlUmVjdChyZWN0KSB7XG4gICAgICAgIHRoaXMuX3NldFZpc2libGVSZWN0KHJlY3QpO1xuICAgIH1cbiAgICBfc2V0VmlzaWJsZVJlY3QocmVjdCwgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX3Zpc2libGVSZWN0O1xuICAgICAgICAvLyBJZ25vcmUgaWYgdGhlIHJlY3RzIGFyZSBlcXVhbFxuICAgICAgICBpZiAocmVjdC5lcXVhbHMoY3VycmVudCkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICAgICAgbGV0IHNob3VsZEludmFsaWRhdGUgPSB0aGlzLmxheW91dCAmJiB0aGlzLmxheW91dC5zaG91bGRJbnZhbGlkYXRlKHJlY3QsIHRoaXMuX3Zpc2libGVSZWN0KTtcbiAgICAgICAgdGhpcy5fcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJlY3QgPSByZWN0O1xuICAgICAgICBpZiAoc2hvdWxkSW52YWxpZGF0ZSkgLy8gV2UgYXJlIGFscmVhZHkgaW4gYSBsYXlvdXQgZWZmZWN0IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBzbyByZWxheW91dE5vdyBpcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgdGhpcy5yZWxheW91dE5vdyh7XG4gICAgICAgICAgICBvZmZzZXRDaGFuZ2VkOiAhcmVjdC5wb2ludEVxdWFscyhjdXJyZW50KSxcbiAgICAgICAgICAgIHNpemVDaGFuZ2VkOiAhcmVjdC5zaXplRXF1YWxzKGN1cnJlbnQpXG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIHRoaXMudXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUpO1xuICAgIH1cbiAgICBnZXQgY29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBjb2xsZWN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0RGF0YShkYXRhKTtcbiAgICB9XG4gICAgX3NldERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdGhpcy5fY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbikgdGhpcy5fcnVuVHJhbnNhY3Rpb24oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9LCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA+IDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZWxvYWREYXRhKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFJlbG9hZHMgdGhlIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UgYW5kIHJlbGF5b3V0cyB0aGUgY29sbGVjdGlvbiB2aWV3LlxuICAgKiBEb2VzIG5vdCBhbmltYXRlIGFueSBjaGFuZ2VzLiBFcXVpdmFsZW50IHRvIHJlLWFzc2lnbmluZyB0aGUgc2FtZSBkYXRhIHNvdXJjZVxuICAgKiB0byB0aGUgY29sbGVjdGlvbiB2aWV3LlxuICAgKi8gcmVsb2FkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5yZWxheW91dCh7XG4gICAgICAgICAgICBjb250ZW50Q2hhbmdlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24gPyB0aGlzLl9jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSA6IG51bGw7XG4gICAgfVxuICAgIC8qKiBUaGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzIGFyZSBhbHdheXMgcHJlc2VudCBpbiB0aGUgRE9NLCBldmVuIGlmIG5vdCBjdXJyZW50bHkgaW4gdmlldy4gKi8gZ2V0IHBlcnNpc3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJzaXN0ZWRLZXlzO1xuICAgIH1cbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIHNldCBwZXJzaXN0ZWRLZXlzKHBlcnNpc3RlZEtleXMpIHtcbiAgICAgICAgaWYgKCEoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGE4ZDBkMGM4ZDFjNWRmNjQpKHBlcnNpc3RlZEtleXMsIHRoaXMuX3BlcnNpc3RlZEtleXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJzaXN0ZWRLZXlzID0gcGVyc2lzdGVkS2V5cztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3Vidmlld3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBrZXksIG9yIGFuIGFuY2VzdG9yLCBpcyBwZXJzaXN0ZWQuICovIGlzUGVyc2lzdGVkS2V5KGtleSkge1xuICAgICAgICAvLyBRdWljayBjaGVjayBpZiB0aGUga2V5IGlzIGRpcmVjdGx5IGluIHRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMuXG4gICAgICAgIGlmICh0aGlzLl9wZXJzaXN0ZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSWYgbm90LCBjaGVjayBpZiB0aGUga2V5IGlzIGFuIGFuY2VzdG9yIG9mIGFueSBvZiB0aGUgcGVyc2lzdGVkIGtleXMuXG4gICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5fcGVyc2lzdGVkS2V5cyl3aGlsZShrICE9IG51bGwpe1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGspO1xuICAgICAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSBicmVhaztcbiAgICAgICAgICAgIGsgPSBsYXlvdXRJbmZvLnBhcmVudEtleTtcbiAgICAgICAgICAgIGlmIChrID09PSBrZXkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LlxuICAgKi8gZ2V0IGxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldCB0aGUgY29sbGVjdGlvbiB2aWV3J3MgbGF5b3V0LlxuICAgKi8gc2V0IGxheW91dChsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dCwgb3B0aW9uYWxseSB3aXRoIGFuIGFuaW1hdGVkIHRyYW5zaXRpb25cbiAgICogZnJvbSB0aGUgY3VycmVudCBsYXlvdXQgdG8gdGhlIG5ldyBsYXlvdXQuXG4gICAqIEBwYXJhbSBsYXlvdXQgVGhlIGxheW91dCB0byBzd2l0Y2ggdG8uXG4gICAqIEBwYXJhbSBhbmltYXRlZCBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIGxheW91dCBjaGFuZ2UuXG4gICAqLyBzZXRMYXlvdXQobGF5b3V0LCBhbmltYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChsYXlvdXQgPT09IHRoaXMuX2xheW91dCkgcmV0dXJuO1xuICAgICAgICBsZXQgYXBwbHlMYXlvdXQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xheW91dCkgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnZpcnR1YWxpemVyID0gbnVsbDtcbiAgICAgICAgICAgIGxheW91dC52aXJ0dWFsaXplciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhbmltYXRlZCkgLy8gQW5pbWF0ZWQgbGF5b3V0IHRyYW5zaXRpb25zIGFyZSByZWFsbHkgc2ltcGxlLCB0aGFua3MgdG8gb3VyIHRyYW5zYWN0aW9uIHN1cHBvcnQuXG4gICAgICAgIC8vIFdlIGp1c3Qgc2V0IHRoZSBsYXlvdXQgaW5zaWRlIGEgdHJhbnNhY3Rpb24gYWN0aW9uLCB3aGljaCBydW5zIGFmdGVyIHRoZSBpbml0aWFsXG4gICAgICAgIC8vIGxheW91dCBpbmZvcyBmb3IgdGhlIGFuaW1hdGlvbiBhcmUgcmV0cmlldmVkIGZyb20gdGhlIHByZXZpb3VzIGxheW91dC4gVGhlbiwgdGhlXG4gICAgICAgIC8vIGZpbmFsIGxheW91dCBpbmZvcyBhcmUgcmV0cmlldmVkIGZyb20gdGhlIG5ldyBsYXlvdXQsIGFuZCBhbmltYXRpb25zIG9jY3VyLlxuICAgICAgICB0aGlzLl9ydW5UcmFuc2FjdGlvbihhcHBseUxheW91dCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlMYXlvdXQoKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0UmV1c2VUeXBlKGxheW91dEluZm8sIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGxheW91dEluZm8udHlwZSA9PT0gXCJpdGVtXCIgJiYgY29udGVudCkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLmRlbGVnYXRlLmdldFR5cGUgPyB0aGlzLmRlbGVnYXRlLmdldFR5cGUoY29udGVudCkgOiBcIml0ZW1cIjtcbiAgICAgICAgICAgIGxldCByZXVzZVR5cGUgPSB0eXBlID09PSBcIml0ZW1cIiA/IFwiaXRlbVwiIDogbGF5b3V0SW5mby50eXBlICsgXCJfXCIgKyB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHJldXNlVHlwZTogcmV1c2VUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBsYXlvdXRJbmZvLnR5cGUsXG4gICAgICAgICAgICByZXVzZVR5cGU6IGxheW91dEluZm8udHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZXVzYWJsZVZpZXcobGF5b3V0SW5mbykge1xuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuZ2V0SXRlbShsYXlvdXRJbmZvLmtleSk7XG4gICAgICAgIGxldCB7IHJldXNlVHlwZTogcmV1c2VUeXBlIH0gPSB0aGlzLl9nZXRSZXVzZVR5cGUobGF5b3V0SW5mbywgY29udGVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdKSB0aGlzLl9yZXVzYWJsZVZpZXdzW3JldXNlVHlwZV0gPSBbXTtcbiAgICAgICAgbGV0IHJldXNhYmxlID0gdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdO1xuICAgICAgICBsZXQgdmlldyA9IHJldXNhYmxlLmxlbmd0aCA+IDAgPyByZXVzYWJsZS5wb3AoKSA6IG5ldyAoMCwgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEpKHRoaXMpO1xuICAgICAgICB2aWV3LnZpZXdUeXBlID0gcmV1c2VUeXBlO1xuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC5pc09yaWdpbigpKSB7XG4gICAgICAgICAgICBsYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueCArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueDtcbiAgICAgICAgICAgIGxheW91dEluZm8ucmVjdC55ICs9IHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC55O1xuICAgICAgICB9XG4gICAgICAgIHZpZXcubGF5b3V0SW5mbyA9IGxheW91dEluZm87XG4gICAgICAgIHRoaXMuX3JlbmRlclZpZXcodmlldyk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBfcmVuZGVyVmlldyhyZXVzYWJsZVZpZXcpIHtcbiAgICAgICAgbGV0IHsgdHlwZTogdHlwZSwga2V5OiBrZXkgfSA9IHJldXNhYmxlVmlldy5sYXlvdXRJbmZvO1xuICAgICAgICByZXVzYWJsZVZpZXcuY29udGVudCA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICByZXVzYWJsZVZpZXcucmVuZGVyZWQgPSB0aGlzLl9yZW5kZXJDb250ZW50KHR5cGUsIHJldXNhYmxlVmlldy5jb250ZW50KTtcbiAgICB9XG4gICAgX3JlbmRlckNvbnRlbnQodHlwZSwgY29udGVudCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcmVuZGVyZWRDb250ZW50LmdldChjb250ZW50KTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPSBudWxsKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgcmVuZGVyZWQgPSB0aGlzLmRlbGVnYXRlLnJlbmRlclZpZXcodHlwZSwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50KSB0aGlzLl9yZW5kZXJlZENvbnRlbnQuc2V0KGNvbnRlbnQsIHJlbmRlcmVkKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgY3VycmVudGx5IHZpc2libGUgdmlld3MsIGluY2x1ZGluZyBib3RoXG4gICAqIGl0ZW0gdmlld3MgYW5kIHN1cHBsZW1lbnRhcnkgdmlld3MuXG4gICAqLyBnZXQgdmlzaWJsZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl92aXNpYmxlVmlld3MudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICogR2V0cyB0aGUgdmlzaWJsZSB2aWV3IGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQga2V5LiBSZXR1cm5zIG51bGwgaWZcbiAgICogdGhlIHZpZXcgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHZpZXcgdG8gcmV0cmlldmUuXG4gICAqLyBnZXRWaWV3KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHZpc2libGUgdmlld3MgbWF0Y2hpbmcgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB2aWV3IHR5cGUgdG8gZmluZC5cbiAgICovIGdldFZpZXdzT2ZUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVZpZXdzLmZpbHRlcigodik9PnYubGF5b3V0SW5mbyAmJiB2LmxheW91dEluZm8udHlwZSA9PT0gdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBnaXZlbiB2aWV3LiBSZXR1cm5zIG51bGxcbiAgICogaWYgdGhlIHZpZXcgaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKi8ga2V5Rm9yVmlldyh2aWV3KSB7XG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXcubGF5b3V0SW5mbykgcmV0dXJuIHZpZXcubGF5b3V0SW5mby5rZXk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgaXRlbSB2aWV3IGN1cnJlbnRseSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAqLyBrZXlBdFBvaW50KHBvaW50KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkocG9pbnQueCwgcG9pbnQueSwgMSwgMSk7XG4gICAgICAgIGxldCBsYXlvdXRJbmZvcyA9IHRoaXMubGF5b3V0LmdldFZpc2libGVMYXlvdXRJbmZvcyhyZWN0KTtcbiAgICAgICAgLy8gTGF5b3V0IG1heSByZXR1cm4gbXVsdGlwbGUgbGF5b3V0IGluZm9zIGluIHRoZSBjYXNlIG9mXG4gICAgICAgIC8vIHBlcnNpc3RlZCBrZXlzLCBzbyBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBhY3R1YWxseSBpbnRlcnNlY3RzLlxuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKXtcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvLnJlY3QuaW50ZXJzZWN0cyhyZWN0KSkgcmV0dXJuIGxheW91dEluZm8ua2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2xlYW51cCBmb3Igd2hlbiB0aGUgVmlydHVhbGl6ZXIgd2lsbCBiZSB1bm1vdW50ZWQuXG4gICAqLyB3aWxsVW5tb3VudCgpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xuICAgIH1cbiAgICAvKipcbiAgICogVHJpZ2dlcnMgYSBsYXlvdXQgaW52YWxpZGF0aW9uLCBhbmQgdXBkYXRlcyB0aGUgdmlzaWJsZSBzdWJ2aWV3cy5cbiAgICovIHJlbGF5b3V0KGNvbnRleHQgPSB7fSkge1xuICAgICAgICAvLyBJZ25vcmUgcmVsYXlvdXRzIHdoaWxlIGFuaW1hdGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24gfHwgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBhIHJlbGF5b3V0LCBleHRlbmQgdGhlIGludmFsaWRhdGlvblxuICAgICAgICAvLyBjb250ZXh0IHNvIHdlIGNvYWxlc2NlIG11bHRpcGxlIHJlbGF5b3V0cyBpbiB0aGUgc2FtZSBmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIHJlbGF5b3V0IGltbWVkaWF0ZWx5LiBQcmVmZXIge0BsaW5rIHJlbGF5b3V0fSBvdmVyIHRoaXMgbWV0aG9kXG4gICAqIHdoZXJlIHBvc3NpYmxlLCBzaW5jZSBpdCBjb2FsZXNjZXMgbXVsdGlwbGUgbGF5b3V0IHBhc3NlcyBpbiB0aGUgc2FtZSB0aWNrLlxuICAgKi8gcmVsYXlvdXROb3coY29udGV4dCA9IHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgfHwge30pIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBzY2hlZHVsZWQgcmVsYXlvdXQsIHNpbmNlIHdlJ3JlIGRvaW5nIGl0IG5vdy5cbiAgICAgICAgaWYgKHRoaXMuX3JlbGF5b3V0UmFmKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZWxheW91dFJhZik7XG4gICAgICAgICAgICB0aGlzLl9yZWxheW91dFJhZiA9IG51bGw7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3ZpZGVkIGNvbnRleHQgd2l0aCB0aGUgY3VycmVudCBpbnZhbGlkYXRpb25Db250ZXh0IHNpbmNlIHdlIGFyZSBjYW5jZWxsaW5nXG4gICAgICAgICAgICAvLyBhIHNjaGVkdWxlZCByZWxheW91dE5vdyBjYWxsIHRoYXQgaGFzIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgc2V0IGFzIGl0cyBkZWZhdWx0IGNvbnRleHQgYXJnIChyZWxheW91dE5vdygpIGluIHJlbGF5b3V0KVxuICAgICAgICAgICAgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0LFxuICAgICAgICAgICAgICAgIC4uLmNvbnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIGludmFsaWRhdGlvbiBjb250ZXh0XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBudWxsO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHdlIGRvbid0IGhhdmUgYSBsYXlvdXQgb3IgY29udGVudCwgb3Igd2UgYXJlXG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYW4gYW5pbWF0ZWQgc2Nyb2xsIHRyYW5zaXRpb24uXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIXRoaXMuX2NvbGxlY3Rpb24gfHwgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSByZXR1cm47XG4gICAgICAgIGxldCBzY3JvbGxBbmNob3IgPSB0aGlzLl9nZXRTY3JvbGxBbmNob3IoKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgYmVmb3JlTGF5b3V0IGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5iZWZvcmVMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGxheW91dFxuICAgICAgICB0aGlzLmxheW91dC52YWxpZGF0ZShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudFNpemUodGhpcy5sYXlvdXQuZ2V0Q29udGVudFNpemUoKSk7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGFmdGVyTGF5b3V0IGhvb2ssIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5hZnRlckxheW91dCA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0LmFmdGVyTGF5b3V0KCk7XG4gICAgICAgIC8vIEFkanVzdCBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gc2Nyb2xsIGFuY2hvciwgYW5kIGNvbnN0cmFpbi5cbiAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgY2hhbmdlZCwgc2Nyb2xsIHRvIHRoZSB0b3AuXG4gICAgICAgIGxldCB2aXNpYmxlUmVjdCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgbGV0IHJlc3RvcmVkU2Nyb2xsQW5jaG9yID0gdGhpcy5fcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpO1xuICAgICAgICBsZXQgY29udGVudE9mZnNldFggPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLng7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0WSA9IGNvbnRleHQuY29udGVudENoYW5nZWQgPyAwIDogcmVzdG9yZWRTY3JvbGxBbmNob3IueTtcbiAgICAgICAgY29udGVudE9mZnNldFggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmNvbnRlbnRTaXplLndpZHRoIC0gdmlzaWJsZVJlY3Qud2lkdGgsIGNvbnRlbnRPZmZzZXRYKSk7XG4gICAgICAgIGNvbnRlbnRPZmZzZXRZID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5jb250ZW50U2l6ZS5oZWlnaHQgLSB2aXNpYmxlUmVjdC5oZWlnaHQsIGNvbnRlbnRPZmZzZXRZKSk7XG4gICAgICAgIGxldCBoYXNMYXlvdXRVcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChjb250ZW50T2Zmc2V0WCAhPT0gdmlzaWJsZVJlY3QueCB8fCBjb250ZW50T2Zmc2V0WSAhPT0gdmlzaWJsZVJlY3QueSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhbmltYXRlZCByZWxheW91dCwgd2UgZG8gbm90IGltbWVkaWF0ZWx5IHNjcm9sbCBiZWNhdXNlIGl0IHdvdWxkIGJlIGppdHRlcnkuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIG5ldyBjb250ZW50IG9mZnNldHMsIGFuZCBhcHBseSBpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGluZGl2aWR1YWwgY29udGVudCBpdGVtcyBpbnN0ZWFkLiBBdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24sIHdlJ2xsIHJlc2V0IGFuZCBzZXQgdGhlXG4gICAgICAgICAgICAvLyBzY3JvbGwgb2Zmc2V0IGZvciByZWFsLiBUaGlzIGVuc3VyZXMgaml0dGVyLWZyZWUgYW5pbWF0aW9uIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gc3luY1xuICAgICAgICAgICAgLy8gdGhlIHNjcm9sbCBhbmltYXRpb24gYW5kIHRoZSBjb250ZW50IGFuaW1hdGlvbi5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LmFuaW1hdGVkIHx8ICF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldC54ICs9IHZpc2libGVSZWN0LnggLSBjb250ZW50T2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueSArPSB2aXNpYmxlUmVjdC55IC0gY29udGVudE9mZnNldFk7XG4gICAgICAgICAgICAgICAgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMudXBkYXRlU3Vidmlld3MoY29udGV4dC5jb250ZW50Q2hhbmdlZCk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5fc2V0Q29udGVudE9mZnNldChuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKShjb250ZW50T2Zmc2V0WCwgY29udGVudE9mZnNldFkpKTtcbiAgICAgICAgfSBlbHNlIGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGNvbnRleHQuY29udGVudENoYW5nZWQpO1xuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MsIHVubGVzcyB0aGlzIGlzIGNvbWluZyBmcm9tIGFuIGFuaW1hdGVkIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmICghKGNvbnRleHQudHJhbnNhY3Rpb24gJiYgY29udGV4dC5hbmltYXRlZCkpIHRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW5pbWF0aW9ucywgYW5kIGFwcGx5IHRoZSBhZnRlckFuaW1hdGlvbiBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCAmJiBoYXNMYXlvdXRVcGRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVUcmFuc2l0aW9ucygpO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVUcmFuc2l0aW9ucygpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNjcm9sbCBwb3NpdGlvbiBhZnRlciBhbmltYXRpb25zIChzZWUgYWJvdmUgY29tbWVudCkuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnRlbnQgb2Zmc2V0IHRvIHNjcm9sbCB0bywgdGFraW5nIF9hbmltYXRlZENvbnRlbnRPZmZzZXQgaW50byBhY2NvdW50LlxuICAgICAgICAgICAgICAgICAgICBsZXQgeyB4OiB4LCB5OiB5IH0gPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoeCwgeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgYW5pbWF0aW9uIHRha2VzIHNsaWdodGx5IGxvbmdlciB0aGFuIGV4cGVjdGVkLlxuICAgICAgICAgICAgc2V0VGltZW91dChkb25lLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiArIDEwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckFuaW1hdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ29ycmVjdHMgRE9NIG9yZGVyIG9mIHZpc2libGUgdmlld3MgdG8gbWF0Y2ggaXRlbSBvcmRlciBvZiBjb2xsZWN0aW9uLlxuICAgKi8gX2NvcnJlY3RJdGVtT3JkZXIoKSB7XG4gICAgICAgIC8vIERlZmVyIHVudGlsIGFmdGVyIHNjcm9sbGluZyBhbmQgYW5pbWF0ZWQgdHJhbnNhY3Rpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICBpZiAodGhpcy5faXNTY3JvbGxpbmcgfHwgdGhpcy5fdHJhbnNhY3Rpb24pIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcy5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5hZGQodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuYWJsZVRyYW5zaXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBfZGlzYWJsZVRyYW5zaXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmVuZEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgX2dldFNjcm9sbEFuY2hvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHZpc2libGVSZWN0ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICAvLyBBc2sgdGhlIGRlbGVnYXRlIHRvIHByb3ZpZGUgYSBzY3JvbGwgYW5jaG9yLCBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGVnYXRlLmdldFNjcm9sbEFuY2hvcih2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyID0gbGF5b3V0SW5mby5yZWN0LmdldENvcm5lckluUmVjdCh2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gbGF5b3V0SW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBhbmNob3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiBpdCBpcyBhdCB0aGUgdG9wXG4gICAgICAgIGlmICh2aXNpYmxlUmVjdC55ID09PSAwICYmICF0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3ApIHJldHVybiBudWxsO1xuICAgICAgICAvLyBGaW5kIGEgdmlldyB3aXRoIGEgdmlzaWJsZSBjb3JuZXIgdGhhdCBoYXMgdGhlIHNtYWxsZXN0IGRpc3RhbmNlIHRvIHRoZSB0b3Agb2YgdGhlIGNvbGxlY3Rpb24gdmlld1xuICAgICAgICBsZXQgY29ybmVyQW5jaG9yID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKGxheW91dEluZm8gJiYgbGF5b3V0SW5mby5yZWN0LmFyZWEgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGxheW91dEluZm8ucmVjdFtjb3JuZXJdLnkgLSB2aXNpYmxlUmVjdC55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcm5lckFuY2hvciB8fCBvZmZzZXQgPCBjb3JuZXJBbmNob3Iub2Zmc2V0KSBjb3JuZXJBbmNob3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3JuZXJBbmNob3I7XG4gICAgfVxuICAgIF9yZXN0b3JlU2Nyb2xsQW5jaG9yKHNjcm9sbEFuY2hvciwgY29udGV4dCkge1xuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgaWYgKHNjcm9sbEFuY2hvcikge1xuICAgICAgICAgICAgdmFyIF9jb250ZXh0X3RyYW5zYWN0aW9uO1xuICAgICAgICAgICAgbGV0IGZpbmFsQW5jaG9yID0gKChfY29udGV4dF90cmFuc2FjdGlvbiA9IGNvbnRleHQudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9jb250ZXh0X3RyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGV4dF90cmFuc2FjdGlvbi5hbmltYXRlZCkgPyBjb250ZXh0LnRyYW5zYWN0aW9uLmZpbmFsTWFwLmdldChzY3JvbGxBbmNob3Iua2V5KSA6IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oc2Nyb2xsQW5jaG9yLmxheW91dEluZm8ua2V5KTtcbiAgICAgICAgICAgIGlmIChmaW5hbEFuY2hvcikge1xuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RtZW50ID0gZmluYWxBbmNob3IucmVjdFtzY3JvbGxBbmNob3IuY29ybmVyXS55IC0gY29udGVudE9mZnNldC55IC0gc2Nyb2xsQW5jaG9yLm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0LnkgKz0gYWRqdXN0bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldDtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZVJlY3QoKSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy52aXNpYmxlUmVjdDtcbiAgICAgICAgbGV0IHggPSB2LnggLSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueDtcbiAgICAgICAgbGV0IHkgPSB2LnkgLSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHgsIHksIHYud2lkdGgsIHYuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUxheW91dEluZm9zKCkge1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuc2hvdWxkT3ZlcnNjYW4gPyB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuZ2V0T3ZlcnNjYW5uZWRSZWN0KCkgOiB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IHRoaXMuX2dldExheW91dEluZm9NYXAocmVjdCk7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3M7XG4gICAgfVxuICAgIF9nZXRMYXlvdXRJbmZvTWFwKHJlY3QsIGNvcHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmxheW91dC5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwO1xuICAgICAgICBmb3IgKGxldCBsYXlvdXRJbmZvIG9mIGxheW91dEluZm9zKXtcbiAgICAgICAgICAgIGlmIChjb3B5KSBsYXlvdXRJbmZvID0gbGF5b3V0SW5mby5jb3B5KCk7XG4gICAgICAgICAgICBtYXAuc2V0KGxheW91dEluZm8ua2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB1cGRhdGVTdWJ2aWV3cyhmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgdmlzaWJsZUxheW91dEluZm9zID0gdGhpcy5nZXRWaXNpYmxlTGF5b3V0SW5mb3MoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRseVZpc2libGUgPSB0aGlzLl92aXNpYmxlVmlld3M7XG4gICAgICAgIGxldCB0b0FkZCwgdG9SZW1vdmUsIHRvVXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZm9yY2UgdXBkYXRlLCByZW1vdmUgYW5kIHJlLWFkZCBhbGwgdmlld3MuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZmluZCBhbmQgdXBkYXRlIHRoZSBkaWZmLlxuICAgICAgICBpZiAoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgICAgIHRvQWRkID0gdmlzaWJsZUxheW91dEluZm9zO1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBjdXJyZW50bHlWaXNpYmxlO1xuICAgICAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoeyB0b0FkZDogdG9BZGQsIHRvUmVtb3ZlOiB0b1JlbW92ZSwgdG9VcGRhdGU6IHRvVXBkYXRlIH0gPSAoMCwgJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIpKGN1cnJlbnRseVZpc2libGUsIHZpc2libGVMYXlvdXRJbmZvcykpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvVXBkYXRlKXtcbiAgICAgICAgICAgICAgICBsZXQgdmlldyA9IGN1cnJlbnRseVZpc2libGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3IHx8ICF2aWV3LmxheW91dEluZm8pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5nZXRJdGVtKHZpc2libGVMYXlvdXRJbmZvcy5nZXQoa2V5KS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmNvbnRlbnQgPT09IGl0ZW0pIHRvVXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmlldyB0eXBlIGNoYW5nZXMsIGRlbGV0ZSBhbmQgcmVjcmVhdGUgdGhlIHZpZXcgaW5zdGVhZCBvZiB1cGRhdGluZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKHZpZXcubGF5b3V0SW5mbywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3LnZpZXdUeXBlICE9PSByZXVzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BZGQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIGlmIHRoZSBzZXRzIGFyZSBlcXVhbFxuICAgICAgICAgICAgaWYgKHRvQWRkLnNpemUgPT09IDAgJiYgdG9SZW1vdmUuc2l6ZSA9PT0gMCAmJiB0b1VwZGF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWNrIHZpZXdzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuIFRoZXkgYXJlIG5vdCByZW1vdmVkIGZyb21cbiAgICAgICAgLy8gdGhlIERPTSBpbW1lZGlhdGVseSwgc2luY2Ugd2UgbWF5IHJldXNlIGFuZCBuZWVkIHRvIHJlLWluc2VydFxuICAgICAgICAvLyB0aGVtIGJhY2sgaW50byB0aGUgRE9NIGFueXdheS5cbiAgICAgICAgbGV0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0b1JlbW92ZS5rZXlzKCkpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLl92aXNpYmxlVmlld3MuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHJlbW92ZWQuYWRkKHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHRyYW5zYWN0aW9uLCB3YWl0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYW5pbWF0aW9ucyB0byByZW1vdmUgdGhlIHZpZXdzIGZyb20gdGhlIERPTS4gQWxzbyBtZWFuc1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHJldXNlIHRob3NlIHZpZXdzIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJldXNlVmlldyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9BZGQua2V5cygpKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdmlzaWJsZUxheW91dEluZm9zLmdldChrZXkpO1xuICAgICAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhbmQgYSBsYXlvdXQgY2hhbmdlIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgYW5pbWF0aW9ucyBzdWNoIHRoYXQgYSB2aWV3IHRoYXQgd2FzIGdvaW5nXG4gICAgICAgICAgICAvLyB0byBiZSByZW1vdmVkIGlzIG5vdyBub3QsIHdlIGRvbid0IGNyZWF0ZSBhIG5ldyB2aWV3XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgb2xkIG9uZSBpcyBzdGlsbCBpbiB0aGUgRE9NLCBtYXJrZWQgYXMgdG9SZW1vdmUuXG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0cmFuc2FjdGlvbiwgZ2V0IGluaXRpYWwgbGF5b3V0IGF0dHJpYnV0ZXMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uaGFzKGtleSkpIGxheW91dEluZm8gPSB0aGlzLl90cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgb3IgcmV1c2UgYSB2aWV3IGZvciB0aGlzIHJvd1xuICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFJldXNhYmxlVmlldyhsYXlvdXRJbmZvKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZpZXcgdG8gdGhlIERPTSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZWQuaGFzKHZpZXcpKSB0aGlzLl9jaGlsZHJlbi5hZGQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3Muc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICByZW1vdmVkLmRlbGV0ZSh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9VcGRhdGUpe1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBjdXJyZW50bHlWaXNpYmxlLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVmlldyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlbWFpbmluZyByb3dzIHRvIGRlbGV0ZSBmcm9tIHRoZSBET01cbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5yZW1vdmVWaWV3cyhyZW1vdmVkKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IHRoaXMuX3RyYW5zYWN0aW9uICYmICh0b0FkZC5zaXplID4gMCB8fCB0b1JlbW92ZS5zaXplID4gMCB8fCB0aGlzLl9oYXNMYXlvdXRVcGRhdGVzKCkpO1xuICAgICAgICBpZiAoaGFzTGF5b3V0VXBkYXRlcykgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHRyYW5zYWN0aW9uLCBhcHBseSBhbmltYXRpb25zIHRvIHZpc2libGUgdmlld3NcbiAgICAgICAgICAgIC8vIGFuZCBcInRvIGJlIHJlbW92ZWRcIiB2aWV3cywgd2hpY2ggYW5pbWF0ZSBvZmYgc2NyZWVuLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX2FwcGx5TGF5b3V0SW5mb3MoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFzTGF5b3V0VXBkYXRlcztcbiAgICB9XG4gICAgYWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQpIHRoaXMucmVsYXlvdXROb3coKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkT3ZlcnNjYW4pIHRoaXMuX292ZXJzY2FuTWFuYWdlci5jb2xsZWN0TWV0cmljcygpO1xuICAgIH1cbiAgICBfZmx1c2hWaXNpYmxlVmlld3MoKSB7XG4gICAgICAgIC8vIENvbGxlY3Rpb25WaXJ0dWFsaXplciBkZWFscyB3aXRoIGEgZmxhdHRlbmVkIHNldCBvZiBMYXlvdXRJbmZvcywgYnV0IHRoZXkgY2FuIHJlcHJlc2VudCBoZWlyYXJjaHlcbiAgICAgICAgLy8gYnkgcmVmZXJlbmNpbmcgYSBwYXJlbnRLZXkuIEp1c3QgYmVmb3JlIHJlbmRlcmluZyB0aGUgdmlzaWJsZSB2aWV3cywgd2UgcmVidWlsZCB0aGlzIGhlaXJhcmNoeVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG1hcHBpbmcgb2Ygdmlld3MgYnkgcGFyZW50IGtleSBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aGUgZGVsZWdhdGUncyByZW5kZXJXcmFwcGVyXG4gICAgICAgIC8vIG1ldGhvZCB0byBidWlsZCB0aGUgZmluYWwgdHJlZS5cbiAgICAgICAgbGV0IHZpZXdzQnlQYXJlbnRLZXkgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX2NoaWxkcmVuKXtcbiAgICAgICAgICAgIHZhciBfdmlld19sYXlvdXRJbmZvLCBfdmlld3NCeVBhcmVudEtleV9nZXQsIF92aWV3X2xheW91dEluZm8xLCBfdmlld19sYXlvdXRJbmZvMiwgX3ZpZXdfbGF5b3V0SW5mbzM7XG4gICAgICAgICAgICBpZiAoKChfdmlld19sYXlvdXRJbmZvID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvLnBhcmVudEtleSkgIT0gbnVsbCAmJiAhdmlld3NCeVBhcmVudEtleS5oYXModmlldy5sYXlvdXRJbmZvLnBhcmVudEtleSkpIHZpZXdzQnlQYXJlbnRLZXkuc2V0KHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXksIFtdKTtcbiAgICAgICAgICAgIChfdmlld3NCeVBhcmVudEtleV9nZXQgPSB2aWV3c0J5UGFyZW50S2V5LmdldCgoX3ZpZXdfbGF5b3V0SW5mbzEgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMS5wYXJlbnRLZXkpKSA9PT0gbnVsbCB8fCBfdmlld3NCeVBhcmVudEtleV9nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92aWV3c0J5UGFyZW50S2V5X2dldC5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgaWYgKCF2aWV3c0J5UGFyZW50S2V5LmhhcygoX3ZpZXdfbGF5b3V0SW5mbzIgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMi5rZXkpKSB2aWV3c0J5UGFyZW50S2V5LnNldCgoX3ZpZXdfbGF5b3V0SW5mbzMgPSB2aWV3LmxheW91dEluZm8pID09PSBudWxsIHx8IF92aWV3X2xheW91dEluZm8zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld19sYXlvdXRJbmZvMy5rZXksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVpbGRUcmVlID0gKHBhcmVudCwgdmlld3MpPT52aWV3cy5tYXAoKHZpZXcpPT57XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdmlld3NCeVBhcmVudEtleS5nZXQodmlldy5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVuZGVyV3JhcHBlcihwYXJlbnQsIHZpZXcsIGNoaWxkcmVuLCAoY2hpbGRWaWV3cyk9PmJ1aWxkVHJlZSh2aWV3LCBjaGlsZFZpZXdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gYnVpbGRUcmVlKG51bGwsIHZpZXdzQnlQYXJlbnRLZXkuZ2V0KG51bGwpKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlVmlld3MoY2hpbGRyZW4pO1xuICAgIH1cbiAgICBfYXBwbHlMYXlvdXRJbmZvKHZpZXcsIGxheW91dEluZm8pIHtcbiAgICAgICAgaWYgKHZpZXcubGF5b3V0SW5mbyA9PT0gbGF5b3V0SW5mbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2aWV3LmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2FwcGx5TGF5b3V0SW5mb3MoKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEFwcGx5IGxheW91dCBpbmZvcyB0byB2aXNpYmxlIHZpZXdzXG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKXtcbiAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAoKGN1ciA9PT0gbnVsbCB8fCBjdXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1ci5rZXkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgZmluYWwgbGF5b3V0IGluZm9zIGZvciB2aWV3cyB0aGF0IHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24udG9SZW1vdmUudmFsdWVzKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhjdXIua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl90cmFuc2FjdGlvbi5yZW1vdmVkLnZhbHVlcygpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5fdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLmdldChjdXIua2V5KSB8fCBjdXI7XG4gICAgICAgICAgICAgICAgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvLmNvcHkoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgfVxuICAgIF9oYXNMYXlvdXRVcGRhdGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKXtcbiAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LmxheW91dEluZm87XG4gICAgICAgICAgICBpZiAoIWN1cikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICBpZiAoLy8gVXNlcyBlcXVhbHMgcmF0aGVyIHRoYW4gcG9pbnRFcXVhbHMgc28gdGhhdCB3aWR0aC9oZWlnaHQgY2hhbmdlcyBhcmUgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgICAgICAhY3VyLnJlY3QuZXF1YWxzKGxheW91dEluZm8ucmVjdCkgfHwgY3VyLm9wYWNpdHkgIT09IGxheW91dEluZm8ub3BhY2l0eSB8fCBjdXIudHJhbnNmb3JtICE9PSBsYXlvdXRJbmZvLnRyYW5zZm9ybSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXVzZVZpZXcodmlldykge1xuICAgICAgICB2aWV3LnByZXBhcmVGb3JSZXVzZSgpO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzW3ZpZXcudmlld1R5cGVdLnB1c2godmlldyk7XG4gICAgfVxuICAgIHJlbW92ZVZpZXdzKHRvUmVtb3ZlKSB7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdG9SZW1vdmUpdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpIHtcbiAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGJlIGFibGUgdG8gaW52YWxpZGF0ZSBhIHNpbmdsZSBpbmRleCBwYXRoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCF0aGlzLmxheW91dC51cGRhdGVJdGVtU2l6ZSkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGFkZCB0aGUgdXBkYXRlXG4gICAgICAgIC8vIHRvIGEgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5zZXQoa2V5LCBzaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHRoaXMucmVsYXlvdXQoKTtcbiAgICB9XG4gICAgc3RhcnRTY3JvbGxpbmcoKSB7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5kU2Nyb2xsaW5nKCkge1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb3JyZWN0SXRlbU9yZGVyKCk7XG4gICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgfVxuICAgIF9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFuaW1hdGVkIGNvbnRlbnQgb2Zmc2V0IG9mIHN1YnZpZXdzLiBTZWUgY29tbWVudCBpbiByZWxheW91dE5vdyBmb3IgZGV0YWlscy5cbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5IGludG8gdmlldywgb3B0aW9uYWxseSB3aXRoIGFuIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHNjcm9sbCBpbnRvIHZpZXcuXG4gICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBhbmltYXRpb24uXG4gICAqLyBzY3JvbGxUb0l0ZW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGtleSBjYW4gYmUgMCwgc28gY2hlY2sgaWYgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrZXkpO1xuICAgICAgICBpZiAoIWxheW91dEluZm8pIHJldHVybjtcbiAgICAgICAgbGV0IHsgZHVyYXRpb246IGR1cmF0aW9uID0gMzAwLCBzaG91bGRTY3JvbGxYOiBzaG91bGRTY3JvbGxYID0gdHJ1ZSwgc2hvdWxkU2Nyb2xsWTogc2hvdWxkU2Nyb2xsWSA9IHRydWUsIG9mZnNldFg6IG9mZnNldFggPSAwLCBvZmZzZXRZOiBvZmZzZXRZID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHggPSB0aGlzLnZpc2libGVSZWN0Lng7XG4gICAgICAgIGxldCB5ID0gdGhpcy52aXNpYmxlUmVjdC55O1xuICAgICAgICBsZXQgbWluWCA9IGxheW91dEluZm8ucmVjdC54IC0gb2Zmc2V0WDtcbiAgICAgICAgbGV0IG1pblkgPSBsYXlvdXRJbmZvLnJlY3QueSAtIG9mZnNldFk7XG4gICAgICAgIGxldCBtYXhYID0geCArIHRoaXMudmlzaWJsZVJlY3Qud2lkdGg7XG4gICAgICAgIGxldCBtYXhZID0geSArIHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsWCkge1xuICAgICAgICAgICAgaWYgKG1pblggPD0geCB8fCBtYXhYID09PSAwKSB4ID0gbWluWDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheW91dEluZm8ucmVjdC5tYXhYID4gbWF4WCkgeCArPSBsYXlvdXRJbmZvLnJlY3QubWF4WCAtIG1heFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFkpIHtcbiAgICAgICAgICAgIGlmIChtaW5ZIDw9IHkgfHwgbWF4WSA9PT0gMCkgeSA9IG1pblk7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRJbmZvLnJlY3QubWF4WSA+IG1heFkpIHkgKz0gbGF5b3V0SW5mby5yZWN0Lm1heFkgLSBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHgsIHkpLCBkdXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBhbmltYXRlZCBzY3JvbGwgdG8gdGhlIGdpdmVuIG9mZnNldC5cbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gc2Nyb2xsIHRvLlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovIHNjcm9sbFRvKG9mZnNldCwgZHVyYXRpb24gPSAzMDApIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHNjcm9sbCBhbmltYXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGNvbnRlbnQgb2Zmc2V0IHN5bmNocm9ub3VzbHkgaWYgdGhlIGR1cmF0aW9uIGlzIHplcm9cbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAgfHwgdGhpcy52aXNpYmxlUmVjdC5wb2ludEVxdWFscyhvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNjcm9sbGluZygpO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24gPSAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMpKHRoaXMudmlzaWJsZVJlY3QsIG9mZnNldCwgZHVyYXRpb24sICgwLCAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCksIChvZmZzZXQpPT57XG4gICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxBbmltYXRpb24udGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdmlldyBzaXplIHVwZGF0ZXMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlld3MgdGhhdCBhcmUgc3RpbGwgdmlzaWJsZSB3aWxsIGJlIGFjdHVhbGx5IHVwZGF0ZWQuXG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCBzaXplXSBvZiB0aGlzLl9zaXplVXBkYXRlUXVldWUpdGhpcy51cGRhdGVJdGVtU2l6ZShrZXksIHNpemUpO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmRTY3JvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxBbmltYXRpb247XG4gICAgfVxuICAgIF9ydW5UcmFuc2FjdGlvbihhY3Rpb24sIGFuaW1hdGVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbikgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICB0aGlzLl9lbmRUcmFuc2FjdGlvbihhbmltYXRlZCk7XG4gICAgfVxuICAgIF9zdGFydFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX25leHRUcmFuc2FjdGlvbikgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbmV3ICgwLCAkOGUxMzVlNTMxZDhkY2I2NiRleHBvcnQkZmViYzU1NzNjNzVjZWZiMCk7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbi5sZXZlbCsrO1xuICAgIH1cbiAgICBfZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gU2F2ZSB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYW5pbWF0ZWQuXG4gICAgICAgIGlmIChhbmltYXRlZCAhPSBudWxsKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPSBhbmltYXRlZDtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIGxldmVsIDAsIHdlIGFyZSBzdGlsbCBpbiBhXG4gICAgICAgIC8vIG5lc3RlZCB0cmFuc2FjdGlvbi4gV2FpdCBmb3IgdGhlIHBhcmVudCB0byBlbmQuXG4gICAgICAgIGlmICgtLXRoaXMuX25leHRUcmFuc2FjdGlvbi5sZXZlbCA+IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBmb3IgZW1wdHkgdHJhbnNhY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBhbmltYXRpb25zIHRvIHRydWVcbiAgICAgICAgaWYgKHRoaXMuX25leHRUcmFuc2FjdGlvbi5hbmltYXRlZCA9PSBudWxsKSB0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBFbnF1ZXVlIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvblF1ZXVlLnB1c2godGhpcy5fbmV4dFRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gaXMgYW5pbWF0aW5nLCB3YWl0IHVudGlsIHRoZSBlbmRcbiAgICAgICAgLy8gdG8gcHJvY2VzcyB0aGUgbmV4dCB0cmFuc2FjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuX3RyYW5zYWN0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQpIHRoaXMuX3BlcmZvcm1UcmFuc2FjdGlvbihuZXh0KTtcbiAgICB9XG4gICAgX2dldENvbnRlbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoMCwgMCwgdGhpcy5jb250ZW50U2l6ZS53aWR0aCwgdGhpcy5jb250ZW50U2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICBfcGVyZm9ybVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgYW5pbWF0ZWQ6IHRyYW5zYWN0aW9uLmFuaW1hdGVkLFxuICAgICAgICAgICAgYmVmb3JlTGF5b3V0OiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQgaW5mb3MgZm9yIGFsbCB2aWV3cyBiZWZvcmUgdGhlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gZmlndXJlIG91dCB3aGljaCB2aWV3cyB0byBhZGQgYW5kIHJlbW92ZS5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHRyYW5zYWN0aW9uLmluaXRpYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCksIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBhY3Rpb25zIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdHJhbnNhY3Rpb24uYWN0aW9ucylhY3Rpb24oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckxheW91dDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIGxheW91dCBpbmZvcyBhZnRlciB0aGUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5hbmltYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5maW5hbE1hcCA9IHRoaXMuX2dldExheW91dEluZm9NYXAodGhpcy5fZ2V0Q29udGVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwVHJhbnNhY3Rpb25BbmltYXRpb25zKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyQW5pbWF0aW9uOiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbmQgcmV1c2Ugdmlld3Mgd2hlbiBhbmltYXRpb25zIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvUmVtb3ZlLnNpemUgPiAwIHx8IHRyYW5zYWN0aW9uLnJlbW92ZWQuc2l6ZSA+IDApIGZvciAobGV0IHZpZXcgb2YgKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRjZmMxNDA4OGRmZWZjZTVmKSh0cmFuc2FjdGlvbi50b1JlbW92ZS52YWx1ZXMoKSwgdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5kZWxldGUodmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV1c2VWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIERPTSBvcmRlciBpcyBjb3JyZWN0IGZvciBhY2Nlc3NpYmlsaXR5IGFmdGVyIGFuaW1hdGlvbnMgYXJlIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoVmlzaWJsZVZpZXdzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgeyBpbml0aWFsTWFwOiBpbml0aWFsTWFwLCBmaW5hbE1hcDogZmluYWxNYXAgfSA9IHRyYW5zYWN0aW9uO1xuICAgICAgICAvLyBTdG9yZSBpbml0aWFsIGFuZCBmaW5hbCBsYXlvdXQgaW5mb3MgZm9yIGFuaW1hdGlvbnNcbiAgICAgICAgZm9yIChsZXQgW2tleSwgbGF5b3V0SW5mb10gb2YgaW5pdGlhbE1hcClpZiAoZmluYWxNYXAuaGFzKGtleSkpIC8vIFN0b3JlIHRoZSBpbml0aWFsIGxheW91dCBpbmZvIGZvciB1c2UgZHVyaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLnNldChrZXksIGxheW91dEluZm8pO1xuICAgICAgICBlbHNlIC8vIFRoaXMgdmlldyB3YXMgcmVtb3ZlZC4gU3RvcmUgdGhlIGxheW91dCBpbmZvIGZvciB1c2VcbiAgICAgICAgLy8gaW4gTGF5b3V0I2dldEZpbmFsTGF5b3V0SW5mbyBkdXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLnNldChsYXlvdXRJbmZvLmtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIC8vIEdldCBpbml0aWFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3ZXJlIGFkZGVkXG4gICAgICAgIGZvciAobGV0IFtrZXksIGxheW91dEluZm9dIG9mIGZpbmFsTWFwKWlmICghaW5pdGlhbE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgbGV0IGluaXRpYWxMYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0SW5pdGlhbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uc2V0KGtleSwgaW5pdGlhbExheW91dEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggdmlld3Mgd2VyZSByZW1vdmVkLlxuICAgICAgICBmb3IgKGxldCBba2V5LCB2aWV3XSBvZiB0aGlzLl92aXNpYmxlVmlld3MpLy8gSWYgYW4gaXRlbSBoYXMgYSB3aWR0aCBvZiAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBfdmlzaWJsZVZpZXdzLlxuICAgICAgICAvLyBSZW1vdmluZyBhbiBpdGVtIHdpdGggIHdpZHRoIG9mIDAgY2FuIGNhdXNlIGEgbG9vcCB3aGVyZSB0aGUgaXRlbSBnZXRzIGFkZGVkLCByZW1vdmVkLFxuICAgICAgICAvLyBhZGRlZCwgcmVtb3ZlZC4uLiBldGMgaW4gYSBsb29wLlxuICAgICAgICBpZiAoIWZpbmFsTWFwLmhhcyhrZXkpICYmIHZpZXcubGF5b3V0SW5mby5yZWN0LndpZHRoID4gMCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVtb3ZlZC5zZXQoa2V5LCB2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVWaWV3cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugc29tZXRoaW5nIHdlaXJkIGhhcHBlbmVkLCB3aGVyZSB3ZSBoYXZlIGEgdmlldyBidXQgbm9cbiAgICAgICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IGluZm8sIHVzZSB0aGUgb25lIGF0dGFjaGVkIHRvIHRoZSB2aWV3LlxuICAgICAgICAgICAgaWYgKHZpZXcubGF5b3V0SW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLmhhcyh2aWV3LmxheW91dEluZm8ua2V5KSkgdHJhbnNhY3Rpb24uZmluYWxMYXlvdXRJbmZvLnNldCh2aWV3LmxheW91dEluZm8ua2V5LCB2aWV3LmxheW91dEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gbmV3ICgwLCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCk7XG4gICAgICAgIHRoaXMuX3JldXNhYmxlVmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUxheW91dEluZm9zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyID0gbmV3ICgwLCAkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYikoKTtcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSgwLCAwKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvblF1ZXVlID0gW107XG4gICAgICAgIHZhciBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgIC8vIFNldCBvcHRpb25zIGZyb20gcGFzc2VkIG9iamVjdCBpZiBnaXZlblxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IChfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uICE9PSB2b2lkIDAgPyBfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24gOiA1MDA7XG4gICAgICAgIHRoaXMuYW5jaG9yU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25zLmFuY2hvclNjcm9sbFBvc2l0aW9uIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AgPSBvcHRpb25zLmFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkT3ZlcnNjYW4gPSBvcHRpb25zLnNob3VsZE92ZXJzY2FuICE9PSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIFtcbiAgICAgICAgICAgIFwiZGVsZWdhdGVcIixcbiAgICAgICAgICAgIFwic2l6ZVwiLFxuICAgICAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgICAgIFwiY29sbGVjdGlvblwiXG4gICAgICAgIF0paWYgKG9wdGlvbnNba2V5XSkgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiAkZmMwYjEzYjQ4NGFjMTE5NCRleHBvcnQkMTUwNWRiODJmZTM1N2U2NShvcHRzKSB7XG4gICAgbGV0IFt2aXNpYmxlVmlld3MsIHNldFZpc2libGVWaWV3c10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShbXSk7XG4gICAgbGV0IFtjb250ZW50U2l6ZSwgc2V0Q29udGVudFNpemVdID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkobmV3ICgwLCAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYykoKSk7XG4gICAgbGV0IFtpc0FuaW1hdGluZywgc2V0QW5pbWF0aW5nXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzU2Nyb2xsaW5nLCBzZXRTY3JvbGxpbmddID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCB2aXJ0dWFsaXplciA9ICgwLCAkOEQzbnIkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIpKCksIFtdKTtcbiAgICB2aXJ0dWFsaXplci5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgc2V0VmlzaWJsZVZpZXdzOiBzZXRWaXNpYmxlVmlld3MsXG4gICAgICAgIHNldFZpc2libGVSZWN0IChyZWN0KSB7XG4gICAgICAgICAgICB2aXJ0dWFsaXplci52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICBvcHRzLm9uVmlzaWJsZVJlY3RDaGFuZ2UocmVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbnRlbnRTaXplOiBzZXRDb250ZW50U2l6ZSxcbiAgICAgICAgcmVuZGVyVmlldzogb3B0cy5yZW5kZXJWaWV3LFxuICAgICAgICByZW5kZXJXcmFwcGVyOiBvcHRzLnJlbmRlcldyYXBwZXIsXG4gICAgICAgIGJlZ2luQW5pbWF0aW9uczogKCk9PnNldEFuaW1hdGluZyh0cnVlKSxcbiAgICAgICAgZW5kQW5pbWF0aW9uczogKCk9PnNldEFuaW1hdGluZyhmYWxzZSksXG4gICAgICAgIGdldFNjcm9sbEFuY2hvcjogb3B0cy5nZXRTY3JvbGxBbmNob3JcbiAgICB9O1xuICAgIHZpcnR1YWxpemVyLmxheW91dCA9IG9wdHMubGF5b3V0O1xuICAgIHZpcnR1YWxpemVyLmNvbGxlY3Rpb24gPSBvcHRzLmNvbGxlY3Rpb247XG4gICAgdmlydHVhbGl6ZXIudHJhbnNpdGlvbkR1cmF0aW9uID0gb3B0cy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgKDAsICQ4RDNuciR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLmFmdGVyUmVuZGVyKCk7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDhEM25yJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT52aXJ0dWFsaXplci53aWxsVW5tb3VudCgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgbGV0IHNldFZpc2libGVSZWN0ID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKHJlY3QpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLnZpc2libGVSZWN0ID0gcmVjdDtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IHN0YXJ0U2Nyb2xsaW5nID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgc2V0U2Nyb2xsaW5nKHRydWUpO1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgZW5kU2Nyb2xsaW5nID0gKDAsICQ4RDNuciR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgdmlydHVhbGl6ZXIuZW5kU2Nyb2xsaW5nKCk7XG4gICAgICAgIHNldFNjcm9sbGluZyhmYWxzZSk7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkOEQzbnIkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICB2aXJ0dWFsaXplcjogdmlydHVhbGl6ZXIsXG4gICAgICAgICAgICB2aXNpYmxlVmlld3M6IHZpc2libGVWaWV3cyxcbiAgICAgICAgICAgIHNldFZpc2libGVSZWN0OiBzZXRWaXNpYmxlUmVjdCxcbiAgICAgICAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50U2l6ZSxcbiAgICAgICAgICAgIGlzQW5pbWF0aW5nOiBpc0FuaW1hdGluZyxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiBpc1Njcm9sbGluZyxcbiAgICAgICAgICAgIHN0YXJ0U2Nyb2xsaW5nOiBzdGFydFNjcm9sbGluZyxcbiAgICAgICAgICAgIGVuZFNjcm9sbGluZzogZW5kU2Nyb2xsaW5nXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHZpcnR1YWxpemVyLFxuICAgICAgICB2aXNpYmxlVmlld3MsXG4gICAgICAgIHNldFZpc2libGVSZWN0LFxuICAgICAgICBjb250ZW50U2l6ZSxcbiAgICAgICAgaXNBbmltYXRpbmcsXG4gICAgICAgIGlzU2Nyb2xsaW5nLFxuICAgICAgICBzdGFydFNjcm9sbGluZyxcbiAgICAgICAgZW5kU2Nyb2xsaW5nXG4gICAgXSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuXG5cblxuXG5leHBvcnQgeyRjNzRjZGE3ZDMxYWYxMjUzJGV4cG9ydCRjODQ2NzFmNDZkNmExY2EgYXMgTGF5b3V0LCAkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSBhcyBMYXlvdXRJbmZvLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSBhcyBQb2ludCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QgYXMgUmVjdCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMgYXMgU2l6ZSwgJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEgYXMgUmV1c2FibGVWaWV3LCAkZmMwYjEzYjQ4NGFjMTE5NCRleHBvcnQkMTUwNWRiODJmZTM1N2U2NSBhcyB1c2VWaXJ0dWFsaXplclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIiQ4RDNuciR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkOEQzbnIkdXNlTWVtbyIsInVzZUVmZmVjdCIsIiQ4RDNuciR1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIiQ4RDNuciR1c2VDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsIiQ4RDNuciR1c2VMYXlvdXRFZmZlY3QiLCIkYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIiwic2hvdWxkSW52YWxpZGF0ZSIsIm5ld1JlY3QiLCJvbGRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2YWxpZGF0ZSIsImludmFsaWRhdGlvbkNvbnRleHQiLCJnZXRJbml0aWFsTGF5b3V0SW5mbyIsImxheW91dEluZm8iLCJnZXRGaW5hbExheW91dEluZm8iLCIkZDdmZDYxMDA5YzIxZDBiYiRleHBvcnQkN2UwZWViOWRhNzAyYTA4NSIsImNvcHkiLCJyZXMiLCJ0eXBlIiwia2V5IiwicmVjdCIsImVzdGltYXRlZFNpemUiLCJvcGFjaXR5IiwidHJhbnNmb3JtIiwicGFyZW50S2V5IiwiaXNTdGlja3kiLCJ6SW5kZXgiLCJhbGxvd092ZXJmbG93IiwiY29uc3RydWN0b3IiLCIkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSIsIngiLCJ5IiwiZXF1YWxzIiwicG9pbnQiLCJpc09yaWdpbiIsIiQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIiwibWF4WCIsIm1heFkiLCJhcmVhIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiaW50ZXJzZWN0cyIsImNvbnRhaW5zUmVjdCIsImNvbnRhaW5zUG9pbnQiLCJnZXRDb3JuZXJJblJlY3QiLCJwb2ludEVxdWFscyIsInNpemVFcXVhbHMiLCJzaXplIiwidW5pb24iLCJvdGhlciIsIk1hdGgiLCJtaW4iLCJtYXgiLCJpbnRlcnNlY3Rpb24iLCIkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyIsIiRhZDFkOThhYThmMGMzMWI0JHZhciRLRVkiLCIkYWQxZDk4YWE4ZjBjMzFiNCRleHBvcnQkMWE1MjIzODg3YzU2MDQ0MSIsInByZXBhcmVGb3JSZXVzZSIsImNvbnRlbnQiLCJyZW5kZXJlZCIsInZpcnR1YWxpemVyIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmTm93Iiwibm93Iiwid2Via2l0Tm93IiwibXNOb3ciLCJtb3pOb3ciLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSIsImJpbmQiLCJEYXRlIiwiZ2V0VGltZSIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcyIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjIiwiYmVnaW4iLCJlbmQiLCJkdXJhdGlvbiIsImVhc2UiLCJmbiIsImNhbmNlbGVkIiwicmFmX2lkIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhcnQiLCJkaWZmWCIsImRpZmZZIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicnVuIiwidCIsImRlbHRhIiwicHJvY2VlZCIsImNhbmNlbCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDc3ODYwYzEwNmI0YTZhMmUiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCIsInNpbiIsIlBJIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDM3YTI2YjI4M2ZkNzc0MGUiLCJhIiwiYiIsIlNldCIsImtleXMiLCJoYXMiLCJhZGQiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYWNhZjk2YTI3NDM4MjQ2YiIsInRvUmVtb3ZlIiwidG9BZGQiLCJ0b1VwZGF0ZSIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRjZmMxNDA4OGRmZWZjZTVmIiwiaXRlcmF0b3JzIiwiaXRlcmF0b3IiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkNjg5N2MyODRiNmY5ZjRkYyIsIm9iamVjdCIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0IiwiJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlIiwiYWRkU2FtcGxlIiwic2FtcGxlIiwiY291bnQiLCJ2YWx1ZSIsIiQzNjQxOTFiM2RlY2YzNjk3JGV4cG9ydCQ0NDU1ZWU2YWZiMzhkY2JiIiwic2V0VmlzaWJsZVJlY3QiLCJ0aW1lIiwic3RhcnRUaW1lIiwiYXZlcmFnZVRpbWUiLCJ2aXNpYmxlUmVjdCIsInZlbG9jaXR5IiwiY29sbGVjdE1ldHJpY3MiLCJhdmVyYWdlUGVyZiIsIm8iLCJhYnMiLCJvdmVyc2NhblkiLCJvdmVyc2NhblgiLCJnZXRPdmVyc2Nhbm5lZFJlY3QiLCJvdmVyc2Nhbm5lZCIsInJvdW5kIiwiJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjAiLCJsZXZlbCIsImFjdGlvbnMiLCJhbmltYXRlZCIsImluaXRpYWxNYXAiLCJNYXAiLCJmaW5hbE1hcCIsImluaXRpYWxMYXlvdXRJbmZvIiwiZmluYWxMYXlvdXRJbmZvIiwicmVtb3ZlZCIsIiQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyIiwiX3NldENvbnRlbnRTaXplIiwiX2NvbnRlbnRTaXplIiwiZGVsZWdhdGUiLCJzZXRDb250ZW50U2l6ZSIsIl9zZXRDb250ZW50T2Zmc2V0Iiwib2Zmc2V0IiwiX3Zpc2libGVSZWN0IiwiY29udGVudFNpemUiLCJfc2V0VmlzaWJsZVJlY3QiLCJmb3JjZVVwZGF0ZSIsImN1cnJlbnQiLCJzaG91bGRPdmVyc2NhbiIsIl9vdmVyc2Nhbk1hbmFnZXIiLCJsYXlvdXQiLCJfcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQiLCJyZWxheW91dE5vdyIsIm9mZnNldENoYW5nZWQiLCJzaXplQ2hhbmdlZCIsInVwZGF0ZVN1YnZpZXdzIiwiY29sbGVjdGlvbiIsIl9jb2xsZWN0aW9uIiwiZGF0YSIsIl9zZXREYXRhIiwiX3J1blRyYW5zYWN0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwicmVsb2FkRGF0YSIsInJlbGF5b3V0IiwiY29udGVudENoYW5nZWQiLCJnZXRJdGVtIiwicGVyc2lzdGVkS2V5cyIsIl9wZXJzaXN0ZWRLZXlzIiwiaXNQZXJzaXN0ZWRLZXkiLCJrIiwiZ2V0TGF5b3V0SW5mbyIsIl9sYXlvdXQiLCJzZXRMYXlvdXQiLCJhcHBseUxheW91dCIsIl9nZXRSZXVzZVR5cGUiLCJnZXRUeXBlIiwicmV1c2VUeXBlIiwiZ2V0UmV1c2FibGVWaWV3IiwiX3JldXNhYmxlVmlld3MiLCJyZXVzYWJsZSIsInZpZXciLCJsZW5ndGgiLCJwb3AiLCJ2aWV3VHlwZSIsIl9hbmltYXRlZENvbnRlbnRPZmZzZXQiLCJfcmVuZGVyVmlldyIsInJldXNhYmxlVmlldyIsIl9yZW5kZXJDb250ZW50IiwiY2FjaGVkIiwiX3JlbmRlcmVkQ29udGVudCIsImdldCIsInJlbmRlclZpZXciLCJzZXQiLCJ2aXNpYmxlVmlld3MiLCJBcnJheSIsImZyb20iLCJfdmlzaWJsZVZpZXdzIiwidmFsdWVzIiwiZ2V0VmlldyIsImdldFZpZXdzT2ZUeXBlIiwiZmlsdGVyIiwidiIsImtleUZvclZpZXciLCJrZXlBdFBvaW50IiwibGF5b3V0SW5mb3MiLCJnZXRWaXNpYmxlTGF5b3V0SW5mb3MiLCJ3aWxsVW5tb3VudCIsIl9yZWxheW91dFJhZiIsImNvbnRleHQiLCJfc2Nyb2xsQW5pbWF0aW9uIiwiX2ludmFsaWRhdGlvbkNvbnRleHQiLCJPYmplY3QiLCJhc3NpZ24iLCJzY3JvbGxBbmNob3IiLCJfZ2V0U2Nyb2xsQW5jaG9yIiwiYmVmb3JlTGF5b3V0IiwiZ2V0Q29udGVudFNpemUiLCJhZnRlckxheW91dCIsImdldFZpc2libGVSZWN0IiwicmVzdG9yZWRTY3JvbGxBbmNob3IiLCJfcmVzdG9yZVNjcm9sbEFuY2hvciIsImNvbnRlbnRPZmZzZXRYIiwiY29udGVudE9mZnNldFkiLCJoYXNMYXlvdXRVcGRhdGVzIiwidHJhbnNhY3Rpb24iLCJfYXBwbHlMYXlvdXRJbmZvcyIsIl9lbmFibGVUcmFuc2l0aW9ucyIsImRvbmUiLCJfZGlzYWJsZVRyYW5zaXRpb25zIiwiYWZ0ZXJBbmltYXRpb24iLCJzZXRUaW1lb3V0IiwiX2NvcnJlY3RJdGVtT3JkZXIiLCJfaXNTY3JvbGxpbmciLCJfdHJhbnNhY3Rpb24iLCJfdmlzaWJsZUxheW91dEluZm9zIiwiX2NoaWxkcmVuIiwiZGVsZXRlIiwiYmVnaW5BbmltYXRpb25zIiwiZW5kQW5pbWF0aW9ucyIsImFuY2hvclNjcm9sbFBvc2l0aW9uIiwiZ2V0U2Nyb2xsQW5jaG9yIiwiY29ybmVyIiwiYW5jaG9yU2Nyb2xsUG9zaXRpb25BdFRvcCIsImNvcm5lckFuY2hvciIsImNvbnRlbnRPZmZzZXQiLCJfY29udGV4dF90cmFuc2FjdGlvbiIsImZpbmFsQW5jaG9yIiwiYWRqdXN0bWVudCIsIl9nZXRMYXlvdXRJbmZvTWFwIiwibWFwIiwidmlzaWJsZUxheW91dEluZm9zIiwiY3VycmVudGx5VmlzaWJsZSIsIml0ZW0iLCJyZXVzZVZpZXciLCJfYXBwbHlMYXlvdXRJbmZvIiwicmVtb3ZlVmlld3MiLCJfZmx1c2hWaXNpYmxlVmlld3MiLCJfaGFzTGF5b3V0VXBkYXRlcyIsImFmdGVyUmVuZGVyIiwiX3RyYW5zYWN0aW9uUXVldWUiLCJfcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUiLCJ2aWV3c0J5UGFyZW50S2V5IiwiX3ZpZXdfbGF5b3V0SW5mbyIsIl92aWV3c0J5UGFyZW50S2V5X2dldCIsIl92aWV3X2xheW91dEluZm8xIiwiX3ZpZXdfbGF5b3V0SW5mbzIiLCJfdmlld19sYXlvdXRJbmZvMyIsInB1c2giLCJidWlsZFRyZWUiLCJwYXJlbnQiLCJ2aWV3cyIsImNoaWxkcmVuIiwicmVuZGVyV3JhcHBlciIsImNoaWxkVmlld3MiLCJzZXRWaXNpYmxlVmlld3MiLCJ1cGRhdGVkIiwiY3VyIiwidXBkYXRlSXRlbVNpemUiLCJfc2l6ZVVwZGF0ZVF1ZXVlIiwiY2hhbmdlZCIsInN0YXJ0U2Nyb2xsaW5nIiwiZW5kU2Nyb2xsaW5nIiwic2Nyb2xsVG9JdGVtIiwib3B0aW9ucyIsInNob3VsZFNjcm9sbFgiLCJzaG91bGRTY3JvbGxZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJtaW5YIiwibWluWSIsInNjcm9sbFRvIiwidGhlbiIsImNsZWFyIiwiYWN0aW9uIiwiX3N0YXJ0VHJhbnNhY3Rpb24iLCJfbmV4dFRyYW5zYWN0aW9uIiwiX2VuZFRyYW5zYWN0aW9uIiwibmV4dCIsInNoaWZ0IiwiX3BlcmZvcm1UcmFuc2FjdGlvbiIsIl9nZXRDb250ZW50UmVjdCIsIl9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyIsIldlYWtNYXAiLCJfb3B0aW9uc190cmFuc2l0aW9uRHVyYXRpb24iLCIkZmMwYjEzYjQ4NGFjMTE5NCRleHBvcnQkMTUwNWRiODJmZTM1N2U2NSIsIm9wdHMiLCJpc0FuaW1hdGluZyIsInNldEFuaW1hdGluZyIsImlzU2Nyb2xsaW5nIiwic2V0U2Nyb2xsaW5nIiwib25WaXNpYmxlUmVjdENoYW5nZSIsInN0YXRlIiwiTGF5b3V0IiwiTGF5b3V0SW5mbyIsIlBvaW50IiwiUmVjdCIsIlNpemUiLCJSZXVzYWJsZVZpZXciLCJ1c2VWaXJ0dWFsaXplclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;